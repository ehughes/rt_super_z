
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

18000000 <flexspi_config-0x400>:
	...

18000400 <flexspi_config>:
18000400:	46 43 46 42 00 04 01 56 00 00 00 00 00 03 03 00     FCFB...V........
18000410:	00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
18000440:	10 00 00 00 01 04 02 00 00 00 00 00 00 00 00 00     ................
18000450:	00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
18000480:	eb 04 18 0a 06 32 04 26 00 00 00 00 00 00 00 00     .....2.&........
18000490:	05 04 04 24 00 00 00 00 00 00 00 00 00 00 00 00     ...$............
	...
180004b0:	06 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
180005c0:	00 01 00 00 00 10 00 00 01 00 00 00 00 00 00 00     ................
180005d0:	00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

18001000 <image_vector_table>:
18001000:	58 21 18 30 c9 55 00 18 dd 9d 00 18 9d 55 00 18     X!.0.U.......U..
18001010:	9d 55 00 18 9d 55 00 18 9d 55 00 18 9d 55 00 18     .U...U...U...U..
18001020:	24 df 00 00 00 00 00 00 00 00 00 00 39 4d 00 18     $...........9M..
18001030:	9d 55 00 18 00 10 00 18 dd 4c 00 18 9d 55 00 18     .U.......L...U..
	...

18001200 <_vector_table>:
18001200:	58 21 18 30 c9 55 00 18 dd 9d 00 18 9d 55 00 18     X!.0.U.......U..
18001210:	9d 55 00 18 9d 55 00 18 9d 55 00 18 9d 55 00 18     .U...U...U...U..
	...
1800122c:	39 4d 00 18 9d 55 00 18 00 00 00 00 dd 4c 00 18     9M...U.......L..
1800123c:	9d 55 00 18                                         .U..

18001240 <_irq_vector_table>:
18001240:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001250:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001260:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001270:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001280:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001290:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
180012a0:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
180012b0:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
180012c0:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
180012d0:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
180012e0:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
180012f0:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001300:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001310:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..
18001320:	bd 4d 00 18 bd 4d 00 18 bd 4d 00 18 bd 4d 00 18     .M...M...M...M..

Disassembly of section text:

18001330 <__aeabi_uldivmod>:
18001330:	b953      	cbnz	r3, 18001348 <__aeabi_uldivmod+0x18>
18001332:	b94a      	cbnz	r2, 18001348 <__aeabi_uldivmod+0x18>
18001334:	2900      	cmp	r1, #0
18001336:	bf08      	it	eq
18001338:	2800      	cmpeq	r0, #0
1800133a:	bf1c      	itt	ne
1800133c:	f04f 31ff 	movne.w	r1, #4294967295
18001340:	f04f 30ff 	movne.w	r0, #4294967295
18001344:	f000 b980 	b.w	18001648 <__aeabi_idiv0>
18001348:	f1ad 0c08 	sub.w	ip, sp, #8
1800134c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
18001350:	f000 f806 	bl	18001360 <__udivmoddi4>
18001354:	f8dd e004 	ldr.w	lr, [sp, #4]
18001358:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1800135c:	b004      	add	sp, #16
1800135e:	4770      	bx	lr

18001360 <__udivmoddi4>:
18001360:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18001364:	9e09      	ldr	r6, [sp, #36]	; 0x24
18001366:	460d      	mov	r5, r1
18001368:	4604      	mov	r4, r0
1800136a:	460f      	mov	r7, r1
1800136c:	2b00      	cmp	r3, #0
1800136e:	d147      	bne.n	18001400 <__udivmoddi4+0xa0>
18001370:	428a      	cmp	r2, r1
18001372:	4694      	mov	ip, r2
18001374:	d95f      	bls.n	18001436 <__udivmoddi4+0xd6>
18001376:	fab2 f382 	clz	r3, r2
1800137a:	b143      	cbz	r3, 1800138e <__udivmoddi4+0x2e>
1800137c:	f1c3 0120 	rsb	r1, r3, #32
18001380:	409f      	lsls	r7, r3
18001382:	fa02 fc03 	lsl.w	ip, r2, r3
18001386:	409c      	lsls	r4, r3
18001388:	fa20 f101 	lsr.w	r1, r0, r1
1800138c:	430f      	orrs	r7, r1
1800138e:	ea4f 451c 	mov.w	r5, ip, lsr #16
18001392:	fa1f fe8c 	uxth.w	lr, ip
18001396:	0c22      	lsrs	r2, r4, #16
18001398:	fbb7 f1f5 	udiv	r1, r7, r5
1800139c:	fb05 7711 	mls	r7, r5, r1, r7
180013a0:	fb01 f00e 	mul.w	r0, r1, lr
180013a4:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
180013a8:	4290      	cmp	r0, r2
180013aa:	d908      	bls.n	180013be <__udivmoddi4+0x5e>
180013ac:	eb1c 0202 	adds.w	r2, ip, r2
180013b0:	f101 37ff 	add.w	r7, r1, #4294967295
180013b4:	d202      	bcs.n	180013bc <__udivmoddi4+0x5c>
180013b6:	4290      	cmp	r0, r2
180013b8:	f200 8134 	bhi.w	18001624 <__udivmoddi4+0x2c4>
180013bc:	4639      	mov	r1, r7
180013be:	1a12      	subs	r2, r2, r0
180013c0:	b2a4      	uxth	r4, r4
180013c2:	fbb2 f0f5 	udiv	r0, r2, r5
180013c6:	fb05 2210 	mls	r2, r5, r0, r2
180013ca:	fb00 fe0e 	mul.w	lr, r0, lr
180013ce:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
180013d2:	45a6      	cmp	lr, r4
180013d4:	d908      	bls.n	180013e8 <__udivmoddi4+0x88>
180013d6:	eb1c 0404 	adds.w	r4, ip, r4
180013da:	f100 32ff 	add.w	r2, r0, #4294967295
180013de:	d202      	bcs.n	180013e6 <__udivmoddi4+0x86>
180013e0:	45a6      	cmp	lr, r4
180013e2:	f200 8119 	bhi.w	18001618 <__udivmoddi4+0x2b8>
180013e6:	4610      	mov	r0, r2
180013e8:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
180013ec:	eba4 040e 	sub.w	r4, r4, lr
180013f0:	2100      	movs	r1, #0
180013f2:	b11e      	cbz	r6, 180013fc <__udivmoddi4+0x9c>
180013f4:	40dc      	lsrs	r4, r3
180013f6:	2300      	movs	r3, #0
180013f8:	e9c6 4300 	strd	r4, r3, [r6]
180013fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
18001400:	428b      	cmp	r3, r1
18001402:	d908      	bls.n	18001416 <__udivmoddi4+0xb6>
18001404:	2e00      	cmp	r6, #0
18001406:	f000 80fb 	beq.w	18001600 <__udivmoddi4+0x2a0>
1800140a:	2100      	movs	r1, #0
1800140c:	e9c6 0500 	strd	r0, r5, [r6]
18001410:	4608      	mov	r0, r1
18001412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
18001416:	fab3 f183 	clz	r1, r3
1800141a:	2900      	cmp	r1, #0
1800141c:	d14b      	bne.n	180014b6 <__udivmoddi4+0x156>
1800141e:	42ab      	cmp	r3, r5
18001420:	f0c0 80f1 	bcc.w	18001606 <__udivmoddi4+0x2a6>
18001424:	4282      	cmp	r2, r0
18001426:	f240 80ee 	bls.w	18001606 <__udivmoddi4+0x2a6>
1800142a:	4608      	mov	r0, r1
1800142c:	2e00      	cmp	r6, #0
1800142e:	d0e5      	beq.n	180013fc <__udivmoddi4+0x9c>
18001430:	e9c6 4700 	strd	r4, r7, [r6]
18001434:	e7e2      	b.n	180013fc <__udivmoddi4+0x9c>
18001436:	b902      	cbnz	r2, 1800143a <__udivmoddi4+0xda>
18001438:	deff      	udf	#255	; 0xff
1800143a:	fab2 f382 	clz	r3, r2
1800143e:	2b00      	cmp	r3, #0
18001440:	f040 809d 	bne.w	1800157e <__udivmoddi4+0x21e>
18001444:	1a8d      	subs	r5, r1, r2
18001446:	ea4f 4e12 	mov.w	lr, r2, lsr #16
1800144a:	b297      	uxth	r7, r2
1800144c:	2101      	movs	r1, #1
1800144e:	fbb5 f2fe 	udiv	r2, r5, lr
18001452:	fb0e 5012 	mls	r0, lr, r2, r5
18001456:	0c25      	lsrs	r5, r4, #16
18001458:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
1800145c:	fb07 f002 	mul.w	r0, r7, r2
18001460:	42a8      	cmp	r0, r5
18001462:	d90f      	bls.n	18001484 <__udivmoddi4+0x124>
18001464:	eb1c 0505 	adds.w	r5, ip, r5
18001468:	f102 38ff 	add.w	r8, r2, #4294967295
1800146c:	bf2c      	ite	cs
1800146e:	f04f 0901 	movcs.w	r9, #1
18001472:	f04f 0900 	movcc.w	r9, #0
18001476:	42a8      	cmp	r0, r5
18001478:	d903      	bls.n	18001482 <__udivmoddi4+0x122>
1800147a:	f1b9 0f00 	cmp.w	r9, #0
1800147e:	f000 80ce 	beq.w	1800161e <__udivmoddi4+0x2be>
18001482:	4642      	mov	r2, r8
18001484:	1a2d      	subs	r5, r5, r0
18001486:	b2a4      	uxth	r4, r4
18001488:	fbb5 f0fe 	udiv	r0, r5, lr
1800148c:	fb0e 5510 	mls	r5, lr, r0, r5
18001490:	fb00 f707 	mul.w	r7, r0, r7
18001494:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
18001498:	42a7      	cmp	r7, r4
1800149a:	d908      	bls.n	180014ae <__udivmoddi4+0x14e>
1800149c:	eb1c 0404 	adds.w	r4, ip, r4
180014a0:	f100 35ff 	add.w	r5, r0, #4294967295
180014a4:	d202      	bcs.n	180014ac <__udivmoddi4+0x14c>
180014a6:	42a7      	cmp	r7, r4
180014a8:	f200 80b3 	bhi.w	18001612 <__udivmoddi4+0x2b2>
180014ac:	4628      	mov	r0, r5
180014ae:	1be4      	subs	r4, r4, r7
180014b0:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
180014b4:	e79d      	b.n	180013f2 <__udivmoddi4+0x92>
180014b6:	f1c1 0720 	rsb	r7, r1, #32
180014ba:	408b      	lsls	r3, r1
180014bc:	fa05 f401 	lsl.w	r4, r5, r1
180014c0:	fa22 fc07 	lsr.w	ip, r2, r7
180014c4:	40fd      	lsrs	r5, r7
180014c6:	408a      	lsls	r2, r1
180014c8:	ea4c 0c03 	orr.w	ip, ip, r3
180014cc:	fa20 f307 	lsr.w	r3, r0, r7
180014d0:	ea4f 491c 	mov.w	r9, ip, lsr #16
180014d4:	431c      	orrs	r4, r3
180014d6:	fa1f fe8c 	uxth.w	lr, ip
180014da:	fa00 f301 	lsl.w	r3, r0, r1
180014de:	0c20      	lsrs	r0, r4, #16
180014e0:	fbb5 f8f9 	udiv	r8, r5, r9
180014e4:	fb09 5518 	mls	r5, r9, r8, r5
180014e8:	ea40 4505 	orr.w	r5, r0, r5, lsl #16
180014ec:	fb08 f00e 	mul.w	r0, r8, lr
180014f0:	42a8      	cmp	r0, r5
180014f2:	d90f      	bls.n	18001514 <__udivmoddi4+0x1b4>
180014f4:	eb1c 0505 	adds.w	r5, ip, r5
180014f8:	f108 3aff 	add.w	sl, r8, #4294967295
180014fc:	bf2c      	ite	cs
180014fe:	f04f 0b01 	movcs.w	fp, #1
18001502:	f04f 0b00 	movcc.w	fp, #0
18001506:	42a8      	cmp	r0, r5
18001508:	d903      	bls.n	18001512 <__udivmoddi4+0x1b2>
1800150a:	f1bb 0f00 	cmp.w	fp, #0
1800150e:	f000 808c 	beq.w	1800162a <__udivmoddi4+0x2ca>
18001512:	46d0      	mov	r8, sl
18001514:	1a2d      	subs	r5, r5, r0
18001516:	b2a4      	uxth	r4, r4
18001518:	fbb5 f0f9 	udiv	r0, r5, r9
1800151c:	fb09 5510 	mls	r5, r9, r0, r5
18001520:	fb00 fe0e 	mul.w	lr, r0, lr
18001524:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
18001528:	45ae      	cmp	lr, r5
1800152a:	d907      	bls.n	1800153c <__udivmoddi4+0x1dc>
1800152c:	eb1c 0505 	adds.w	r5, ip, r5
18001530:	f100 34ff 	add.w	r4, r0, #4294967295
18001534:	d201      	bcs.n	1800153a <__udivmoddi4+0x1da>
18001536:	45ae      	cmp	lr, r5
18001538:	d87e      	bhi.n	18001638 <__udivmoddi4+0x2d8>
1800153a:	4620      	mov	r0, r4
1800153c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
18001540:	eba5 050e 	sub.w	r5, r5, lr
18001544:	fba0 9802 	umull	r9, r8, r0, r2
18001548:	4545      	cmp	r5, r8
1800154a:	464c      	mov	r4, r9
1800154c:	46c6      	mov	lr, r8
1800154e:	d302      	bcc.n	18001556 <__udivmoddi4+0x1f6>
18001550:	d106      	bne.n	18001560 <__udivmoddi4+0x200>
18001552:	454b      	cmp	r3, r9
18001554:	d204      	bcs.n	18001560 <__udivmoddi4+0x200>
18001556:	3801      	subs	r0, #1
18001558:	ebb9 0402 	subs.w	r4, r9, r2
1800155c:	eb68 0e0c 	sbc.w	lr, r8, ip
18001560:	2e00      	cmp	r6, #0
18001562:	d06f      	beq.n	18001644 <__udivmoddi4+0x2e4>
18001564:	1b1a      	subs	r2, r3, r4
18001566:	eb65 050e 	sbc.w	r5, r5, lr
1800156a:	fa22 f301 	lsr.w	r3, r2, r1
1800156e:	fa05 f707 	lsl.w	r7, r5, r7
18001572:	40cd      	lsrs	r5, r1
18001574:	2100      	movs	r1, #0
18001576:	431f      	orrs	r7, r3
18001578:	e9c6 7500 	strd	r7, r5, [r6]
1800157c:	e73e      	b.n	180013fc <__udivmoddi4+0x9c>
1800157e:	fa02 fc03 	lsl.w	ip, r2, r3
18001582:	f1c3 0020 	rsb	r0, r3, #32
18001586:	fa01 f203 	lsl.w	r2, r1, r3
1800158a:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
1800158e:	40c1      	lsrs	r1, r0
18001590:	fa24 f500 	lsr.w	r5, r4, r0
18001594:	fa1f f78c 	uxth.w	r7, ip
18001598:	409c      	lsls	r4, r3
1800159a:	4315      	orrs	r5, r2
1800159c:	fbb1 f0fe 	udiv	r0, r1, lr
180015a0:	0c2a      	lsrs	r2, r5, #16
180015a2:	fb0e 1110 	mls	r1, lr, r0, r1
180015a6:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
180015aa:	fb00 f107 	mul.w	r1, r0, r7
180015ae:	4291      	cmp	r1, r2
180015b0:	d90e      	bls.n	180015d0 <__udivmoddi4+0x270>
180015b2:	eb1c 0202 	adds.w	r2, ip, r2
180015b6:	f100 38ff 	add.w	r8, r0, #4294967295
180015ba:	bf2c      	ite	cs
180015bc:	f04f 0901 	movcs.w	r9, #1
180015c0:	f04f 0900 	movcc.w	r9, #0
180015c4:	4291      	cmp	r1, r2
180015c6:	d902      	bls.n	180015ce <__udivmoddi4+0x26e>
180015c8:	f1b9 0f00 	cmp.w	r9, #0
180015cc:	d031      	beq.n	18001632 <__udivmoddi4+0x2d2>
180015ce:	4640      	mov	r0, r8
180015d0:	1a52      	subs	r2, r2, r1
180015d2:	b2ad      	uxth	r5, r5
180015d4:	fbb2 f1fe 	udiv	r1, r2, lr
180015d8:	fb0e 2211 	mls	r2, lr, r1, r2
180015dc:	ea45 4502 	orr.w	r5, r5, r2, lsl #16
180015e0:	fb01 f207 	mul.w	r2, r1, r7
180015e4:	42aa      	cmp	r2, r5
180015e6:	d907      	bls.n	180015f8 <__udivmoddi4+0x298>
180015e8:	eb1c 0505 	adds.w	r5, ip, r5
180015ec:	f101 38ff 	add.w	r8, r1, #4294967295
180015f0:	d201      	bcs.n	180015f6 <__udivmoddi4+0x296>
180015f2:	42aa      	cmp	r2, r5
180015f4:	d823      	bhi.n	1800163e <__udivmoddi4+0x2de>
180015f6:	4641      	mov	r1, r8
180015f8:	1aad      	subs	r5, r5, r2
180015fa:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
180015fe:	e726      	b.n	1800144e <__udivmoddi4+0xee>
18001600:	4631      	mov	r1, r6
18001602:	4630      	mov	r0, r6
18001604:	e6fa      	b.n	180013fc <__udivmoddi4+0x9c>
18001606:	1a84      	subs	r4, r0, r2
18001608:	eb65 0303 	sbc.w	r3, r5, r3
1800160c:	2001      	movs	r0, #1
1800160e:	461f      	mov	r7, r3
18001610:	e70c      	b.n	1800142c <__udivmoddi4+0xcc>
18001612:	4464      	add	r4, ip
18001614:	3802      	subs	r0, #2
18001616:	e74a      	b.n	180014ae <__udivmoddi4+0x14e>
18001618:	4464      	add	r4, ip
1800161a:	3802      	subs	r0, #2
1800161c:	e6e4      	b.n	180013e8 <__udivmoddi4+0x88>
1800161e:	3a02      	subs	r2, #2
18001620:	4465      	add	r5, ip
18001622:	e72f      	b.n	18001484 <__udivmoddi4+0x124>
18001624:	3902      	subs	r1, #2
18001626:	4462      	add	r2, ip
18001628:	e6c9      	b.n	180013be <__udivmoddi4+0x5e>
1800162a:	f1a8 0802 	sub.w	r8, r8, #2
1800162e:	4465      	add	r5, ip
18001630:	e770      	b.n	18001514 <__udivmoddi4+0x1b4>
18001632:	3802      	subs	r0, #2
18001634:	4462      	add	r2, ip
18001636:	e7cb      	b.n	180015d0 <__udivmoddi4+0x270>
18001638:	3802      	subs	r0, #2
1800163a:	4465      	add	r5, ip
1800163c:	e77e      	b.n	1800153c <__udivmoddi4+0x1dc>
1800163e:	3902      	subs	r1, #2
18001640:	4465      	add	r5, ip
18001642:	e7d9      	b.n	180015f8 <__udivmoddi4+0x298>
18001644:	4631      	mov	r1, r6
18001646:	e6d9      	b.n	180013fc <__udivmoddi4+0x9c>

18001648 <__aeabi_idiv0>:
18001648:	4770      	bx	lr
1800164a:	bf00      	nop

1800164c <monkey_handler>:
LOG_MODULE_REGISTER(main);

static int monkey_handler(const struct shell *shell, 
                      size_t argc,
                      char **argv)
{
1800164c:	b538      	push	{r3, r4, r5, lr}
1800164e:	4604      	mov	r4, r0
   ARG_UNUSED(argc);
   ARG_UNUSED(argv);

   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"\r\n");
18001650:	4d3c      	ldr	r5, [pc, #240]	; (18001744 <monkey_handler+0xf8>)
18001652:	2103      	movs	r1, #3
18001654:	462a      	mov	r2, r5
18001656:	f007 fcaf 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"                 ██████████████████████████            \r\n");
1800165a:	4620      	mov	r0, r4
1800165c:	2103      	movs	r1, #3
1800165e:	4a3a      	ldr	r2, [pc, #232]	; (18001748 <monkey_handler+0xfc>)
18001660:	f007 fcaa 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"               ██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██          \r\n");
18001664:	4620      	mov	r0, r4
18001666:	2103      	movs	r1, #3
18001668:	4a38      	ldr	r2, [pc, #224]	; (1800174c <monkey_handler+0x100>)
1800166a:	f007 fca5 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"               ██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██        \r\n");
1800166e:	4620      	mov	r0, r4
18001670:	2103      	movs	r1, #3
18001672:	4a37      	ldr	r2, [pc, #220]	; (18001750 <monkey_handler+0x104>)
18001674:	f007 fca0 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"             ██▒▒▒▒░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░██        \r\n");
18001678:	4620      	mov	r0, r4
1800167a:	2103      	movs	r1, #3
1800167c:	4a35      	ldr	r2, [pc, #212]	; (18001754 <monkey_handler+0x108>)
1800167e:	f007 fc9b 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"         ██████▒▒░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░██      \r\n");
18001682:	4620      	mov	r0, r4
18001684:	2103      	movs	r1, #3
18001686:	4a34      	ldr	r2, [pc, #208]	; (18001758 <monkey_handler+0x10c>)
18001688:	f007 fc96 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"       ██░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██████  \r\n");
1800168c:	4620      	mov	r0, r4
1800168e:	2103      	movs	r1, #3
18001690:	4a32      	ldr	r2, [pc, #200]	; (1800175c <monkey_handler+0x110>)
18001692:	f007 fc91 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"       ██░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██░░░░██\r\n");
18001696:	4620      	mov	r0, r4
18001698:	2103      	movs	r1, #3
1800169a:	4a31      	ldr	r2, [pc, #196]	; (18001760 <monkey_handler+0x114>)
1800169c:	f007 fc8c 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"       ██░░░░░░▒▒░░░░░░░░░░██░░░░░░░░██░░░░░░░░██░░░░██\r\n");
180016a0:	4620      	mov	r0, r4
180016a2:	2103      	movs	r1, #3
180016a4:	4a2f      	ldr	r2, [pc, #188]	; (18001764 <monkey_handler+0x118>)
180016a6:	f007 fc87 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"         ████░░▒▒░░░░░░░░░░██░░░░░░░░██░░░░░░░░██████  \r\n");
180016aa:	4620      	mov	r0, r4
180016ac:	2103      	movs	r1, #3
180016ae:	4a2e      	ldr	r2, [pc, #184]	; (18001768 <monkey_handler+0x11c>)
180016b0:	f007 fc82 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"             ██▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██      \r\n");
180016b4:	4620      	mov	r0, r4
180016b6:	2103      	movs	r1, #3
180016b8:	4a2c      	ldr	r2, [pc, #176]	; (1800176c <monkey_handler+0x120>)
180016ba:	f007 fc7d 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"     ████      ██▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░██        \r\n");
180016be:	4620      	mov	r0, r4
180016c0:	2103      	movs	r1, #3
180016c2:	4a2b      	ldr	r2, [pc, #172]	; (18001770 <monkey_handler+0x124>)
180016c4:	f007 fc78 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"   ██    ██      ██▒▒░░░░░░░░░░░░░░░░░░░░░░██          \r\n");
180016c8:	4620      	mov	r0, r4
180016ca:	2103      	movs	r1, #3
180016cc:	4a29      	ldr	r2, [pc, #164]	; (18001774 <monkey_handler+0x128>)
180016ce:	f007 fc73 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"   ██  ██      ██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██        \r\n");
180016d2:	4620      	mov	r0, r4
180016d4:	2103      	movs	r1, #3
180016d6:	4a28      	ldr	r2, [pc, #160]	; (18001778 <monkey_handler+0x12c>)
180016d8:	f007 fc6e 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"   ██          ██▒▒▒▒▒▒▒▒░░░░░░░░░░░░▒▒▒▒▒▒▒▒██        \r\n");
180016dc:	4620      	mov	r0, r4
180016de:	2103      	movs	r1, #3
180016e0:	4a26      	ldr	r2, [pc, #152]	; (1800177c <monkey_handler+0x130>)
180016e2:	f007 fc69 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"     ████    ██▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒██      \r\n");
180016e6:	4620      	mov	r0, r4
180016e8:	2103      	movs	r1, #3
180016ea:	4a25      	ldr	r2, [pc, #148]	; (18001780 <monkey_handler+0x134>)
180016ec:	f007 fc64 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"         ██████▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒██      \r\n");
180016f0:	4620      	mov	r0, r4
180016f2:	2103      	movs	r1, #3
180016f4:	4a23      	ldr	r2, [pc, #140]	; (18001784 <monkey_handler+0x138>)
180016f6:	f007 fc5f 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"             ██▒▒▒▒██▒▒░░░░░░░░░░░░░░░░▒▒██▒▒▒▒██      \r\n");
180016fa:	4620      	mov	r0, r4
180016fc:	2103      	movs	r1, #3
180016fe:	4a22      	ldr	r2, [pc, #136]	; (18001788 <monkey_handler+0x13c>)
18001700:	f007 fc5a 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"               ██████▒▒▒▒░░░░░░░░░░░░▒▒▒▒██████        \r\n");
18001704:	4620      	mov	r0, r4
18001706:	2103      	movs	r1, #3
18001708:	4a20      	ldr	r2, [pc, #128]	; (1800178c <monkey_handler+0x140>)
1800170a:	f007 fc55 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"                   ██▒▒▒▒▒▒████████▒▒▒▒▒▒██            \r\n");
1800170e:	4620      	mov	r0, r4
18001710:	2103      	movs	r1, #3
18001712:	4a1f      	ldr	r2, [pc, #124]	; (18001790 <monkey_handler+0x144>)
18001714:	f007 fc50 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"                   ██░░░░██        ██░░░░██            \r\n");
18001718:	4620      	mov	r0, r4
1800171a:	2103      	movs	r1, #3
1800171c:	4a1d      	ldr	r2, [pc, #116]	; (18001794 <monkey_handler+0x148>)
1800171e:	f007 fc4b 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"                   ██████            ██████            \r\n");
18001722:	4620      	mov	r0, r4
18001724:	2103      	movs	r1, #3
18001726:	4a1c      	ldr	r2, [pc, #112]	; (18001798 <monkey_handler+0x14c>)
18001728:	f007 fc46 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_YELLOW,"\r\n");
1800172c:	462a      	mov	r2, r5
1800172e:	4620      	mov	r0, r4
18001730:	2103      	movs	r1, #3
18001732:	f007 fc41 	bl	18008fb8 <shell_fprintf>
   shell_fprintf(shell,SHELL_VT100_COLOR_CYAN,"                          I'm Super\r\n");
18001736:	4620      	mov	r0, r4
18001738:	2106      	movs	r1, #6
1800173a:	4a18      	ldr	r2, [pc, #96]	; (1800179c <monkey_handler+0x150>)
1800173c:	f007 fc3c 	bl	18008fb8 <shell_fprintf>
      
   return 0;
}
18001740:	2000      	movs	r0, #0
18001742:	bd38      	pop	{r3, r4, r5, pc}
18001744:	1800c8a9 	.word	0x1800c8a9
18001748:	1800bc30 	.word	0x1800bc30
1800174c:	1800bc9e 	.word	0x1800bc9e
18001750:	1800bd14 	.word	0x1800bd14
18001754:	1800bd8e 	.word	0x1800bd8e
18001758:	1800be0c 	.word	0x1800be0c
1800175c:	1800be96 	.word	0x1800be96
18001760:	1800bf2c 	.word	0x1800bf2c
18001764:	1800bfc6 	.word	0x1800bfc6
18001768:	1800c060 	.word	0x1800c060
1800176c:	1800c0f2 	.word	0x1800c0f2
18001770:	1800c174 	.word	0x1800c174
18001774:	1800c1f6 	.word	0x1800c1f6
18001778:	1800c270 	.word	0x1800c270
1800177c:	1800c2f2 	.word	0x1800c2f2
18001780:	1800c370 	.word	0x1800c370
18001784:	1800c3fa 	.word	0x1800c3fa
18001788:	1800c484 	.word	0x1800c484
1800178c:	1800c506 	.word	0x1800c506
18001790:	1800c580 	.word	0x1800c580
18001794:	1800c5ea 	.word	0x1800c5ea
18001798:	1800c644 	.word	0x1800c644
1800179c:	1800c696 	.word	0x1800c696

180017a0 <main>:


void main(void)
{

	LOG_INF("The RT685 SuperMonkey is running.");
180017a0:	490a      	ldr	r1, [pc, #40]	; (180017cc <main+0x2c>)
{
180017a2:	b508      	push	{r3, lr}
	LOG_INF("The RT685 SuperMonkey is running.");
180017a4:	680b      	ldr	r3, [r1, #0]
180017a6:	f003 0307 	and.w	r3, r3, #7
180017aa:	2b02      	cmp	r3, #2
180017ac:	d908      	bls.n	180017c0 <main+0x20>
 *
 * @return Source ID.
 */
static inline uint32_t log_dynamic_source_id(struct log_source_dynamic_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
180017ae:	4b08      	ldr	r3, [pc, #32]	; (180017d0 <main+0x30>)
180017b0:	4808      	ldr	r0, [pc, #32]	; (180017d4 <main+0x34>)
180017b2:	1ac9      	subs	r1, r1, r3
180017b4:	0889      	lsrs	r1, r1, #2
180017b6:	0189      	lsls	r1, r1, #6
180017b8:	f041 0103 	orr.w	r1, r1, #3
180017bc:	f006 fff7 	bl	180087ae <log_0>
		/* coverity[OVERRUN] */
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
180017c0:	2100      	movs	r1, #0
180017c2:	f242 7010 	movw	r0, #10000	; 0x2710
180017c6:	f005 ffcf 	bl	18007768 <z_impl_k_sleep>

	while(1)
180017ca:	e7f9      	b.n	180017c0 <main+0x20>
180017cc:	30180094 	.word	0x30180094
180017d0:	3018008c 	.word	0x3018008c
180017d4:	1800c6bc 	.word	0x1800c6bc

180017d8 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
180017d8:	680b      	ldr	r3, [r1, #0]
180017da:	3301      	adds	r3, #1
180017dc:	600b      	str	r3, [r1, #0]
	return _char_out(c);
180017de:	4b01      	ldr	r3, [pc, #4]	; (180017e4 <char_out+0xc>)
180017e0:	681b      	ldr	r3, [r3, #0]
180017e2:	4718      	bx	r3
180017e4:	30180000 	.word	0x30180000

180017e8 <__printk_hook_install>:
	_char_out = fn;
180017e8:	4b01      	ldr	r3, [pc, #4]	; (180017f0 <__printk_hook_install+0x8>)
180017ea:	6018      	str	r0, [r3, #0]
}
180017ec:	4770      	bx	lr
180017ee:	bf00      	nop
180017f0:	30180000 	.word	0x30180000

180017f4 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
180017f4:	b507      	push	{r0, r1, r2, lr}
180017f6:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
180017f8:	2100      	movs	r1, #0
{
180017fa:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
180017fc:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
180017fe:	4803      	ldr	r0, [pc, #12]	; (1800180c <vprintk+0x18>)
18001800:	a901      	add	r1, sp, #4
18001802:	f000 f819 	bl	18001838 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
18001806:	b003      	add	sp, #12
18001808:	f85d fb04 	ldr.w	pc, [sp], #4
1800180c:	180017d9 	.word	0x180017d9

18001810 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
18001810:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
18001812:	2500      	movs	r5, #0
{
18001814:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
18001816:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
1800181a:	4604      	mov	r4, r0

	cbvprintf(str_out, &ctx, fmt, ap);
1800181c:	a901      	add	r1, sp, #4
1800181e:	4805      	ldr	r0, [pc, #20]	; (18001834 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
18001820:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
18001822:	f000 f809 	bl	18001838 <cbvprintf>

	if (ctx.count < ctx.max) {
18001826:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
1800182a:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
1800182c:	bfb8      	it	lt
1800182e:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
18001830:	b005      	add	sp, #20
18001832:	bd30      	pop	{r4, r5, pc}
18001834:	18008053 	.word	0x18008053

18001838 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
18001838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1800183c:	468b      	mov	fp, r1
1800183e:	4692      	mov	sl, r2
18001840:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
18001842:	2500      	movs	r5, #0
{
18001844:	b091      	sub	sp, #68	; 0x44
18001846:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
18001848:	f89a 0000 	ldrb.w	r0, [sl]
1800184c:	b908      	cbnz	r0, 18001852 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
1800184e:	4628      	mov	r0, r5
18001850:	e35f      	b.n	18001f12 <cbvprintf+0x6da>
		if (*fp != '%') {
18001852:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
18001854:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
18001858:	d007      	beq.n	1800186a <cbvprintf+0x32>
			OUTC('%');
1800185a:	4659      	mov	r1, fp
1800185c:	9b02      	ldr	r3, [sp, #8]
1800185e:	4798      	blx	r3
18001860:	2800      	cmp	r0, #0
18001862:	f2c0 8356 	blt.w	18001f12 <cbvprintf+0x6da>
18001866:	3501      	adds	r5, #1
			break;
18001868:	e212      	b.n	18001c90 <cbvprintf+0x458>
		} state = {
1800186a:	2218      	movs	r2, #24
1800186c:	2100      	movs	r1, #0
1800186e:	a80a      	add	r0, sp, #40	; 0x28
18001870:	f008 fc7a 	bl	1800a168 <memset>
	if (*sp == '%') {
18001874:	f89a 3001 	ldrb.w	r3, [sl, #1]
18001878:	2b25      	cmp	r3, #37	; 0x25
1800187a:	d078      	beq.n	1800196e <cbvprintf+0x136>
1800187c:	2200      	movs	r2, #0
1800187e:	4610      	mov	r0, r2
18001880:	4696      	mov	lr, r2
18001882:	4694      	mov	ip, r2
18001884:	4616      	mov	r6, r2
18001886:	4639      	mov	r1, r7
		switch (*sp) {
18001888:	f817 3b01 	ldrb.w	r3, [r7], #1
1800188c:	2b2b      	cmp	r3, #43	; 0x2b
1800188e:	f000 809d 	beq.w	180019cc <cbvprintf+0x194>
18001892:	f200 8094 	bhi.w	180019be <cbvprintf+0x186>
18001896:	2b20      	cmp	r3, #32
18001898:	f000 809b 	beq.w	180019d2 <cbvprintf+0x19a>
1800189c:	2b23      	cmp	r3, #35	; 0x23
1800189e:	f000 809b 	beq.w	180019d8 <cbvprintf+0x1a0>
180018a2:	b12e      	cbz	r6, 180018b0 <cbvprintf+0x78>
180018a4:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
180018a8:	f046 0604 	orr.w	r6, r6, #4
180018ac:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
180018b0:	f1bc 0f00 	cmp.w	ip, #0
180018b4:	d005      	beq.n	180018c2 <cbvprintf+0x8a>
180018b6:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
180018ba:	f046 0608 	orr.w	r6, r6, #8
180018be:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
180018c2:	f1be 0f00 	cmp.w	lr, #0
180018c6:	d005      	beq.n	180018d4 <cbvprintf+0x9c>
180018c8:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
180018cc:	f046 0610 	orr.w	r6, r6, #16
180018d0:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
180018d4:	b128      	cbz	r0, 180018e2 <cbvprintf+0xaa>
180018d6:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
180018da:	f040 0020 	orr.w	r0, r0, #32
180018de:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
180018e2:	b12a      	cbz	r2, 180018f0 <cbvprintf+0xb8>
180018e4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
180018e8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
180018ec:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
180018f0:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
180018f4:	f002 0044 	and.w	r0, r2, #68	; 0x44
180018f8:	2844      	cmp	r0, #68	; 0x44
180018fa:	d103      	bne.n	18001904 <cbvprintf+0xcc>
		conv->flag_zero = false;
180018fc:	f36f 1286 	bfc	r2, #6, #1
18001900:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
18001904:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
18001908:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
1800190a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
1800190e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
18001912:	d17b      	bne.n	18001a0c <cbvprintf+0x1d4>
		conv->width_star = true;
18001914:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
			++sp;
18001918:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
1800191a:	f042 0201 	orr.w	r2, r2, #1
1800191e:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
18001922:	781a      	ldrb	r2, [r3, #0]
18001924:	2a2e      	cmp	r2, #46	; 0x2e
18001926:	bf0c      	ite	eq
18001928:	2101      	moveq	r1, #1
1800192a:	2100      	movne	r1, #0
1800192c:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
18001930:	f361 0241 	bfi	r2, r1, #1, #1
18001934:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
18001938:	d174      	bne.n	18001a24 <cbvprintf+0x1ec>
	if (*sp == '*') {
1800193a:	785a      	ldrb	r2, [r3, #1]
1800193c:	2a2a      	cmp	r2, #42	; 0x2a
1800193e:	d06a      	beq.n	18001a16 <cbvprintf+0x1de>
	size_t val = 0;
18001940:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
18001942:	260a      	movs	r6, #10
	++sp;
18001944:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
18001946:	4618      	mov	r0, r3
18001948:	f810 2b01 	ldrb.w	r2, [r0], #1
1800194c:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
18001950:	2f09      	cmp	r7, #9
18001952:	f240 808e 	bls.w	18001a72 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
18001956:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
1800195a:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
1800195c:	f3c2 0040 	ubfx	r0, r2, #1, #1
18001960:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
18001964:	f361 0241 	bfi	r2, r1, #1, #1
18001968:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
1800196c:	e05a      	b.n	18001a24 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
1800196e:	f10a 0702 	add.w	r7, sl, #2
18001972:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
18001976:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
1800197a:	07d9      	lsls	r1, r3, #31
1800197c:	f140 8149 	bpl.w	18001c12 <cbvprintf+0x3da>
			width = va_arg(ap, int);
18001980:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
18001984:	f1b9 0f00 	cmp.w	r9, #0
18001988:	da07      	bge.n	1800199a <cbvprintf+0x162>
				conv->flag_dash = true;
1800198a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
1800198e:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
18001992:	f042 0204 	orr.w	r2, r2, #4
18001996:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
1800199a:	075a      	lsls	r2, r3, #29
1800199c:	f140 8142 	bpl.w	18001c24 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
180019a0:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
180019a4:	f1b8 0f00 	cmp.w	r8, #0
180019a8:	f280 8141 	bge.w	18001c2e <cbvprintf+0x3f6>
				conv->prec_present = false;
180019ac:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
180019b0:	f36f 0341 	bfc	r3, #1, #1
180019b4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
180019b8:	f04f 38ff 	mov.w	r8, #4294967295
180019bc:	e137      	b.n	18001c2e <cbvprintf+0x3f6>
		switch (*sp) {
180019be:	2b2d      	cmp	r3, #45	; 0x2d
180019c0:	d00c      	beq.n	180019dc <cbvprintf+0x1a4>
180019c2:	2b30      	cmp	r3, #48	; 0x30
180019c4:	f47f af6d 	bne.w	180018a2 <cbvprintf+0x6a>
			conv->flag_zero = true;
180019c8:	2201      	movs	r2, #1
	} while (loop);
180019ca:	e75c      	b.n	18001886 <cbvprintf+0x4e>
			conv->flag_plus = true;
180019cc:	f04f 0c01 	mov.w	ip, #1
180019d0:	e759      	b.n	18001886 <cbvprintf+0x4e>
			conv->flag_space = true;
180019d2:	f04f 0e01 	mov.w	lr, #1
180019d6:	e756      	b.n	18001886 <cbvprintf+0x4e>
			conv->flag_hash = true;
180019d8:	2001      	movs	r0, #1
180019da:	e754      	b.n	18001886 <cbvprintf+0x4e>
		switch (*sp) {
180019dc:	2601      	movs	r6, #1
180019de:	e752      	b.n	18001886 <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
180019e0:	4633      	mov	r3, r6
180019e2:	fb0c 0202 	mla	r2, ip, r2, r0
180019e6:	3a30      	subs	r2, #48	; 0x30
180019e8:	461e      	mov	r6, r3
180019ea:	f816 0b01 	ldrb.w	r0, [r6], #1
180019ee:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
180019f2:	2f09      	cmp	r7, #9
180019f4:	d9f4      	bls.n	180019e0 <cbvprintf+0x1a8>
	if (sp != wp) {
180019f6:	4299      	cmp	r1, r3
180019f8:	d093      	beq.n	18001922 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
180019fa:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
180019fe:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
18001a00:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
18001a02:	f362 0141 	bfi	r1, r2, #1, #1
18001a06:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
18001a0a:	e78a      	b.n	18001922 <cbvprintf+0xea>
18001a0c:	460b      	mov	r3, r1
	size_t val = 0;
18001a0e:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
18001a10:	f04f 0c0a 	mov.w	ip, #10
18001a14:	e7e8      	b.n	180019e8 <cbvprintf+0x1b0>
		conv->prec_star = true;
18001a16:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
18001a1a:	3302      	adds	r3, #2
		conv->prec_star = true;
18001a1c:	f042 0204 	orr.w	r2, r2, #4
18001a20:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
18001a24:	461f      	mov	r7, r3
18001a26:	f817 2b01 	ldrb.w	r2, [r7], #1
18001a2a:	2a6c      	cmp	r2, #108	; 0x6c
18001a2c:	d041      	beq.n	18001ab2 <cbvprintf+0x27a>
18001a2e:	d825      	bhi.n	18001a7c <cbvprintf+0x244>
18001a30:	2a68      	cmp	r2, #104	; 0x68
18001a32:	d02b      	beq.n	18001a8c <cbvprintf+0x254>
18001a34:	2a6a      	cmp	r2, #106	; 0x6a
18001a36:	d046      	beq.n	18001ac6 <cbvprintf+0x28e>
18001a38:	2a4c      	cmp	r2, #76	; 0x4c
18001a3a:	d04c      	beq.n	18001ad6 <cbvprintf+0x29e>
18001a3c:	461f      	mov	r7, r3
	conv->specifier = *sp++;
18001a3e:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
18001a42:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
18001a46:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
18001a48:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
18001a4c:	f200 80d9 	bhi.w	18001c02 <cbvprintf+0x3ca>
18001a50:	2a57      	cmp	r2, #87	; 0x57
18001a52:	d84d      	bhi.n	18001af0 <cbvprintf+0x2b8>
18001a54:	2a41      	cmp	r2, #65	; 0x41
18001a56:	d003      	beq.n	18001a60 <cbvprintf+0x228>
18001a58:	3a45      	subs	r2, #69	; 0x45
18001a5a:	2a02      	cmp	r2, #2
18001a5c:	f200 80d1 	bhi.w	18001c02 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
18001a60:	2204      	movs	r2, #4
18001a62:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
18001a66:	f362 0302 	bfi	r3, r2, #0, #3
18001a6a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
18001a6e:	2301      	movs	r3, #1
			break;
18001a70:	e09e      	b.n	18001bb0 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
18001a72:	fb06 2101 	mla	r1, r6, r1, r2
18001a76:	4603      	mov	r3, r0
18001a78:	3930      	subs	r1, #48	; 0x30
18001a7a:	e764      	b.n	18001946 <cbvprintf+0x10e>
	switch (*sp) {
18001a7c:	2a74      	cmp	r2, #116	; 0x74
18001a7e:	d026      	beq.n	18001ace <cbvprintf+0x296>
18001a80:	2a7a      	cmp	r2, #122	; 0x7a
18001a82:	d1db      	bne.n	18001a3c <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
18001a84:	2206      	movs	r2, #6
18001a86:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
18001a8a:	e00d      	b.n	18001aa8 <cbvprintf+0x270>
		if (*++sp == 'h') {
18001a8c:	785a      	ldrb	r2, [r3, #1]
18001a8e:	2a68      	cmp	r2, #104	; 0x68
18001a90:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
18001a94:	d106      	bne.n	18001aa4 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
18001a96:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
18001a98:	f361 02c6 	bfi	r2, r1, #3, #4
18001a9c:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
18001aa0:	1c9f      	adds	r7, r3, #2
18001aa2:	e7cc      	b.n	18001a3e <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
18001aa4:	4613      	mov	r3, r2
18001aa6:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
18001aa8:	f362 03c6 	bfi	r3, r2, #3, #4
18001aac:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
18001ab0:	e7c5      	b.n	18001a3e <cbvprintf+0x206>
		if (*++sp == 'l') {
18001ab2:	785a      	ldrb	r2, [r3, #1]
18001ab4:	2a6c      	cmp	r2, #108	; 0x6c
18001ab6:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
18001aba:	d101      	bne.n	18001ac0 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
18001abc:	2104      	movs	r1, #4
18001abe:	e7eb      	b.n	18001a98 <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
18001ac0:	4613      	mov	r3, r2
18001ac2:	2203      	movs	r2, #3
18001ac4:	e7f0      	b.n	18001aa8 <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
18001ac6:	2205      	movs	r2, #5
18001ac8:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
18001acc:	e7ec      	b.n	18001aa8 <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
18001ace:	2207      	movs	r2, #7
18001ad0:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
18001ad4:	e7e8      	b.n	18001aa8 <cbvprintf+0x270>
		conv->unsupported = true;
18001ad6:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
18001ada:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
18001ade:	f023 0302 	bic.w	r3, r3, #2
18001ae2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
18001ae6:	f043 0302 	orr.w	r3, r3, #2
18001aea:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
18001aee:	e7a6      	b.n	18001a3e <cbvprintf+0x206>
	switch (conv->specifier) {
18001af0:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
18001af4:	2920      	cmp	r1, #32
18001af6:	f200 8084 	bhi.w	18001c02 <cbvprintf+0x3ca>
18001afa:	a001      	add	r0, pc, #4	; (adr r0, 18001b00 <cbvprintf+0x2c8>)
18001afc:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
18001b00:	18001bc5 	.word	0x18001bc5
18001b04:	18001c03 	.word	0x18001c03
18001b08:	18001c03 	.word	0x18001c03
18001b0c:	18001c03 	.word	0x18001c03
18001b10:	18001c03 	.word	0x18001c03
18001b14:	18001c03 	.word	0x18001c03
18001b18:	18001c03 	.word	0x18001c03
18001b1c:	18001c03 	.word	0x18001c03
18001b20:	18001c03 	.word	0x18001c03
18001b24:	18001a61 	.word	0x18001a61
18001b28:	18001c03 	.word	0x18001c03
18001b2c:	18001bc5 	.word	0x18001bc5
18001b30:	18001b85 	.word	0x18001b85
18001b34:	18001a61 	.word	0x18001a61
18001b38:	18001a61 	.word	0x18001a61
18001b3c:	18001a61 	.word	0x18001a61
18001b40:	18001c03 	.word	0x18001c03
18001b44:	18001b85 	.word	0x18001b85
18001b48:	18001c03 	.word	0x18001c03
18001b4c:	18001c03 	.word	0x18001c03
18001b50:	18001c03 	.word	0x18001c03
18001b54:	18001c03 	.word	0x18001c03
18001b58:	18001bcd 	.word	0x18001bcd
18001b5c:	18001bc5 	.word	0x18001bc5
18001b60:	18001be9 	.word	0x18001be9
18001b64:	18001c03 	.word	0x18001c03
18001b68:	18001c03 	.word	0x18001c03
18001b6c:	18001be9 	.word	0x18001be9
18001b70:	18001c03 	.word	0x18001c03
18001b74:	18001bc5 	.word	0x18001bc5
18001b78:	18001c03 	.word	0x18001c03
18001b7c:	18001c03 	.word	0x18001c03
18001b80:	18001bc5 	.word	0x18001bc5
		conv->specifier_cat = SPECIFIER_SINT;
18001b84:	2001      	movs	r0, #1
18001b86:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
18001b8a:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
18001b8e:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
18001b92:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
18001b94:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
18001b98:	bf02      	ittt	eq
18001b9a:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
18001b9e:	f041 0101 	orreq.w	r1, r1, #1
18001ba2:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
18001ba6:	2a63      	cmp	r2, #99	; 0x63
18001ba8:	d131      	bne.n	18001c0e <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
18001baa:	3b00      	subs	r3, #0
18001bac:	bf18      	it	ne
18001bae:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
18001bb0:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
18001bb4:	f3c2 0140 	ubfx	r1, r2, #1, #1
18001bb8:	430b      	orrs	r3, r1
18001bba:	f363 0241 	bfi	r2, r3, #1, #1
18001bbe:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
18001bc2:	e6d8      	b.n	18001976 <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
18001bc4:	2002      	movs	r0, #2
18001bc6:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
18001bca:	e7de      	b.n	18001b8a <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
18001bcc:	2103      	movs	r1, #3
18001bce:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
18001bd2:	f003 0378 	and.w	r3, r3, #120	; 0x78
18001bd6:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
18001bda:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
18001bde:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
18001be0:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
18001be4:	4143      	adcs	r3, r0
18001be6:	e7e3      	b.n	18001bb0 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
18001be8:	2103      	movs	r1, #3
18001bea:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
18001bee:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
18001bf2:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
18001bf6:	bf14      	ite	ne
18001bf8:	2301      	movne	r3, #1
18001bfa:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
18001bfc:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
18001c00:	e7d6      	b.n	18001bb0 <cbvprintf+0x378>
		conv->invalid = true;
18001c02:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
18001c06:	f043 0301 	orr.w	r3, r3, #1
18001c0a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
18001c0e:	2300      	movs	r3, #0
18001c10:	e7ce      	b.n	18001bb0 <cbvprintf+0x378>
		} else if (conv->width_present) {
18001c12:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
18001c16:	2a00      	cmp	r2, #0
		int width = -1;
18001c18:	bfac      	ite	ge
18001c1a:	f04f 39ff 	movge.w	r9, #4294967295
			width = conv->width_value;
18001c1e:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
18001c22:	e6ba      	b.n	1800199a <cbvprintf+0x162>
		} else if (conv->prec_present) {
18001c24:	079b      	lsls	r3, r3, #30
18001c26:	f57f aec7 	bpl.w	180019b8 <cbvprintf+0x180>
			precision = conv->prec_value;
18001c2a:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
18001c2e:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
18001c30:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
18001c34:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
18001c38:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
18001c3c:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
18001c40:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
18001c42:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
18001c46:	d138      	bne.n	18001cba <cbvprintf+0x482>
			switch (length_mod) {
18001c48:	1ecb      	subs	r3, r1, #3
18001c4a:	2b04      	cmp	r3, #4
18001c4c:	d822      	bhi.n	18001c94 <cbvprintf+0x45c>
18001c4e:	e8df f003 	tbb	[pc, r3]
18001c52:	0903      	.short	0x0903
18001c54:	2109      	.short	0x2109
18001c56:	21          	.byte	0x21
18001c57:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
18001c58:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
18001c5c:	17da      	asrs	r2, r3, #31
18001c5e:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
18001c62:	e006      	b.n	18001c72 <cbvprintf+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
18001c64:	3407      	adds	r4, #7
18001c66:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
18001c6a:	e8f4 2302 	ldrd	r2, r3, [r4], #8
18001c6e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
18001c72:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
18001c76:	f013 0603 	ands.w	r6, r3, #3
18001c7a:	d056      	beq.n	18001d2a <cbvprintf+0x4f2>
			OUTS(sp, fp);
18001c7c:	463b      	mov	r3, r7
18001c7e:	4652      	mov	r2, sl
18001c80:	4659      	mov	r1, fp
18001c82:	9802      	ldr	r0, [sp, #8]
18001c84:	f006 fb3e 	bl	18008304 <outs>
18001c88:	2800      	cmp	r0, #0
18001c8a:	f2c0 8142 	blt.w	18001f12 <cbvprintf+0x6da>
18001c8e:	4405      	add	r5, r0
			continue;
18001c90:	46ba      	mov	sl, r7
18001c92:	e5d9      	b.n	18001848 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
18001c94:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
18001c98:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
18001c9a:	ea4f 72e3 	mov.w	r2, r3, asr #31
18001c9e:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
18001ca2:	d105      	bne.n	18001cb0 <cbvprintf+0x478>
				value->uint = (unsigned char)value->uint;
18001ca4:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
18001ca8:	930a      	str	r3, [sp, #40]	; 0x28
18001caa:	2300      	movs	r3, #0
18001cac:	930b      	str	r3, [sp, #44]	; 0x2c
18001cae:	e7e0      	b.n	18001c72 <cbvprintf+0x43a>
			} else if (length_mod == LENGTH_H) {
18001cb0:	2902      	cmp	r1, #2
18001cb2:	d1de      	bne.n	18001c72 <cbvprintf+0x43a>
				value->sint = (short)value->sint;
18001cb4:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
18001cb8:	e7d0      	b.n	18001c5c <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
18001cba:	2b02      	cmp	r3, #2
18001cbc:	d123      	bne.n	18001d06 <cbvprintf+0x4ce>
			switch (length_mod) {
18001cbe:	1ecb      	subs	r3, r1, #3
18001cc0:	2b04      	cmp	r3, #4
18001cc2:	d813      	bhi.n	18001cec <cbvprintf+0x4b4>
18001cc4:	e8df f003 	tbb	[pc, r3]
18001cc8:	120a0a03 	.word	0x120a0a03
18001ccc:	12          	.byte	0x12
18001ccd:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
18001cce:	2300      	movs	r3, #0
					value->uint = (wchar_t)va_arg(ap,
18001cd0:	6822      	ldr	r2, [r4, #0]
				value->sint = va_arg(ap, int);
18001cd2:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
18001cd4:	920a      	str	r2, [sp, #40]	; 0x28
18001cd6:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
18001cd8:	4604      	mov	r4, r0
18001cda:	e7ca      	b.n	18001c72 <cbvprintf+0x43a>
					(uint_value_type)va_arg(ap,
18001cdc:	1de0      	adds	r0, r4, #7
18001cde:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
18001ce2:	e8f0 2302 	ldrd	r2, r3, [r0], #8
18001ce6:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
18001cea:	e7f5      	b.n	18001cd8 <cbvprintf+0x4a0>
					(uint_value_type)va_arg(ap, size_t);
18001cec:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
18001cf0:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
18001cf2:	930a      	str	r3, [sp, #40]	; 0x28
18001cf4:	f04f 0300 	mov.w	r3, #0
18001cf8:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
18001cfa:	d0d3      	beq.n	18001ca4 <cbvprintf+0x46c>
			} else if (length_mod == LENGTH_H) {
18001cfc:	2902      	cmp	r1, #2
18001cfe:	d1b8      	bne.n	18001c72 <cbvprintf+0x43a>
				value->uint = (unsigned short)value->uint;
18001d00:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
18001d04:	e7d0      	b.n	18001ca8 <cbvprintf+0x470>
		} else if (specifier_cat == SPECIFIER_FP) {
18001d06:	2b04      	cmp	r3, #4
18001d08:	d109      	bne.n	18001d1e <cbvprintf+0x4e6>
					(sint_value_type)va_arg(ap, long long);
18001d0a:	1de3      	adds	r3, r4, #7
18001d0c:	f023 0307 	bic.w	r3, r3, #7
18001d10:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
18001d14:	e9d3 2300 	ldrd	r2, r3, [r3]
18001d18:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
18001d1c:	e7a9      	b.n	18001c72 <cbvprintf+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
18001d1e:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
18001d20:	bf04      	itt	eq
18001d22:	f854 3b04 	ldreq.w	r3, [r4], #4
18001d26:	930a      	streq	r3, [sp, #40]	; 0x28
18001d28:	e7a3      	b.n	18001c72 <cbvprintf+0x43a>
		switch (conv->specifier) {
18001d2a:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
18001d2e:	2878      	cmp	r0, #120	; 0x78
18001d30:	d8ae      	bhi.n	18001c90 <cbvprintf+0x458>
18001d32:	2862      	cmp	r0, #98	; 0x62
18001d34:	d822      	bhi.n	18001d7c <cbvprintf+0x544>
18001d36:	2825      	cmp	r0, #37	; 0x25
18001d38:	f43f ad8f 	beq.w	1800185a <cbvprintf+0x22>
18001d3c:	2858      	cmp	r0, #88	; 0x58
18001d3e:	d1a7      	bne.n	18001c90 <cbvprintf+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
18001d40:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
18001d44:	f10d 0326 	add.w	r3, sp, #38	; 0x26
18001d48:	9300      	str	r3, [sp, #0]
18001d4a:	aa0c      	add	r2, sp, #48	; 0x30
18001d4c:	ab04      	add	r3, sp, #16
18001d4e:	f006 fa93 	bl	18008278 <encode_uint>
18001d52:	4682      	mov	sl, r0
			if (precision >= 0) {
18001d54:	f1b8 0f00 	cmp.w	r8, #0
18001d58:	f10d 0026 	add.w	r0, sp, #38	; 0x26
18001d5c:	db0c      	blt.n	18001d78 <cbvprintf+0x540>
				conv->flag_zero = false;
18001d5e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
18001d62:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
18001d66:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
18001d6a:	4598      	cmp	r8, r3
				conv->flag_zero = false;
18001d6c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
18001d70:	d902      	bls.n	18001d78 <cbvprintf+0x540>
					conv->pad0_value = precision - (int)len;
18001d72:	eba8 0303 	sub.w	r3, r8, r3
18001d76:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
18001d78:	4680      	mov	r8, r0
18001d7a:	e03d      	b.n	18001df8 <cbvprintf+0x5c0>
		switch (conv->specifier) {
18001d7c:	3863      	subs	r0, #99	; 0x63
18001d7e:	2815      	cmp	r0, #21
18001d80:	d886      	bhi.n	18001c90 <cbvprintf+0x458>
18001d82:	a201      	add	r2, pc, #4	; (adr r2, 18001d88 <cbvprintf+0x550>)
18001d84:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
18001d88:	18001e09 	.word	0x18001e09
18001d8c:	18001e6d 	.word	0x18001e6d
18001d90:	18001c91 	.word	0x18001c91
18001d94:	18001c91 	.word	0x18001c91
18001d98:	18001c91 	.word	0x18001c91
18001d9c:	18001c91 	.word	0x18001c91
18001da0:	18001e6d 	.word	0x18001e6d
18001da4:	18001c91 	.word	0x18001c91
18001da8:	18001c91 	.word	0x18001c91
18001dac:	18001c91 	.word	0x18001c91
18001db0:	18001c91 	.word	0x18001c91
18001db4:	18001ec7 	.word	0x18001ec7
18001db8:	18001e95 	.word	0x18001e95
18001dbc:	18001e99 	.word	0x18001e99
18001dc0:	18001c91 	.word	0x18001c91
18001dc4:	18001c91 	.word	0x18001c91
18001dc8:	18001de1 	.word	0x18001de1
18001dcc:	18001c91 	.word	0x18001c91
18001dd0:	18001e95 	.word	0x18001e95
18001dd4:	18001c91 	.word	0x18001c91
18001dd8:	18001c91 	.word	0x18001c91
18001ddc:	18001e95 	.word	0x18001e95
			if (precision >= 0) {
18001de0:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
18001de4:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
18001de8:	db0a      	blt.n	18001e00 <cbvprintf+0x5c8>
				len = strnlen(bps, precision);
18001dea:	4641      	mov	r1, r8
18001dec:	4650      	mov	r0, sl
18001dee:	f008 f961 	bl	1800a0b4 <strnlen>
		char sign = 0;
18001df2:	2600      	movs	r6, #0
			bpe = bps + len;
18001df4:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
18001df8:	f1ba 0f00 	cmp.w	sl, #0
18001dfc:	d10c      	bne.n	18001e18 <cbvprintf+0x5e0>
18001dfe:	e747      	b.n	18001c90 <cbvprintf+0x458>
				len = strlen(bps);
18001e00:	4650      	mov	r0, sl
18001e02:	f008 f950 	bl	1800a0a6 <strlen>
18001e06:	e7f4      	b.n	18001df2 <cbvprintf+0x5ba>
			break;
18001e08:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
18001e0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bps = buf;
18001e0c:	f10d 0a10 	add.w	sl, sp, #16
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
18001e10:	f88d 3010 	strb.w	r3, [sp, #16]
			bpe = buf + 1;
18001e14:	f10d 0811 	add.w	r8, sp, #17
		size_t nj_len = (bpe - bps);
18001e18:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
18001e1c:	b106      	cbz	r6, 18001e20 <cbvprintf+0x5e8>
			nj_len += 1U;
18001e1e:	3301      	adds	r3, #1
		if (conv->altform_0c) {
18001e20:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
18001e24:	06d0      	lsls	r0, r2, #27
18001e26:	d568      	bpl.n	18001efa <cbvprintf+0x6c2>
			nj_len += 2U;
18001e28:	3302      	adds	r3, #2
		if (conv->pad_fp) {
18001e2a:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
18001e2c:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
18001e2e:	bf48      	it	mi
18001e30:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
18001e32:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
18001e34:	bf48      	it	mi
18001e36:	189b      	addmi	r3, r3, r2
		if (width > 0) {
18001e38:	f1b9 0f00 	cmp.w	r9, #0
18001e3c:	dd76      	ble.n	18001f2c <cbvprintf+0x6f4>
			if (!conv->flag_dash) {
18001e3e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
18001e42:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
18001e46:	f3c2 0380 	ubfx	r3, r2, #2, #1
18001e4a:	9303      	str	r3, [sp, #12]
18001e4c:	0753      	lsls	r3, r2, #29
18001e4e:	d46d      	bmi.n	18001f2c <cbvprintf+0x6f4>
				if (conv->flag_zero) {
18001e50:	0650      	lsls	r0, r2, #25
18001e52:	d561      	bpl.n	18001f18 <cbvprintf+0x6e0>
					if (sign != 0) {
18001e54:	b146      	cbz	r6, 18001e68 <cbvprintf+0x630>
						OUTC(sign);
18001e56:	4659      	mov	r1, fp
18001e58:	4630      	mov	r0, r6
18001e5a:	9b02      	ldr	r3, [sp, #8]
18001e5c:	4798      	blx	r3
18001e5e:	2800      	cmp	r0, #0
18001e60:	db57      	blt.n	18001f12 <cbvprintf+0x6da>
						sign = 0;
18001e62:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
18001e64:	3501      	adds	r5, #1
						sign = 0;
18001e66:	461e      	mov	r6, r3
					pad = '0';
18001e68:	2330      	movs	r3, #48	; 0x30
18001e6a:	e056      	b.n	18001f1a <cbvprintf+0x6e2>
			if (conv->flag_plus) {
18001e6c:	071e      	lsls	r6, r3, #28
18001e6e:	d40f      	bmi.n	18001e90 <cbvprintf+0x658>
				sign = ' ';
18001e70:	f013 0610 	ands.w	r6, r3, #16
18001e74:	bf18      	it	ne
18001e76:	2620      	movne	r6, #32
			sint = value->sint;
18001e78:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
18001e7c:	2b00      	cmp	r3, #0
18001e7e:	f6bf af5f 	bge.w	18001d40 <cbvprintf+0x508>
				value->uint = (uint_value_type)-sint;
18001e82:	4252      	negs	r2, r2
18001e84:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
18001e88:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
18001e8a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
18001e8e:	e757      	b.n	18001d40 <cbvprintf+0x508>
				sign = '+';
18001e90:	262b      	movs	r6, #43	; 0x2b
18001e92:	e7f1      	b.n	18001e78 <cbvprintf+0x640>
		switch (conv->specifier) {
18001e94:	2600      	movs	r6, #0
18001e96:	e753      	b.n	18001d40 <cbvprintf+0x508>
			if (value->ptr != NULL) {
18001e98:	980a      	ldr	r0, [sp, #40]	; 0x28
18001e9a:	b340      	cbz	r0, 18001eee <cbvprintf+0x6b6>
				bps = encode_uint((uintptr_t)value->ptr, conv,
18001e9c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
18001ea0:	9300      	str	r3, [sp, #0]
18001ea2:	2100      	movs	r1, #0
18001ea4:	ab04      	add	r3, sp, #16
18001ea6:	aa0c      	add	r2, sp, #48	; 0x30
18001ea8:	f006 f9e6 	bl	18008278 <encode_uint>
				conv->altform_0c = true;
18001eac:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
18001eb0:	4682      	mov	sl, r0
				conv->altform_0c = true;
18001eb2:	f003 03ef 	and.w	r3, r3, #239	; 0xef
18001eb6:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
18001eba:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
18001ebe:	2600      	movs	r6, #0
				conv->altform_0c = true;
18001ec0:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
18001ec4:	e746      	b.n	18001d54 <cbvprintf+0x51c>
				store_count(conv, value->ptr, count);
18001ec6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
18001ec8:	2907      	cmp	r1, #7
18001eca:	f63f aee1 	bhi.w	18001c90 <cbvprintf+0x458>
18001ece:	e8df f001 	tbb	[pc, r1]
18001ed2:	040c      	.short	0x040c
18001ed4:	08080c06 	.word	0x08080c06
18001ed8:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
18001eda:	701d      	strb	r5, [r3, #0]
		break;
18001edc:	e6d8      	b.n	18001c90 <cbvprintf+0x458>
		*(short *)dp = (short)count;
18001ede:	801d      	strh	r5, [r3, #0]
		break;
18001ee0:	e6d6      	b.n	18001c90 <cbvprintf+0x458>
		*(intmax_t *)dp = (intmax_t)count;
18001ee2:	17ea      	asrs	r2, r5, #31
18001ee4:	e9c3 5200 	strd	r5, r2, [r3]
		break;
18001ee8:	e6d2      	b.n	18001c90 <cbvprintf+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
18001eea:	601d      	str	r5, [r3, #0]
		break;
18001eec:	e6d0      	b.n	18001c90 <cbvprintf+0x458>
			bps = "(nil)";
18001eee:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 18001fb8 <cbvprintf+0x780>
18001ef2:	4606      	mov	r6, r0
			bpe = bps + 5;
18001ef4:	f10a 0805 	add.w	r8, sl, #5
18001ef8:	e78e      	b.n	18001e18 <cbvprintf+0x5e0>
		} else if (conv->altform_0) {
18001efa:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
18001efc:	bf48      	it	mi
18001efe:	3301      	addmi	r3, #1
18001f00:	e793      	b.n	18001e2a <cbvprintf+0x5f2>
					OUTC(pad);
18001f02:	4618      	mov	r0, r3
18001f04:	9303      	str	r3, [sp, #12]
18001f06:	4659      	mov	r1, fp
18001f08:	9b02      	ldr	r3, [sp, #8]
18001f0a:	4798      	blx	r3
18001f0c:	2800      	cmp	r0, #0
18001f0e:	9b03      	ldr	r3, [sp, #12]
18001f10:	da04      	bge.n	18001f1c <cbvprintf+0x6e4>
#undef OUTS
#undef OUTC
}
18001f12:	b011      	add	sp, #68	; 0x44
18001f14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
18001f18:	2320      	movs	r3, #32
18001f1a:	444d      	add	r5, r9
18001f1c:	464a      	mov	r2, r9
				while (width-- > 0) {
18001f1e:	2a00      	cmp	r2, #0
18001f20:	eba5 0109 	sub.w	r1, r5, r9
18001f24:	f109 39ff 	add.w	r9, r9, #4294967295
18001f28:	dceb      	bgt.n	18001f02 <cbvprintf+0x6ca>
18001f2a:	460d      	mov	r5, r1
		if (sign != 0) {
18001f2c:	b136      	cbz	r6, 18001f3c <cbvprintf+0x704>
			OUTC(sign);
18001f2e:	4659      	mov	r1, fp
18001f30:	4630      	mov	r0, r6
18001f32:	9b02      	ldr	r3, [sp, #8]
18001f34:	4798      	blx	r3
18001f36:	2800      	cmp	r0, #0
18001f38:	dbeb      	blt.n	18001f12 <cbvprintf+0x6da>
18001f3a:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
18001f3c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
18001f40:	06d9      	lsls	r1, r3, #27
18001f42:	d401      	bmi.n	18001f48 <cbvprintf+0x710>
18001f44:	071a      	lsls	r2, r3, #28
18001f46:	d506      	bpl.n	18001f56 <cbvprintf+0x71e>
				OUTC('0');
18001f48:	4659      	mov	r1, fp
18001f4a:	2030      	movs	r0, #48	; 0x30
18001f4c:	9b02      	ldr	r3, [sp, #8]
18001f4e:	4798      	blx	r3
18001f50:	2800      	cmp	r0, #0
18001f52:	dbde      	blt.n	18001f12 <cbvprintf+0x6da>
18001f54:	3501      	adds	r5, #1
			if (conv->altform_0c) {
18001f56:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
18001f5a:	06db      	lsls	r3, r3, #27
18001f5c:	d507      	bpl.n	18001f6e <cbvprintf+0x736>
				OUTC(conv->specifier);
18001f5e:	4659      	mov	r1, fp
18001f60:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
18001f64:	9b02      	ldr	r3, [sp, #8]
18001f66:	4798      	blx	r3
18001f68:	2800      	cmp	r0, #0
18001f6a:	dbd2      	blt.n	18001f12 <cbvprintf+0x6da>
18001f6c:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
18001f6e:	9e0d      	ldr	r6, [sp, #52]	; 0x34
18001f70:	442e      	add	r6, r5
18001f72:	1b73      	subs	r3, r6, r5
18001f74:	2b00      	cmp	r3, #0
18001f76:	dc16      	bgt.n	18001fa6 <cbvprintf+0x76e>
			OUTS(bps, bpe);
18001f78:	4643      	mov	r3, r8
18001f7a:	4652      	mov	r2, sl
18001f7c:	4659      	mov	r1, fp
18001f7e:	9802      	ldr	r0, [sp, #8]
18001f80:	f006 f9c0 	bl	18008304 <outs>
18001f84:	2800      	cmp	r0, #0
18001f86:	dbc4      	blt.n	18001f12 <cbvprintf+0x6da>
18001f88:	4405      	add	r5, r0
		while (width > 0) {
18001f8a:	44a9      	add	r9, r5
18001f8c:	eba9 0305 	sub.w	r3, r9, r5
18001f90:	2b00      	cmp	r3, #0
18001f92:	f77f ae7d 	ble.w	18001c90 <cbvprintf+0x458>
			OUTC(' ');
18001f96:	4659      	mov	r1, fp
18001f98:	2020      	movs	r0, #32
18001f9a:	9b02      	ldr	r3, [sp, #8]
18001f9c:	4798      	blx	r3
18001f9e:	2800      	cmp	r0, #0
18001fa0:	dbb7      	blt.n	18001f12 <cbvprintf+0x6da>
18001fa2:	3501      	adds	r5, #1
			--width;
18001fa4:	e7f2      	b.n	18001f8c <cbvprintf+0x754>
				OUTC('0');
18001fa6:	4659      	mov	r1, fp
18001fa8:	2030      	movs	r0, #48	; 0x30
18001faa:	9b02      	ldr	r3, [sp, #8]
18001fac:	4798      	blx	r3
18001fae:	2800      	cmp	r0, #0
18001fb0:	dbaf      	blt.n	18001f12 <cbvprintf+0x6da>
18001fb2:	3501      	adds	r5, #1
18001fb4:	e7dd      	b.n	18001f72 <cbvprintf+0x73a>
18001fb6:	bf00      	nop
18001fb8:	1800c6fb 	.word	0x1800c6fb

18001fbc <sys_reboot>:
#include <sys/printk.h>

extern void sys_arch_reboot(int type);

FUNC_NORETURN void sys_reboot(int type)
{
18001fbc:	b508      	push	{r3, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
18001fbe:	f04f 0220 	mov.w	r2, #32
18001fc2:	f3ef 8311 	mrs	r3, BASEPRI
18001fc6:	f382 8812 	msr	BASEPRI_MAX, r2
18001fca:	f3bf 8f6f 	isb	sy
	(void)irq_lock();
	sys_clock_disable();

	sys_arch_reboot(type);
18001fce:	f003 fb17 	bl	18005600 <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
18001fd2:	4803      	ldr	r0, [pc, #12]	; (18001fe0 <sys_reboot+0x24>)
18001fd4:	f006 f850 	bl	18008078 <printk>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
18001fd8:	f002 fdc4 	bl	18004b64 <arch_cpu_idle>
18001fdc:	e7fc      	b.n	18001fd8 <sys_reboot+0x1c>
18001fde:	bf00      	nop
18001fe0:	1800c701 	.word	0x1800c701

18001fe4 <nxp_rt600_init>:
 *
 * @return 0
 */

static int nxp_rt600_init(const struct device *arg)
{
18001fe4:	b538      	push	{r3, r4, r5, lr}
18001fe6:	f04f 0320 	mov.w	r3, #32
18001fea:	f3ef 8511 	mrs	r5, BASEPRI
18001fee:	f383 8812 	msr	BASEPRI_MAX, r3
18001ff2:	f3bf 8f6f 	isb	sy

	/* disable interrupts */
	oldLevel = irq_lock();

	/* Enable cache to accelerate boot. */
	if (SYSTEM_IS_XIP_FLEXSPI() && (CACHE64_POLSEL->POLSEL == 0)) {
18001ff6:	4b44      	ldr	r3, [pc, #272]	; (18002108 <nxp_rt600_init+0x124>)
18001ff8:	f003 4368 	and.w	r3, r3, #3892314112	; 0xe8000000
18001ffc:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
18002000:	d11d      	bne.n	1800203e <nxp_rt600_init+0x5a>
18002002:	4b42      	ldr	r3, [pc, #264]	; (1800210c <nxp_rt600_init+0x128>)
18002004:	69da      	ldr	r2, [r3, #28]
18002006:	b9d2      	cbnz	r2, 1800203e <nxp_rt600_init+0x5a>
		/*
		 * Set command to invalidate all ways and write GO bit
		 * to initiate command
		 */
		CACHE64->CCR = (CACHE64_CTRL_CCR_INVW1_MASK |
18002008:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
1800200c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
					CACHE64_CTRL_CCR_INVW0_MASK);
		CACHE64->CCR |= CACHE64_CTRL_CCR_GO_MASK;
18002010:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
18002014:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
18002018:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		/* Wait until the command completes */
		while (CACHE64->CCR & CACHE64_CTRL_CCR_GO_MASK) {
1800201c:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
18002020:	2a00      	cmp	r2, #0
18002022:	dbfb      	blt.n	1800201c <nxp_rt600_init+0x38>
		}
		/* Enable cache, enable write buffer */
		CACHE64->CCR = (CACHE64_CTRL_CCR_ENWRBUF_MASK |
18002024:	2203      	movs	r2, #3
18002026:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
						CACHE64_CTRL_CCR_ENCACHE_MASK);

		/* Set whole FlexSPI0 space to write through. */
		CACHE64_POLSEL->REG0_TOP = 0x07FFFC00U;
1800202a:	4a39      	ldr	r2, [pc, #228]	; (18002110 <nxp_rt600_init+0x12c>)
1800202c:	615a      	str	r2, [r3, #20]
		CACHE64_POLSEL->REG1_TOP = 0x0U;
1800202e:	2200      	movs	r2, #0
18002030:	619a      	str	r2, [r3, #24]
		CACHE64_POLSEL->POLSEL = 0x1U;
18002032:	2201      	movs	r2, #1
18002034:	61da      	str	r2, [r3, #28]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
18002036:	f3bf 8f6f 	isb	sy
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
1800203a:	f3bf 8f4f 	dsb	sy
 * @param en    peripheral for which to disable the PDRUNCFG bit
 */
static inline void POWER_DisablePD(pd_bit_t en)
{
    /* PDRUNCFGCLR */
    SYSCTL0_PDRCFGCLR_REG(((uint32_t)en) >> 8UL) = (1UL << (((uint32_t)en) & 0xFFU));
1800203e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
18002042:	4c34      	ldr	r4, [pc, #208]	; (18002114 <nxp_rt600_init+0x130>)
	CLOCK_EnableFfroClk(kCLOCK_Ffro48M);
18002044:	2000      	movs	r0, #0
18002046:	f8c4 3630 	str.w	r3, [r4, #1584]	; 0x630
1800204a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
1800204e:	f8c4 3630 	str.w	r3, [r4, #1584]	; 0x630
18002052:	f004 f85f 	bl	18006114 <CLOCK_EnableFfroClk>
18002056:	f44f 4300 	mov.w	r3, #32768	; 0x8000
1800205a:	f8c4 3630 	str.w	r3, [r4, #1584]	; 0x630
	CLOCK_EnableSfroClk();
1800205e:	f004 f8b9 	bl	180061d4 <CLOCK_EnableSfroClk>
	CLOCK_AttachClk(kFFRO_to_MAIN_CLK);
18002062:	482d      	ldr	r0, [pc, #180]	; (18002118 <nxp_rt600_init+0x134>)
18002064:	f008 fb2d 	bl	1800a6c2 <CLOCK_AttachClk>
18002068:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	POWER_UpdateOscSettlingTime(CONFIG_SYSOSC_SETTLING_US);
1800206c:	f44f 7082 	mov.w	r0, #260	; 0x104
18002070:	f8c4 3630 	str.w	r3, [r4, #1584]	; 0x630
18002074:	f004 f98c 	bl	18006390 <POWER_UpdateOscSettlingTime>
	CLOCK_EnableSysOscClk(true, true, CONFIG_SYSOSC_SETTLING_US);
18002078:	2101      	movs	r1, #1
1800207a:	f44f 7282 	mov.w	r2, #260	; 0x104
1800207e:	4608      	mov	r0, r1
18002080:	f004 f972 	bl	18006368 <CLOCK_EnableSysOscClk>
 *
 * @param freq : The XTAL input clock frequency in Hz.
 */
static inline void CLOCK_SetXtalFreq(uint32_t freq)
{
    g_xtalFreq = freq;
18002084:	4b25      	ldr	r3, [pc, #148]	; (1800211c <nxp_rt600_init+0x138>)
18002086:	4a26      	ldr	r2, [pc, #152]	; (18002120 <nxp_rt600_init+0x13c>)
	CLOCK_InitSysPll(&g_sysPllConfig);
18002088:	4826      	ldr	r0, [pc, #152]	; (18002124 <nxp_rt600_init+0x140>)
1800208a:	601a      	str	r2, [r3, #0]
1800208c:	f004 f8c6 	bl	1800621c <CLOCK_InitSysPll>
	CLOCK_InitSysPfd(kCLOCK_Pfd0, 19);
18002090:	2113      	movs	r1, #19
18002092:	2000      	movs	r0, #0
18002094:	f004 f946 	bl	18006324 <CLOCK_InitSysPfd>
	CLOCK_InitSysPfd(kCLOCK_Pfd2, 24);
18002098:	2118      	movs	r1, #24
1800209a:	2002      	movs	r0, #2
1800209c:	f004 f942 	bl	18006324 <CLOCK_InitSysPfd>
	CLOCK_SetClkDiv(kCLOCK_DivSysCpuAhbClk, 2U);
180020a0:	2102      	movs	r1, #2
180020a2:	f44f 6080 	mov.w	r0, #1024	; 0x400
180020a6:	f008 fb2a 	bl	1800a6fe <CLOCK_SetClkDiv>
	CLOCK_AttachClk(kMAIN_PLL_to_MAIN_CLK);
180020aa:	f242 4034 	movw	r0, #9268	; 0x2434
180020ae:	f008 fb08 	bl	1800a6c2 <CLOCK_AttachClk>
	CLOCK_SetClkDiv(kCLOCK_DivPfc0Clk, 2U);
180020b2:	2102      	movs	r1, #2
180020b4:	f44f 60a0 	mov.w	r0, #1280	; 0x500
180020b8:	f008 fb21 	bl	1800a6fe <CLOCK_SetClkDiv>
	CLOCK_SetClkDiv(kCLOCK_DivPllFrgClk, 12U);
180020bc:	210c      	movs	r1, #12
180020be:	481a      	ldr	r0, [pc, #104]	; (18002128 <nxp_rt600_init+0x144>)
180020c0:	f008 fb1d 	bl	1800a6fe <CLOCK_SetClkDiv>
	CLOCK_AttachClk(kSFRO_to_FLEXCOMM0);
180020c4:	4819      	ldr	r0, [pc, #100]	; (1800212c <nxp_rt600_init+0x148>)
180020c6:	f008 fafc 	bl	1800a6c2 <CLOCK_AttachClk>
	CLOCK_AttachClk(kAUDIO_PLL_to_FLEXCOMM1);
180020ca:	4819      	ldr	r0, [pc, #100]	; (18002130 <nxp_rt600_init+0x14c>)
180020cc:	f008 faf9 	bl	1800a6c2 <CLOCK_AttachClk>
	CLOCK_AttachClk(kAUDIO_PLL_to_FLEXCOMM3);
180020d0:	4818      	ldr	r0, [pc, #96]	; (18002134 <nxp_rt600_init+0x150>)
180020d2:	f008 faf6 	bl	1800a6c2 <CLOCK_AttachClk>
	CLOCK_AttachClk(kLPOSC_to_WDT0_CLK);
180020d6:	f44f 60e4 	mov.w	r0, #1824	; 0x720
180020da:	f008 faf2 	bl	1800a6c2 <CLOCK_AttachClk>
	DT_FOREACH_STATUS_OKAY(nxp_lpc_ctimer, CTIMER_CLOCK_SETUP)
180020de:	4816      	ldr	r0, [pc, #88]	; (18002138 <nxp_rt600_init+0x154>)
180020e0:	f008 faef 	bl	1800a6c2 <CLOCK_AttachClk>
180020e4:	4815      	ldr	r0, [pc, #84]	; (1800213c <nxp_rt600_init+0x158>)
180020e6:	f008 faec 	bl	1800a6c2 <CLOCK_AttachClk>
180020ea:	4815      	ldr	r0, [pc, #84]	; (18002140 <nxp_rt600_init+0x15c>)
180020ec:	f008 fae9 	bl	1800a6c2 <CLOCK_AttachClk>
180020f0:	4814      	ldr	r0, [pc, #80]	; (18002144 <nxp_rt600_init+0x160>)
180020f2:	f008 fae6 	bl	1800a6c2 <CLOCK_AttachClk>
180020f6:	4814      	ldr	r0, [pc, #80]	; (18002148 <nxp_rt600_init+0x164>)
180020f8:	f008 fae3 	bl	1800a6c2 <CLOCK_AttachClk>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
180020fc:	f385 8811 	msr	BASEPRI, r5
18002100:	f3bf 8f6f 	isb	sy

	/* restore interrupt state */
	irq_unlock(oldLevel);

	return 0;
}
18002104:	2000      	movs	r0, #0
18002106:	bd38      	pop	{r3, r4, r5, pc}
18002108:	18001fe5 	.word	0x18001fe5
1800210c:	50033000 	.word	0x50033000
18002110:	07fffc00 	.word	0x07fffc00
18002114:	50002000 	.word	0x50002000
18002118:	04343430 	.word	0x04343430
1800211c:	301809f0 	.word	0x301809f0
18002120:	016e3600 	.word	0x016e3600
18002124:	1800b4f8 	.word	0x1800b4f8
18002128:	800006fc 	.word	0x800006fc
1800212c:	80000508 	.word	0x80000508
18002130:	80002528 	.word	0x80002528
18002134:	80002568 	.word	0x80002568
18002138:	80001720 	.word	0x80001720
1800213c:	80001724 	.word	0x80001724
18002140:	80001728 	.word	0x80001728
18002144:	8000172c 	.word	0x8000172c
18002148:	80001730 	.word	0x80001730

1800214c <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
1800214c:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
1800214e:	2200      	movs	r2, #0
{
18002150:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
18002152:	490f      	ldr	r1, [pc, #60]	; (18002190 <enable_logger+0x44>)
18002154:	480f      	ldr	r0, [pc, #60]	; (18002194 <enable_logger+0x48>)
18002156:	f008 fdff 	bl	1800ad58 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
1800215a:	2200      	movs	r2, #0
1800215c:	2300      	movs	r3, #0
1800215e:	2400      	movs	r4, #0
18002160:	e9cd 2306 	strd	r2, r3, [sp, #24]
18002164:	230e      	movs	r3, #14
18002166:	4d0c      	ldr	r5, [pc, #48]	; (18002198 <enable_logger+0x4c>)
18002168:	e9cd 3403 	strd	r3, r4, [sp, #12]
1800216c:	f44f 7240 	mov.w	r2, #768	; 0x300
18002170:	4628      	mov	r0, r5
18002172:	e9cd 4401 	strd	r4, r4, [sp, #4]
18002176:	4b09      	ldr	r3, [pc, #36]	; (1800219c <enable_logger+0x50>)
18002178:	4909      	ldr	r1, [pc, #36]	; (180021a0 <enable_logger+0x54>)
1800217a:	9400      	str	r4, [sp, #0]
1800217c:	f004 fdee 	bl	18006d5c <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
18002180:	4908      	ldr	r1, [pc, #32]	; (180021a4 <enable_logger+0x58>)
18002182:	4628      	mov	r0, r5
18002184:	f004 fd40 	bl	18006c08 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
18002188:	4620      	mov	r0, r4
1800218a:	b009      	add	sp, #36	; 0x24
1800218c:	bd30      	pop	{r4, r5, pc}
1800218e:	bf00      	nop
18002190:	180021a9 	.word	0x180021a9
18002194:	301800f0 	.word	0x301800f0
18002198:	30180128 	.word	0x30180128
1800219c:	180024fd 	.word	0x180024fd
180021a0:	30180a88 	.word	0x30180a88
180021a4:	1800cb0c 	.word	0x1800cb0c

180021a8 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
180021a8:	4801      	ldr	r0, [pc, #4]	; (180021b0 <log_process_thread_timer_expiry_fn+0x8>)
180021aa:	f004 bfc1 	b.w	18007130 <z_impl_k_sem_give>
180021ae:	bf00      	nop
180021b0:	301800d8 	.word	0x301800d8

180021b4 <log_core_init>:
{
180021b4:	b508      	push	{r3, lr}
	panic_mode = false;
180021b6:	2300      	movs	r3, #0
180021b8:	4a0c      	ldr	r2, [pc, #48]	; (180021ec <log_core_init+0x38>)
	log_output_timestamp_freq_set(freq);
180021ba:	480d      	ldr	r0, [pc, #52]	; (180021f0 <log_core_init+0x3c>)
	panic_mode = false;
180021bc:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
180021be:	4a0d      	ldr	r2, [pc, #52]	; (180021f4 <log_core_init+0x40>)
180021c0:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
180021c2:	4b0d      	ldr	r3, [pc, #52]	; (180021f8 <log_core_init+0x44>)
180021c4:	4a0d      	ldr	r2, [pc, #52]	; (180021fc <log_core_init+0x48>)
180021c6:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
180021c8:	f000 fd76 	bl	18002cb8 <log_output_timestamp_freq_set>
		log_msg_pool_init();
180021cc:	f000 fb1a 	bl	18002804 <log_msg_pool_init>
		log_list_init(&list);
180021d0:	480b      	ldr	r0, [pc, #44]	; (18002200 <log_core_init+0x4c>)
180021d2:	f006 faa9 	bl	18008728 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
180021d6:	2304      	movs	r3, #4
180021d8:	2228      	movs	r2, #40	; 0x28
180021da:	490a      	ldr	r1, [pc, #40]	; (18002204 <log_core_init+0x50>)
180021dc:	480a      	ldr	r0, [pc, #40]	; (18002208 <log_core_init+0x54>)
180021de:	f008 fbf1 	bl	1800a9c4 <k_mem_slab_init>
}
180021e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		z_log_runtime_filters_init();
180021e6:	f000 ba45 	b.w	18002674 <z_log_runtime_filters_init>
180021ea:	bf00      	nop
180021ec:	30180a61 	.word	0x30180a61
180021f0:	000f4240 	.word	0x000f4240
180021f4:	3018052c 	.word	0x3018052c
180021f8:	30180004 	.word	0x30180004
180021fc:	18008767 	.word	0x18008767
18002200:	30180534 	.word	0x30180534
18002204:	30182e98 	.word	0x30182e98
18002208:	3018053c 	.word	0x3018053c

1800220c <log_init>:
{
1800220c:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
1800220e:	4b10      	ldr	r3, [pc, #64]	; (18002250 <log_init+0x44>)
18002210:	e8d3 5fef 	ldaex	r5, [r3]
18002214:	1c6a      	adds	r2, r5, #1
18002216:	e8c3 2fe1 	stlex	r1, r2, [r3]
1800221a:	2900      	cmp	r1, #0
1800221c:	d1f8      	bne.n	18002210 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
1800221e:	b92d      	cbnz	r5, 1800222c <log_init+0x20>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
18002220:	4c0c      	ldr	r4, [pc, #48]	; (18002254 <log_init+0x48>)
18002222:	4e0d      	ldr	r6, [pc, #52]	; (18002258 <log_init+0x4c>)
18002224:	1b36      	subs	r6, r6, r4
18002226:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
18002228:	42b5      	cmp	r5, r6
1800222a:	db00      	blt.n	1800222e <log_init+0x22>
}
1800222c:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
1800222e:	7b23      	ldrb	r3, [r4, #12]
18002230:	b153      	cbz	r3, 18002248 <log_init+0x3c>
			if (backend->api->init != NULL) {
18002232:	6823      	ldr	r3, [r4, #0]
18002234:	699b      	ldr	r3, [r3, #24]
18002236:	b10b      	cbz	r3, 1800223c <log_init+0x30>
				backend->api->init(backend);
18002238:	4620      	mov	r0, r4
1800223a:	4798      	blx	r3
			log_backend_enable(backend,
1800223c:	6863      	ldr	r3, [r4, #4]
1800223e:	2204      	movs	r2, #4
18002240:	4620      	mov	r0, r4
18002242:	6819      	ldr	r1, [r3, #0]
18002244:	f000 faae 	bl	180027a4 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
18002248:	3501      	adds	r5, #1
1800224a:	3410      	adds	r4, #16
1800224c:	e7ec      	b.n	18002228 <log_init+0x1c>
1800224e:	bf00      	nop
18002250:	30180530 	.word	0x30180530
18002254:	1800b3f8 	.word	0x1800b3f8
18002258:	1800b408 	.word	0x1800b408

1800225c <get_msg>:
{
1800225c:	b510      	push	{r4, lr}
	__asm__ volatile(
1800225e:	f04f 0320 	mov.w	r3, #32
18002262:	f3ef 8411 	mrs	r4, BASEPRI
18002266:	f383 8812 	msr	BASEPRI_MAX, r3
1800226a:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
1800226e:	4804      	ldr	r0, [pc, #16]	; (18002280 <get_msg+0x24>)
18002270:	f006 fa6a 	bl	18008748 <log_list_head_get>
	__asm__ volatile(
18002274:	f384 8811 	msr	BASEPRI, r4
18002278:	f3bf 8f6f 	isb	sy
}
1800227c:	bd10      	pop	{r4, pc}
1800227e:	bf00      	nop
18002280:	30180534 	.word	0x30180534

18002284 <z_log_notify_backend_enabled>:
{
18002284:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
18002286:	4c04      	ldr	r4, [pc, #16]	; (18002298 <z_log_notify_backend_enabled+0x14>)
18002288:	7823      	ldrb	r3, [r4, #0]
1800228a:	b913      	cbnz	r3, 18002292 <z_log_notify_backend_enabled+0xe>
1800228c:	4803      	ldr	r0, [pc, #12]	; (1800229c <z_log_notify_backend_enabled+0x18>)
1800228e:	f004 ff4f 	bl	18007130 <z_impl_k_sem_give>
	backend_attached = true;
18002292:	2301      	movs	r3, #1
18002294:	7023      	strb	r3, [r4, #0]
}
18002296:	bd10      	pop	{r4, pc}
18002298:	30180a60 	.word	0x30180a60
1800229c:	301800d8 	.word	0x301800d8

180022a0 <z_log_dropped>:
180022a0:	4b08      	ldr	r3, [pc, #32]	; (180022c4 <z_log_dropped+0x24>)
180022a2:	e8d3 2fef 	ldaex	r2, [r3]
180022a6:	3201      	adds	r2, #1
180022a8:	e8c3 2fe1 	stlex	r1, r2, [r3]
180022ac:	2900      	cmp	r1, #0
180022ae:	d1f8      	bne.n	180022a2 <z_log_dropped+0x2>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
180022b0:	4b05      	ldr	r3, [pc, #20]	; (180022c8 <z_log_dropped+0x28>)
180022b2:	e8d3 2fef 	ldaex	r2, [r3]
180022b6:	3a01      	subs	r2, #1
180022b8:	e8c3 2fe1 	stlex	r1, r2, [r3]
180022bc:	2900      	cmp	r1, #0
180022be:	d1f8      	bne.n	180022b2 <z_log_dropped+0x12>
}
180022c0:	4770      	bx	lr
180022c2:	bf00      	nop
180022c4:	3018052c 	.word	0x3018052c
180022c8:	30180528 	.word	0x30180528

180022cc <z_log_dropped_read_and_clear>:
}
180022cc:	2000      	movs	r0, #0
180022ce:	4602      	mov	r2, r0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
180022d0:	4b03      	ldr	r3, [pc, #12]	; (180022e0 <z_log_dropped_read_and_clear+0x14>)
180022d2:	e8d3 0fef 	ldaex	r0, [r3]
180022d6:	e8c3 2fe1 	stlex	r1, r2, [r3]
180022da:	2900      	cmp	r1, #0
180022dc:	d1f9      	bne.n	180022d2 <z_log_dropped_read_and_clear+0x6>
180022de:	4770      	bx	lr
180022e0:	3018052c 	.word	0x3018052c

180022e4 <dropped_notify>:
{
180022e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
180022e6:	f7ff fff1 	bl	180022cc <z_log_dropped_read_and_clear>
	for (int i = 0; i < log_backend_count_get(); i++) {
180022ea:	2600      	movs	r6, #0
	uint32_t dropped = z_log_dropped_read_and_clear();
180022ec:	4607      	mov	r7, r0
180022ee:	4c09      	ldr	r4, [pc, #36]	; (18002314 <dropped_notify+0x30>)
180022f0:	4d09      	ldr	r5, [pc, #36]	; (18002318 <dropped_notify+0x34>)
180022f2:	1b2d      	subs	r5, r5, r4
180022f4:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
180022f6:	42ae      	cmp	r6, r5
180022f8:	db00      	blt.n	180022fc <dropped_notify+0x18>
}
180022fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
180022fc:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
180022fe:	795b      	ldrb	r3, [r3, #5]
18002300:	b12b      	cbz	r3, 1800230e <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
18002302:	6823      	ldr	r3, [r4, #0]
18002304:	691b      	ldr	r3, [r3, #16]
18002306:	b113      	cbz	r3, 1800230e <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
18002308:	4639      	mov	r1, r7
1800230a:	4620      	mov	r0, r4
1800230c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
1800230e:	3601      	adds	r6, #1
18002310:	3410      	adds	r4, #16
18002312:	e7f0      	b.n	180022f6 <dropped_notify+0x12>
18002314:	1800b3f8 	.word	0x1800b3f8
18002318:	1800b408 	.word	0x1800b408

1800231c <z_log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
1800231c:	4b14      	ldr	r3, [pc, #80]	; (18002370 <z_log_strdup+0x54>)
{
1800231e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
18002320:	4298      	cmp	r0, r3
{
18002322:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
18002324:	d302      	bcc.n	1800232c <z_log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
18002326:	4b13      	ldr	r3, [pc, #76]	; (18002374 <z_log_strdup+0x58>)
18002328:	4298      	cmp	r0, r3
1800232a:	d31c      	bcc.n	18002366 <z_log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
1800232c:	2200      	movs	r2, #0
1800232e:	2300      	movs	r3, #0
18002330:	4811      	ldr	r0, [pc, #68]	; (18002378 <z_log_strdup+0x5c>)
18002332:	a901      	add	r1, sp, #4
18002334:	f004 fc02 	bl	18006b3c <k_mem_slab_alloc>
	if (err != 0) {
18002338:	4605      	mov	r5, r0
1800233a:	b9b8      	cbnz	r0, 1800236c <z_log_strdup+0x50>
1800233c:	2201      	movs	r2, #1
1800233e:	9b01      	ldr	r3, [sp, #4]
18002340:	e8d3 1fef 	ldaex	r1, [r3]
18002344:	e8c3 2fe0 	stlex	r0, r2, [r3]
18002348:	2800      	cmp	r0, #0
1800234a:	d1f9      	bne.n	18002340 <z_log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
1800234c:	9801      	ldr	r0, [sp, #4]
1800234e:	4621      	mov	r1, r4
18002350:	221f      	movs	r2, #31
18002352:	3004      	adds	r0, #4
18002354:	f007 fe87 	bl	1800a066 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
18002358:	237e      	movs	r3, #126	; 0x7e
1800235a:	9c01      	ldr	r4, [sp, #4]
1800235c:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
18002360:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
18002364:	3404      	adds	r4, #4
}
18002366:	4620      	mov	r0, r4
18002368:	b003      	add	sp, #12
1800236a:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
1800236c:	4c03      	ldr	r4, [pc, #12]	; (1800237c <z_log_strdup+0x60>)
1800236e:	e7fa      	b.n	18002366 <z_log_strdup+0x4a>
18002370:	1800b0d8 	.word	0x1800b0d8
18002374:	1800de34 	.word	0x1800de34
18002378:	3018053c 	.word	0x3018053c
1800237c:	1800c72a 	.word	0x1800c72a

18002380 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
18002380:	b148      	cbz	r0, 18002396 <log_is_strdup+0x16>
18002382:	4b05      	ldr	r3, [pc, #20]	; (18002398 <log_is_strdup+0x18>)
18002384:	4298      	cmp	r0, r3
18002386:	d305      	bcc.n	18002394 <log_is_strdup+0x14>
18002388:	33a0      	adds	r3, #160	; 0xa0
1800238a:	4298      	cmp	r0, r3
1800238c:	bf2c      	ite	cs
1800238e:	2000      	movcs	r0, #0
18002390:	2001      	movcc	r0, #1
18002392:	4770      	bx	lr
18002394:	2000      	movs	r0, #0
}
18002396:	4770      	bx	lr
18002398:	30182e98 	.word	0x30182e98

1800239c <z_impl_log_process>:
	if (!backend_attached && !bypass) {
1800239c:	4b4a      	ldr	r3, [pc, #296]	; (180024c8 <z_impl_log_process+0x12c>)
{
1800239e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
180023a2:	781b      	ldrb	r3, [r3, #0]
{
180023a4:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
180023a6:	b903      	cbnz	r3, 180023aa <z_impl_log_process+0xe>
180023a8:	b1e0      	cbz	r0, 180023e4 <z_impl_log_process+0x48>
	msg = get_msg();
180023aa:	f7ff ff57 	bl	1800225c <get_msg>
	if (msg.msg) {
180023ae:	4604      	mov	r4, r0
180023b0:	b158      	cbz	r0, 180023ca <z_impl_log_process+0x2e>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
180023b2:	4b46      	ldr	r3, [pc, #280]	; (180024cc <z_impl_log_process+0x130>)
180023b4:	e8d3 2fef 	ldaex	r2, [r3]
180023b8:	3a01      	subs	r2, #1
180023ba:	e8c3 2fe1 	stlex	r1, r2, [r3]
180023be:	2900      	cmp	r1, #0
180023c0:	d1f8      	bne.n	180023b4 <z_impl_log_process+0x18>
	if (!bypass) {
180023c2:	b19d      	cbz	r5, 180023ec <z_impl_log_process+0x50>
			log_msg_put(msg.msg);
180023c4:	4620      	mov	r0, r4
180023c6:	f006 face 	bl	18008966 <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
180023ca:	b92d      	cbnz	r5, 180023d8 <z_impl_log_process+0x3c>
	return dropped_cnt > 0;
180023cc:	4b40      	ldr	r3, [pc, #256]	; (180024d0 <z_impl_log_process+0x134>)
	if (!bypass && z_log_dropped_pending()) {
180023ce:	681b      	ldr	r3, [r3, #0]
180023d0:	2b00      	cmp	r3, #0
180023d2:	dd01      	ble.n	180023d8 <z_impl_log_process+0x3c>
		dropped_notify();
180023d4:	f7ff ff86 	bl	180022e4 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
180023d8:	483e      	ldr	r0, [pc, #248]	; (180024d4 <z_impl_log_process+0x138>)
180023da:	f006 f9b3 	bl	18008744 <log_list_head_peek>
180023de:	1e05      	subs	r5, r0, #0
180023e0:	bf18      	it	ne
180023e2:	2501      	movne	r5, #1
}
180023e4:	4628      	mov	r0, r5
180023e6:	b003      	add	sp, #12
180023e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
180023ec:	4b3a      	ldr	r3, [pc, #232]	; (180024d8 <z_impl_log_process+0x13c>)
		if (!IS_ENABLED(CONFIG_LOG2) &&
180023ee:	781b      	ldrb	r3, [r3, #0]
180023f0:	b9bb      	cbnz	r3, 18002422 <z_impl_log_process+0x86>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
180023f2:	7a23      	ldrb	r3, [r4, #8]
	if (!log_msg_is_std(msg)) {
180023f4:	07da      	lsls	r2, r3, #31
180023f6:	d414      	bmi.n	18002422 <z_impl_log_process+0x86>
	msg_str = log_msg_str_get(msg);
180023f8:	f006 fac4 	bl	18008984 <log_msg_str_get>
180023fc:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
180023fe:	4620      	mov	r0, r4
18002400:	f006 fa8f 	bl	18008922 <log_msg_nargs_get>
18002404:	4601      	mov	r1, r0
18002406:	4640      	mov	r0, r8
18002408:	f006 f9b1 	bl	1800876e <z_log_get_s_mask>
1800240c:	4606      	mov	r6, r0
1800240e:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 180024dc <z_impl_log_process+0x140>
18002412:	4b33      	ldr	r3, [pc, #204]	; (180024e0 <z_impl_log_process+0x144>)
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
18002414:	f8df b0cc 	ldr.w	fp, [pc, #204]	; 180024e4 <z_impl_log_process+0x148>
18002418:	eba9 0303 	sub.w	r3, r9, r3
1800241c:	ea4f 0a93 	mov.w	sl, r3, lsr #2
	while (mask) {
18002420:	b936      	cbnz	r6, 18002430 <z_impl_log_process+0x94>
	return __log_backends_end - __log_backends_start;
18002422:	4e31      	ldr	r6, [pc, #196]	; (180024e8 <z_impl_log_process+0x14c>)
18002424:	4b31      	ldr	r3, [pc, #196]	; (180024ec <z_impl_log_process+0x150>)
18002426:	2700      	movs	r7, #0
18002428:	1b9b      	subs	r3, r3, r6
1800242a:	ea4f 1823 	mov.w	r8, r3, asr #4
1800242e:	e048      	b.n	180024c2 <z_impl_log_process+0x126>
		idx = 31 - __builtin_clz(mask);
18002430:	fab6 f786 	clz	r7, r6
18002434:	f1c7 071f 	rsb	r7, r7, #31
		str = (const char *)log_msg_arg_get(msg, idx);
18002438:	4639      	mov	r1, r7
1800243a:	4620      	mov	r0, r4
1800243c:	f006 fa74 	bl	18008928 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
18002440:	4b2b      	ldr	r3, [pc, #172]	; (180024f0 <z_impl_log_process+0x154>)
		str = (const char *)log_msg_arg_get(msg, idx);
18002442:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
18002444:	4298      	cmp	r0, r3
18002446:	d302      	bcc.n	1800244e <z_impl_log_process+0xb2>
		if (!is_rodata(str) && !log_is_strdup(str) &&
18002448:	4b2a      	ldr	r3, [pc, #168]	; (180024f4 <z_impl_log_process+0x158>)
1800244a:	4298      	cmp	r0, r3
1800244c:	d31b      	bcc.n	18002486 <z_impl_log_process+0xea>
1800244e:	4610      	mov	r0, r2
18002450:	f7ff ff96 	bl	18002380 <log_is_strdup>
18002454:	b9b8      	cbnz	r0, 18002486 <z_impl_log_process+0xea>
18002456:	4b28      	ldr	r3, [pc, #160]	; (180024f8 <z_impl_log_process+0x15c>)
18002458:	429a      	cmp	r2, r3
1800245a:	d014      	beq.n	18002486 <z_impl_log_process+0xea>
	return msg->hdr.ids.source_id;
1800245c:	8961      	ldrh	r1, [r4, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
1800245e:	f3c1 1189 	ubfx	r1, r1, #6, #10
18002462:	f000 f925 	bl	180026b0 <log_source_name_get>
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
18002466:	f8d9 3000 	ldr.w	r3, [r9]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
1800246a:	4602      	mov	r2, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
1800246c:	075b      	lsls	r3, r3, #29
1800246e:	d00a      	beq.n	18002486 <z_impl_log_process+0xea>
18002470:	ea4f 138a 	mov.w	r3, sl, lsl #6
18002474:	f043 0301 	orr.w	r3, r3, #1
18002478:	f8ad 3000 	strh.w	r3, [sp]
1800247c:	4639      	mov	r1, r7
1800247e:	4643      	mov	r3, r8
18002480:	4658      	mov	r0, fp
18002482:	f006 f9ce 	bl	18008822 <log_3>
		mask &= ~BIT(idx);
18002486:	2301      	movs	r3, #1
18002488:	fa03 f707 	lsl.w	r7, r3, r7
1800248c:	ea26 0607 	bic.w	r6, r6, r7
18002490:	e7c6      	b.n	18002420 <z_impl_log_process+0x84>
	return backend->cb->active;
18002492:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
18002494:	795b      	ldrb	r3, [r3, #5]
18002496:	b193      	cbz	r3, 180024be <z_impl_log_process+0x122>
	return msg->hdr.ids.level;
18002498:	7aa1      	ldrb	r1, [r4, #10]
	return msg->hdr.ids.source_id;
1800249a:	8962      	ldrh	r2, [r4, #10]
	return msg->hdr.ids.level;
1800249c:	f001 0907 	and.w	r9, r1, #7
	backend_level = log_filter_get(backend, domain_id,
180024a0:	2301      	movs	r3, #1
180024a2:	4630      	mov	r0, r6
180024a4:	f3c2 1289 	ubfx	r2, r2, #6, #10
180024a8:	f3c1 01c2 	ubfx	r1, r1, #3, #3
180024ac:	f000 f990 	bl	180027d0 <log_filter_get>
			if (log_backend_is_active(backend) &&
180024b0:	4581      	cmp	r9, r0
180024b2:	d804      	bhi.n	180024be <z_impl_log_process+0x122>
	backend->api->put(backend, msg);
180024b4:	6833      	ldr	r3, [r6, #0]
180024b6:	4621      	mov	r1, r4
180024b8:	4630      	mov	r0, r6
180024ba:	685b      	ldr	r3, [r3, #4]
180024bc:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
180024be:	3701      	adds	r7, #1
180024c0:	3610      	adds	r6, #16
180024c2:	4547      	cmp	r7, r8
180024c4:	dbe5      	blt.n	18002492 <z_impl_log_process+0xf6>
180024c6:	e77d      	b.n	180023c4 <z_impl_log_process+0x28>
180024c8:	30180a60 	.word	0x30180a60
180024cc:	30180528 	.word	0x30180528
180024d0:	3018052c 	.word	0x3018052c
180024d4:	30180534 	.word	0x30180534
180024d8:	30180a61 	.word	0x30180a61
180024dc:	30180090 	.word	0x30180090
180024e0:	3018008c 	.word	0x3018008c
180024e4:	1800c744 	.word	0x1800c744
180024e8:	1800b3f8 	.word	0x1800b3f8
180024ec:	1800b408 	.word	0x1800b408
180024f0:	1800b0d8 	.word	0x1800b0d8
180024f4:	1800de34 	.word	0x1800de34
180024f8:	1800c72a 	.word	0x1800c72a

180024fc <log_process_thread_func>:
{
180024fc:	b510      	push	{r4, lr}
	log_init();
180024fe:	f7ff fe85 	bl	1800220c <log_init>
	return z_impl_z_current_get();
18002502:	f005 f949 	bl	18007798 <z_impl_z_current_get>
	proc_tid = process_tid;
18002506:	4b0c      	ldr	r3, [pc, #48]	; (18002538 <log_process_thread_func+0x3c>)
18002508:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
1800250a:	b130      	cbz	r0, 1800251a <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
1800250c:	4b0b      	ldr	r3, [pc, #44]	; (1800253c <log_process_thread_func+0x40>)
	    process_tid &&
1800250e:	681b      	ldr	r3, [r3, #0]
18002510:	2b09      	cmp	r3, #9
18002512:	dd02      	ble.n	1800251a <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
18002514:	480a      	ldr	r0, [pc, #40]	; (18002540 <log_process_thread_func+0x44>)
18002516:	f004 fe0b 	bl	18007130 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
1800251a:	4c09      	ldr	r4, [pc, #36]	; (18002540 <log_process_thread_func+0x44>)
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
1800251c:	2000      	movs	r0, #0
1800251e:	f7ff ff3d 	bl	1800239c <z_impl_log_process>
		if (log_process(false) == false) {
18002522:	2800      	cmp	r0, #0
18002524:	d1fa      	bne.n	1800251c <log_process_thread_func+0x20>
18002526:	f04f 32ff 	mov.w	r2, #4294967295
1800252a:	f04f 33ff 	mov.w	r3, #4294967295
1800252e:	4620      	mov	r0, r4
18002530:	f004 fe24 	bl	1800717c <z_impl_k_sem_take>
18002534:	e7f2      	b.n	1800251c <log_process_thread_func+0x20>
18002536:	bf00      	nop
18002538:	30180558 	.word	0x30180558
1800253c:	30180528 	.word	0x30180528
18002540:	301800d8 	.word	0x301800d8

18002544 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
18002544:	4b27      	ldr	r3, [pc, #156]	; (180025e4 <msg_finalize+0xa0>)
{
18002546:	b537      	push	{r0, r1, r2, r4, r5, lr}
	msg->hdr.timestamp = timestamp_func();
18002548:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
1800254a:	8141      	strh	r1, [r0, #10]
{
1800254c:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
1800254e:	4798      	blx	r3
18002550:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
18002552:	f04f 0320 	mov.w	r3, #32
18002556:	f3ef 8511 	mrs	r5, BASEPRI
1800255a:	f383 8812 	msr	BASEPRI_MAX, r3
1800255e:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
18002562:	4821      	ldr	r0, [pc, #132]	; (180025e8 <msg_finalize+0xa4>)
18002564:	4621      	mov	r1, r4
18002566:	f006 f8e3 	bl	18008730 <log_list_add_tail>
	__asm__ volatile(
1800256a:	f385 8811 	msr	BASEPRI, r5
1800256e:	f3bf 8f6f 	isb	sy
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
18002572:	4b1e      	ldr	r3, [pc, #120]	; (180025ec <msg_finalize+0xa8>)
18002574:	e8d3 2fef 	ldaex	r2, [r3]
18002578:	3201      	adds	r2, #1
1800257a:	e8c3 2fe1 	stlex	r1, r2, [r3]
1800257e:	2900      	cmp	r1, #0
18002580:	d1f8      	bne.n	18002574 <msg_finalize+0x30>
	if (panic_mode) {
18002582:	4a1b      	ldr	r2, [pc, #108]	; (180025f0 <msg_finalize+0xac>)
18002584:	7812      	ldrb	r2, [r2, #0]
18002586:	b182      	cbz	r2, 180025aa <msg_finalize+0x66>
	__asm__ volatile(
18002588:	f04f 0320 	mov.w	r3, #32
1800258c:	f3ef 8411 	mrs	r4, BASEPRI
18002590:	f383 8812 	msr	BASEPRI_MAX, r3
18002594:	f3bf 8f6f 	isb	sy
18002598:	2000      	movs	r0, #0
1800259a:	f7ff feff 	bl	1800239c <z_impl_log_process>
	__asm__ volatile(
1800259e:	f384 8811 	msr	BASEPRI, r4
180025a2:	f3bf 8f6f 	isb	sy
}
180025a6:	b003      	add	sp, #12
180025a8:	bd30      	pop	{r4, r5, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
180025aa:	4a12      	ldr	r2, [pc, #72]	; (180025f4 <msg_finalize+0xb0>)
180025ac:	681b      	ldr	r3, [r3, #0]
180025ae:	6812      	ldr	r2, [r2, #0]
180025b0:	2a00      	cmp	r2, #0
180025b2:	d0f8      	beq.n	180025a6 <msg_finalize+0x62>
180025b4:	2b01      	cmp	r3, #1
180025b6:	d10a      	bne.n	180025ce <msg_finalize+0x8a>
	z_impl_k_timer_start(timer, duration, period);
180025b8:	2200      	movs	r2, #0
180025ba:	2300      	movs	r3, #0
180025bc:	480e      	ldr	r0, [pc, #56]	; (180025f8 <msg_finalize+0xb4>)
180025be:	e9cd 2300 	strd	r2, r3, [sp]
180025c2:	f242 7210 	movw	r2, #10000	; 0x2710
180025c6:	2300      	movs	r3, #0
180025c8:	f005 fb16 	bl	18007bf8 <z_impl_k_timer_start>
180025cc:	e7eb      	b.n	180025a6 <msg_finalize+0x62>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
180025ce:	2b0a      	cmp	r3, #10
180025d0:	d1e9      	bne.n	180025a6 <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
180025d2:	4809      	ldr	r0, [pc, #36]	; (180025f8 <msg_finalize+0xb4>)
180025d4:	f008 fbcc 	bl	1800ad70 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
180025d8:	4808      	ldr	r0, [pc, #32]	; (180025fc <msg_finalize+0xb8>)
}
180025da:	b003      	add	sp, #12
180025dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
180025e0:	f004 bda6 	b.w	18007130 <z_impl_k_sem_give>
180025e4:	30180004 	.word	0x30180004
180025e8:	30180534 	.word	0x30180534
180025ec:	30180528 	.word	0x30180528
180025f0:	30180a61 	.word	0x30180a61
180025f4:	30180558 	.word	0x30180558
180025f8:	301800f0 	.word	0x301800f0
180025fc:	301800d8 	.word	0x301800d8

18002600 <z_impl_log_panic>:
{
18002600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
18002602:	4f0e      	ldr	r7, [pc, #56]	; (1800263c <z_impl_log_panic+0x3c>)
18002604:	783d      	ldrb	r5, [r7, #0]
18002606:	b975      	cbnz	r5, 18002626 <z_impl_log_panic+0x26>
	log_init();
18002608:	f7ff fe00 	bl	1800220c <log_init>
	return __log_backends_end - __log_backends_start;
1800260c:	4c0c      	ldr	r4, [pc, #48]	; (18002640 <z_impl_log_panic+0x40>)
1800260e:	4e0d      	ldr	r6, [pc, #52]	; (18002644 <z_impl_log_panic+0x44>)
18002610:	1b36      	subs	r6, r6, r4
18002612:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
18002614:	42b5      	cmp	r5, r6
18002616:	db07      	blt.n	18002628 <z_impl_log_panic+0x28>
18002618:	2000      	movs	r0, #0
1800261a:	f7ff febf 	bl	1800239c <z_impl_log_process>
		while (log_process(false) == true) {
1800261e:	2800      	cmp	r0, #0
18002620:	d1fa      	bne.n	18002618 <z_impl_log_panic+0x18>
	panic_mode = true;
18002622:	2301      	movs	r3, #1
18002624:	703b      	strb	r3, [r7, #0]
}
18002626:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
18002628:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
1800262a:	795b      	ldrb	r3, [r3, #5]
1800262c:	b11b      	cbz	r3, 18002636 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
1800262e:	6823      	ldr	r3, [r4, #0]
18002630:	4620      	mov	r0, r4
18002632:	695b      	ldr	r3, [r3, #20]
18002634:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
18002636:	3501      	adds	r5, #1
18002638:	3410      	adds	r4, #16
1800263a:	e7eb      	b.n	18002614 <z_impl_log_panic+0x14>
1800263c:	30180a61 	.word	0x30180a61
18002640:	1800b3f8 	.word	0x1800b3f8
18002644:	1800b408 	.word	0x1800b408

18002648 <z_log_free>:
{
18002648:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
1800264a:	3804      	subs	r0, #4
1800264c:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
1800264e:	e8d0 3fef 	ldaex	r3, [r0]
18002652:	1e5a      	subs	r2, r3, #1
18002654:	e8c0 2fe1 	stlex	r1, r2, [r0]
18002658:	2900      	cmp	r1, #0
1800265a:	d1f8      	bne.n	1800264e <z_log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
1800265c:	2b01      	cmp	r3, #1
1800265e:	d103      	bne.n	18002668 <z_log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
18002660:	4803      	ldr	r0, [pc, #12]	; (18002670 <z_log_free+0x28>)
18002662:	a901      	add	r1, sp, #4
18002664:	f008 f9c9 	bl	1800a9fa <k_mem_slab_free>
}
18002668:	b003      	add	sp, #12
1800266a:	f85d fb04 	ldr.w	pc, [sp], #4
1800266e:	bf00      	nop
18002670:	3018053c 	.word	0x3018053c

18002674 <z_log_runtime_filters_init>:
	 *
	 * Each log source's aggregated runtime level is set to match its
	 * compile-time level. When backends are attached later on in
	 * log_init(), they'll be initialized to the same value.
	 */
	for (int i = 0; i < z_log_sources_count(); i++) {
18002674:	2100      	movs	r1, #0
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
18002676:	480b      	ldr	r0, [pc, #44]	; (180026a4 <z_log_runtime_filters_init+0x30>)
18002678:	4b0b      	ldr	r3, [pc, #44]	; (180026a8 <z_log_runtime_filters_init+0x34>)
{
1800267a:	b530      	push	{r4, r5, lr}
1800267c:	1a1b      	subs	r3, r3, r0
1800267e:	4c0b      	ldr	r4, [pc, #44]	; (180026ac <z_log_runtime_filters_init+0x38>)
18002680:	08db      	lsrs	r3, r3, #3
	return __log_const_start[source_id].level;
18002682:	3004      	adds	r0, #4
	for (int i = 0; i < z_log_sources_count(); i++) {
18002684:	4299      	cmp	r1, r3
18002686:	d100      	bne.n	1800268a <z_log_runtime_filters_init+0x16>

		LOG_FILTER_SLOT_SET(filters,
				    LOG_FILTER_AGGR_SLOT_IDX,
				    level);
	}
}
18002688:	bd30      	pop	{r4, r5, pc}
		LOG_FILTER_SLOT_SET(filters,
1800268a:	f810 2031 	ldrb.w	r2, [r0, r1, lsl #3]
1800268e:	6825      	ldr	r5, [r4, #0]
18002690:	f002 0207 	and.w	r2, r2, #7
18002694:	f025 0507 	bic.w	r5, r5, #7
18002698:	432a      	orrs	r2, r5
1800269a:	f844 2b04 	str.w	r2, [r4], #4
	for (int i = 0; i < z_log_sources_count(); i++) {
1800269e:	3101      	adds	r1, #1
180026a0:	e7f0      	b.n	18002684 <z_log_runtime_filters_init+0x10>
180026a2:	bf00      	nop
180026a4:	1800b3c0 	.word	0x1800b3c0
180026a8:	1800b3f8 	.word	0x1800b3f8
180026ac:	3018008c 	.word	0x3018008c

180026b0 <log_source_name_get>:
180026b0:	4a04      	ldr	r2, [pc, #16]	; (180026c4 <log_source_name_get+0x14>)
180026b2:	4b05      	ldr	r3, [pc, #20]	; (180026c8 <log_source_name_get+0x18>)
180026b4:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
180026b6:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
180026ba:	bf34      	ite	cc
180026bc:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
180026c0:	2000      	movcs	r0, #0
}
180026c2:	4770      	bx	lr
180026c4:	1800b3c0 	.word	0x1800b3c0
180026c8:	1800b3f8 	.word	0x1800b3f8

180026cc <z_impl_log_filter_set>:
}

uint32_t z_impl_log_filter_set(struct log_backend const *const backend,
			       uint32_t domain_id, int16_t source_id,
			       uint32_t level)
{
180026cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
180026d0:	4689      	mov	r9, r1
180026d2:	4616      	mov	r6, r2
180026d4:	4698      	mov	r8, r3
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) {
		uint32_t new_aggr_filter;

		uint32_t *filters = z_log_dynamic_filters_get(source_id);

		if (backend == NULL) {
180026d6:	4604      	mov	r4, r0
180026d8:	b9b8      	cbnz	r0, 1800270a <z_impl_log_filter_set+0x3e>
			struct log_backend const *iter_backend;
			uint32_t max = 0U;
180026da:	4605      	mov	r5, r0
	return __log_backends_end - __log_backends_start;
180026dc:	f8df a084 	ldr.w	sl, [pc, #132]	; 18002764 <z_impl_log_filter_set+0x98>
180026e0:	4f21      	ldr	r7, [pc, #132]	; (18002768 <z_impl_log_filter_set+0x9c>)
180026e2:	eba7 070a 	sub.w	r7, r7, sl
180026e6:	113f      	asrs	r7, r7, #4
			uint32_t current;

			for (int i = 0; i < log_backend_count_get(); i++) {
180026e8:	42bc      	cmp	r4, r7
180026ea:	db02      	blt.n	180026f2 <z_impl_log_filter_set+0x26>
					    new_aggr_filter);
		}
	}

	return level;
}
180026ec:	4628      	mov	r0, r5
180026ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		/* coverity[OVERRUN] */
		return (uint32_t) arch_syscall_invoke4(*(uintptr_t *)&backend, *(uintptr_t *)&domain_id, *(uintptr_t *)&source_id, *(uintptr_t *)&level, K_SYSCALL_LOG_FILTER_SET);
	}
#endif
	compiler_barrier();
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
180026f2:	eb0a 1004 	add.w	r0, sl, r4, lsl #4
180026f6:	4643      	mov	r3, r8
180026f8:	4632      	mov	r2, r6
180026fa:	4649      	mov	r1, r9
180026fc:	f7ff ffe6 	bl	180026cc <z_impl_log_filter_set>
				max = MAX(current, max);
18002700:	4285      	cmp	r5, r0
18002702:	bf38      	it	cc
18002704:	4605      	movcc	r5, r0
			for (int i = 0; i < log_backend_count_get(); i++) {
18002706:	3401      	adds	r4, #1
18002708:	e7ee      	b.n	180026e8 <z_impl_log_filter_set+0x1c>
	return __log_const_start[source_id].level;
1800270a:	4b18      	ldr	r3, [pc, #96]	; (1800276c <z_impl_log_filter_set+0xa0>)
			LOG_FILTER_SLOT_SET(filters,
1800270c:	4c18      	ldr	r4, [pc, #96]	; (18002770 <z_impl_log_filter_set+0xa4>)
	return __log_const_start[source_id].level;
1800270e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3

		return LOG_FILTER_SLOT_GET(filters,
					   log_backend_id_get(backend));
	}

	return log_compiled_level_get(source_id);
18002712:	791d      	ldrb	r5, [r3, #4]
	return backend->cb->id;
18002714:	6843      	ldr	r3, [r0, #4]
			level = MIN(level, max);
18002716:	4545      	cmp	r5, r8
			LOG_FILTER_SLOT_SET(filters,
18002718:	791a      	ldrb	r2, [r3, #4]
1800271a:	f04f 0307 	mov.w	r3, #7
			level = MIN(level, max);
1800271e:	bf28      	it	cs
18002720:	4645      	movcs	r5, r8
			LOG_FILTER_SLOT_SET(filters,
18002722:	eb02 0242 	add.w	r2, r2, r2, lsl #1
18002726:	fa03 f102 	lsl.w	r1, r3, r2
1800272a:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
1800272e:	ea23 0301 	bic.w	r3, r3, r1
18002732:	f005 0107 	and.w	r1, r5, #7
18002736:	fa01 f202 	lsl.w	r2, r1, r2
1800273a:	4313      	orrs	r3, r2
	uint32_t max_filter = LOG_LEVEL_NONE;
1800273c:	2100      	movs	r1, #0
			LOG_FILTER_SLOT_SET(filters,
1800273e:	2203      	movs	r2, #3
		uint32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
18002740:	fa23 f002 	lsr.w	r0, r3, r2
18002744:	f000 0007 	and.w	r0, r0, #7
18002748:	4281      	cmp	r1, r0
1800274a:	f102 0203 	add.w	r2, r2, #3
1800274e:	bf38      	it	cc
18002750:	4601      	movcc	r1, r0
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
18002752:	2a1e      	cmp	r2, #30
18002754:	d1f4      	bne.n	18002740 <z_impl_log_filter_set+0x74>
			LOG_FILTER_SLOT_SET(filters,
18002756:	f023 0307 	bic.w	r3, r3, #7
1800275a:	430b      	orrs	r3, r1
1800275c:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
	return level;
18002760:	e7c4      	b.n	180026ec <z_impl_log_filter_set+0x20>
18002762:	bf00      	nop
18002764:	1800b3f8 	.word	0x1800b3f8
18002768:	1800b408 	.word	0x1800b408
1800276c:	1800b3c0 	.word	0x1800b3c0
18002770:	3018008c 	.word	0x3018008c

18002774 <backend_filter_set>:
{
18002774:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18002776:	4606      	mov	r6, r0
18002778:	460f      	mov	r7, r1
		for (int i = 0; i < z_log_sources_count(); i++) {
1800277a:	2500      	movs	r5, #0
1800277c:	4c07      	ldr	r4, [pc, #28]	; (1800279c <backend_filter_set+0x28>)
1800277e:	4b08      	ldr	r3, [pc, #32]	; (180027a0 <backend_filter_set+0x2c>)
18002780:	1ae4      	subs	r4, r4, r3
18002782:	08e4      	lsrs	r4, r4, #3
18002784:	42a5      	cmp	r5, r4
18002786:	d100      	bne.n	1800278a <backend_filter_set+0x16>
}
18002788:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
1800278a:	2100      	movs	r1, #0
1800278c:	b22a      	sxth	r2, r5
1800278e:	463b      	mov	r3, r7
18002790:	4630      	mov	r0, r6
18002792:	f7ff ff9b 	bl	180026cc <z_impl_log_filter_set>
		for (int i = 0; i < z_log_sources_count(); i++) {
18002796:	3501      	adds	r5, #1
18002798:	e7f4      	b.n	18002784 <backend_filter_set+0x10>
1800279a:	bf00      	nop
1800279c:	1800b3f8 	.word	0x1800b3f8
180027a0:	1800b3c0 	.word	0x1800b3c0

180027a4 <log_backend_enable>:
	id += backend - log_backend_get(0);
180027a4:	4b09      	ldr	r3, [pc, #36]	; (180027cc <log_backend_enable+0x28>)
{
180027a6:	b570      	push	{r4, r5, r6, lr}
	id += backend - log_backend_get(0);
180027a8:	1ac3      	subs	r3, r0, r3
	backend->cb->id = id;
180027aa:	6846      	ldr	r6, [r0, #4]
180027ac:	111b      	asrs	r3, r3, #4
{
180027ae:	4604      	mov	r4, r0
	id += backend - log_backend_get(0);
180027b0:	3301      	adds	r3, #1
{
180027b2:	460d      	mov	r5, r1
	log_backend_id_set(backend, id);
180027b4:	7133      	strb	r3, [r6, #4]
	backend_filter_set(backend, level);
180027b6:	4611      	mov	r1, r2
180027b8:	f7ff ffdc 	bl	18002774 <backend_filter_set>
	backend->cb->active = true;
180027bc:	2201      	movs	r2, #1
	backend->cb->ctx = ctx;
180027be:	6863      	ldr	r3, [r4, #4]
180027c0:	601d      	str	r5, [r3, #0]
	backend->cb->active = true;
180027c2:	715a      	strb	r2, [r3, #5]
}
180027c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_log_notify_backend_enabled();
180027c8:	f7ff bd5c 	b.w	18002284 <z_log_notify_backend_enabled>
180027cc:	1800b3f8 	.word	0x1800b3f8

180027d0 <log_filter_get>:
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
180027d0:	b163      	cbz	r3, 180027ec <log_filter_get+0x1c>
		if (source_id < 0) {
180027d2:	2a00      	cmp	r2, #0
180027d4:	db0f      	blt.n	180027f6 <log_filter_get+0x26>
	return backend->cb->id;
180027d6:	6843      	ldr	r3, [r0, #4]
		return LOG_FILTER_SLOT_GET(filters,
180027d8:	4908      	ldr	r1, [pc, #32]	; (180027fc <log_filter_get+0x2c>)
180027da:	7918      	ldrb	r0, [r3, #4]
180027dc:	eb00 0340 	add.w	r3, r0, r0, lsl #1
180027e0:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
180027e4:	40d8      	lsrs	r0, r3
180027e6:	f000 0007 	and.w	r0, r0, #7
180027ea:	4770      	bx	lr
	return __log_const_start[source_id].level;
180027ec:	4b04      	ldr	r3, [pc, #16]	; (18002800 <log_filter_get+0x30>)
180027ee:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
	return log_compiled_level_get(source_id);
180027f2:	7910      	ldrb	r0, [r2, #4]
180027f4:	4770      	bx	lr
			return LOG_LEVEL_DBG;
180027f6:	2004      	movs	r0, #4
}
180027f8:	4770      	bx	lr
180027fa:	bf00      	nop
180027fc:	3018008c 	.word	0x3018008c
18002800:	1800b3c0 	.word	0x1800b3c0

18002804 <log_msg_pool_init>:
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
18002804:	2320      	movs	r3, #32
18002806:	4902      	ldr	r1, [pc, #8]	; (18002810 <log_msg_pool_init+0xc>)
18002808:	461a      	mov	r2, r3
1800280a:	4802      	ldr	r0, [pc, #8]	; (18002814 <log_msg_pool_init+0x10>)
1800280c:	f008 b8da 	b.w	1800a9c4 <k_mem_slab_init>
18002810:	30182f38 	.word	0x30182f38
18002814:	3018055c 	.word	0x3018055c

18002818 <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
18002818:	2300      	movs	r3, #0
{
1800281a:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
1800281c:	4d09      	ldr	r5, [pc, #36]	; (18002844 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
1800281e:	9301      	str	r3, [sp, #4]
	return z_impl_log_process(bypass);
18002820:	2001      	movs	r0, #1
18002822:	f7ff fdbb 	bl	1800239c <z_impl_log_process>
18002826:	4604      	mov	r4, r0
			z_log_dropped();
18002828:	f7ff fd3a 	bl	180022a0 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
1800282c:	2200      	movs	r2, #0
1800282e:	2300      	movs	r3, #0
18002830:	4628      	mov	r0, r5
18002832:	a901      	add	r1, sp, #4
18002834:	f004 f982 	bl	18006b3c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
18002838:	b108      	cbz	r0, 1800283e <log_msg_no_space_handle+0x26>
1800283a:	2c00      	cmp	r4, #0
1800283c:	d1f0      	bne.n	18002820 <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
1800283e:	9801      	ldr	r0, [sp, #4]
18002840:	b003      	add	sp, #12
18002842:	bd30      	pop	{r4, r5, pc}
18002844:	3018055c 	.word	0x3018055c

18002848 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
18002848:	2300      	movs	r3, #0
{
1800284a:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
1800284c:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
1800284e:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
18002850:	4806      	ldr	r0, [pc, #24]	; (1800286c <log_msg_chunk_alloc+0x24>)
18002852:	2300      	movs	r3, #0
18002854:	a901      	add	r1, sp, #4
18002856:	f004 f971 	bl	18006b3c <k_mem_slab_alloc>
	if (err != 0) {
1800285a:	b110      	cbz	r0, 18002862 <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
1800285c:	f7ff ffdc 	bl	18002818 <log_msg_no_space_handle>
18002860:	9001      	str	r0, [sp, #4]
}
18002862:	9801      	ldr	r0, [sp, #4]
18002864:	b003      	add	sp, #12
18002866:	f85d fb04 	ldr.w	pc, [sp], #4
1800286a:	bf00      	nop
1800286c:	3018055c 	.word	0x3018055c

18002870 <msg_free>:
{
18002870:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
18002872:	7a03      	ldrb	r3, [r0, #8]
18002874:	b085      	sub	sp, #20
	if (log_msg_is_std(msg) && nargs) {
18002876:	07dc      	lsls	r4, r3, #31
{
18002878:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
1800287a:	d41e      	bmi.n	180028ba <msg_free+0x4a>
	}
}

uint32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
1800287c:	7a45      	ldrb	r5, [r0, #9]
	if (log_msg_is_std(msg) && nargs) {
1800287e:	092d      	lsrs	r5, r5, #4
18002880:	d01b      	beq.n	180028ba <msg_free+0x4a>
		uint32_t smask = 0U;
18002882:	2400      	movs	r4, #0
		for (i = 0U; i < nargs; i++) {
18002884:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
18002886:	4631      	mov	r1, r6
18002888:	9801      	ldr	r0, [sp, #4]
1800288a:	f006 f84d 	bl	18008928 <log_msg_arg_get>
1800288e:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
18002890:	f7ff fd76 	bl	18002380 <log_is_strdup>
18002894:	b170      	cbz	r0, 180028b4 <msg_free+0x44>
				if (smask == 0U) {
18002896:	b934      	cbnz	r4, 180028a6 <msg_free+0x36>
					smask = z_log_get_s_mask(
18002898:	9b01      	ldr	r3, [sp, #4]
1800289a:	4629      	mov	r1, r5
1800289c:	6918      	ldr	r0, [r3, #16]
1800289e:	f005 ff66 	bl	1800876e <z_log_get_s_mask>
					if (smask == 0U) {
180028a2:	4604      	mov	r4, r0
180028a4:	b148      	cbz	r0, 180028ba <msg_free+0x4a>
				if (smask & BIT(i)) {
180028a6:	fa24 f306 	lsr.w	r3, r4, r6
180028aa:	07d9      	lsls	r1, r3, #31
180028ac:	d502      	bpl.n	180028b4 <msg_free+0x44>
					z_log_free(buf);
180028ae:	4638      	mov	r0, r7
180028b0:	f7ff feca 	bl	18002648 <z_log_free>
		for (i = 0U; i < nargs; i++) {
180028b4:	3601      	adds	r6, #1
180028b6:	42ae      	cmp	r6, r5
180028b8:	d3e5      	bcc.n	18002886 <msg_free+0x16>
	if (msg->hdr.params.generic.ext == 1) {
180028ba:	9b01      	ldr	r3, [sp, #4]
180028bc:	7a1a      	ldrb	r2, [r3, #8]
180028be:	0792      	lsls	r2, r2, #30
180028c0:	d504      	bpl.n	180028cc <msg_free+0x5c>
		cont_free(msg->payload.ext.next);
180028c2:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
180028c4:	4c08      	ldr	r4, [pc, #32]	; (180028e8 <msg_free+0x78>)
180028c6:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
180028c8:	9b03      	ldr	r3, [sp, #12]
180028ca:	b92b      	cbnz	r3, 180028d8 <msg_free+0x68>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
180028cc:	4806      	ldr	r0, [pc, #24]	; (180028e8 <msg_free+0x78>)
180028ce:	a901      	add	r1, sp, #4
180028d0:	f008 f893 	bl	1800a9fa <k_mem_slab_free>
}
180028d4:	b005      	add	sp, #20
180028d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
180028d8:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
180028da:	4620      	mov	r0, r4
180028dc:	a903      	add	r1, sp, #12
180028de:	f008 f88c 	bl	1800a9fa <k_mem_slab_free>
		cont = next;
180028e2:	9503      	str	r5, [sp, #12]
180028e4:	e7f0      	b.n	180028c8 <msg_free+0x58>
180028e6:	bf00      	nop
180028e8:	3018055c 	.word	0x3018055c

180028ec <log_msg_mem_get_free>:
	return slab->num_blocks - slab->num_used;
180028ec:	4b02      	ldr	r3, [pc, #8]	; (180028f8 <log_msg_mem_get_free+0xc>)
180028ee:	6898      	ldr	r0, [r3, #8]
180028f0:	699b      	ldr	r3, [r3, #24]
}

uint32_t log_msg_mem_get_free(void)
{
	return k_mem_slab_num_free_get(&log_msg_pool);
}
180028f2:	1ac0      	subs	r0, r0, r3
180028f4:	4770      	bx	lr
180028f6:	bf00      	nop
180028f8:	3018055c 	.word	0x3018055c

180028fc <log_msg_mem_get_used>:

uint32_t log_msg_mem_get_used(void)
{
	return k_mem_slab_num_used_get(&log_msg_pool);
}
180028fc:	4b01      	ldr	r3, [pc, #4]	; (18002904 <log_msg_mem_get_used+0x8>)
180028fe:	6998      	ldr	r0, [r3, #24]
18002900:	4770      	bx	lr
18002902:	bf00      	nop
18002904:	3018055c 	.word	0x3018055c

18002908 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
18002908:	b40e      	push	{r1, r2, r3}
1800290a:	b503      	push	{r0, r1, lr}
1800290c:	ab03      	add	r3, sp, #12
1800290e:	f853 2b04 	ldr.w	r2, [r3], #4
18002912:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
18002914:	4804      	ldr	r0, [pc, #16]	; (18002928 <print_formatted+0x20>)
	va_start(args, fmt);
18002916:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
18002918:	f7fe ff8e 	bl	18001838 <cbvprintf>
	va_end(args);

	return length;
}
1800291c:	b002      	add	sp, #8
1800291e:	f85d eb04 	ldr.w	lr, [sp], #4
18002922:	b003      	add	sp, #12
18002924:	4770      	bx	lr
18002926:	bf00      	nop
18002928:	18008c85 	.word	0x18008c85

1800292c <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
1800292c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
18002930:	461d      	mov	r5, r3
18002932:	9b08      	ldr	r3, [sp, #32]
18002934:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
18002936:	06da      	lsls	r2, r3, #27
{
18002938:	4604      	mov	r4, r0
1800293a:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
1800293c:	d405      	bmi.n	1800294a <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
1800293e:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
18002940:	bf4c      	ite	mi
18002942:	492a      	ldrmi	r1, [pc, #168]	; (180029ec <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
18002944:	492a      	ldrpl	r1, [pc, #168]	; (180029f0 <hexdump_line_print+0xc4>)
18002946:	f7ff ffdf 	bl	18002908 <print_formatted>
{
1800294a:	f04f 0800 	mov.w	r8, #0
	newline_print(output, flags);

	for (int i = 0; i < prefix_offset; i++) {
		print_formatted(output, " ");
1800294e:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 180029f4 <hexdump_line_print+0xc8>
	for (int i = 0; i < prefix_offset; i++) {
18002952:	45a8      	cmp	r8, r5
18002954:	db2a      	blt.n	180029ac <hexdump_line_print+0x80>
	}

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
18002956:	2500      	movs	r5, #0
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
18002958:	f8df 809c 	ldr.w	r8, [pc, #156]	; 180029f8 <hexdump_line_print+0xcc>
			print_formatted(output, "%02x ", data[i]);
1800295c:	f8df 909c 	ldr.w	r9, [pc, #156]	; 180029fc <hexdump_line_print+0xd0>
			print_formatted(output, " ");
18002960:	f8df a090 	ldr.w	sl, [pc, #144]	; 180029f4 <hexdump_line_print+0xc8>
		if (i < length) {
18002964:	42bd      	cmp	r5, r7
18002966:	d22f      	bcs.n	180029c8 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
18002968:	4649      	mov	r1, r9
1800296a:	4620      	mov	r0, r4
1800296c:	5d72      	ldrb	r2, [r6, r5]
1800296e:	f7ff ffcb 	bl	18002908 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
18002972:	3501      	adds	r5, #1
18002974:	2d10      	cmp	r5, #16
18002976:	d120      	bne.n	180029ba <hexdump_line_print+0x8e>
		}
	}

	print_formatted(output, "|");
18002978:	4620      	mov	r0, r4
1800297a:	4921      	ldr	r1, [pc, #132]	; (18002a00 <hexdump_line_print+0xd4>)
1800297c:	f7ff ffc4 	bl	18002908 <print_formatted>

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
18002980:	2500      	movs	r5, #0
			char c = (char)data[i];

			print_formatted(output, "%c",
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
18002982:	f8df 8070 	ldr.w	r8, [pc, #112]	; 180029f4 <hexdump_line_print+0xc8>
			print_formatted(output, "%c",
18002986:	f8df 907c 	ldr.w	r9, [pc, #124]	; 18002a04 <hexdump_line_print+0xd8>
		if (i < length) {
1800298a:	42af      	cmp	r7, r5
1800298c:	d928      	bls.n	180029e0 <hexdump_line_print+0xb4>
			char c = (char)data[i];
1800298e:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
18002990:	4649      	mov	r1, r9
	return (int)((((unsigned)c) >= ' ') &&
18002992:	f1a2 0320 	sub.w	r3, r2, #32
18002996:	2b5f      	cmp	r3, #95	; 0x5f
18002998:	bf28      	it	cs
1800299a:	222e      	movcs	r2, #46	; 0x2e
1800299c:	4620      	mov	r0, r4
1800299e:	f7ff ffb3 	bl	18002908 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
180029a2:	3501      	adds	r5, #1
180029a4:	2d10      	cmp	r5, #16
180029a6:	d114      	bne.n	180029d2 <hexdump_line_print+0xa6>
		}
	}
}
180029a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
180029ac:	4649      	mov	r1, r9
180029ae:	4620      	mov	r0, r4
180029b0:	f7ff ffaa 	bl	18002908 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
180029b4:	f108 0801 	add.w	r8, r8, #1
180029b8:	e7cb      	b.n	18002952 <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
180029ba:	076a      	lsls	r2, r5, #29
180029bc:	d1d2      	bne.n	18002964 <hexdump_line_print+0x38>
			print_formatted(output, " ");
180029be:	4651      	mov	r1, sl
180029c0:	4620      	mov	r0, r4
180029c2:	f7ff ffa1 	bl	18002908 <print_formatted>
180029c6:	e7cd      	b.n	18002964 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
180029c8:	4641      	mov	r1, r8
180029ca:	4620      	mov	r0, r4
180029cc:	f7ff ff9c 	bl	18002908 <print_formatted>
180029d0:	e7cf      	b.n	18002972 <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
180029d2:	076b      	lsls	r3, r5, #29
180029d4:	d1d9      	bne.n	1800298a <hexdump_line_print+0x5e>
			print_formatted(output, " ");
180029d6:	4641      	mov	r1, r8
180029d8:	4620      	mov	r0, r4
180029da:	f7ff ff95 	bl	18002908 <print_formatted>
180029de:	e7d4      	b.n	1800298a <hexdump_line_print+0x5e>
			print_formatted(output, " ");
180029e0:	4641      	mov	r1, r8
180029e2:	4620      	mov	r0, r4
180029e4:	f7ff ff90 	bl	18002908 <print_formatted>
180029e8:	e7db      	b.n	180029a2 <hexdump_line_print+0x76>
180029ea:	bf00      	nop
180029ec:	1800ccbd 	.word	0x1800ccbd
180029f0:	1800c8a9 	.word	0x1800c8a9
180029f4:	1800c790 	.word	0x1800c790
180029f8:	1800c78e 	.word	0x1800c78e
180029fc:	1800c788 	.word	0x1800c788
18002a00:	1800c792 	.word	0x1800c792
18002a04:	1800d27a 	.word	0x1800d27a

18002a08 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
18002a08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
18002a0c:	f011 0602 	ands.w	r6, r1, #2
{
18002a10:	b087      	sub	sp, #28
18002a12:	9205      	str	r2, [sp, #20]
18002a14:	4607      	mov	r7, r0
18002a16:	461a      	mov	r2, r3
18002a18:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
18002a1c:	f9bd 9048 	ldrsh.w	r9, [sp, #72]	; 0x48
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
18002a20:	f001 0a01 	and.w	sl, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
18002a24:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
18002a28:	d006      	beq.n	18002a38 <prefix_print+0x30>
	if (!format) {
18002a2a:	f011 0f44 	tst.w	r1, #68	; 0x44
18002a2e:	d138      	bne.n	18002aa2 <prefix_print+0x9a>
		length = print_formatted(output, "[%08lu] ", timestamp);
18002a30:	4933      	ldr	r1, [pc, #204]	; (18002b00 <prefix_print+0xf8>)
18002a32:	f7ff ff69 	bl	18002908 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
18002a36:	4606      	mov	r6, r0
	if (color) {
18002a38:	f1ba 0f00 	cmp.w	sl, #0
18002a3c:	d00a      	beq.n	18002a54 <prefix_print+0x4c>
		const char *log_color = start && (colors[level] != NULL) ?
18002a3e:	4b31      	ldr	r3, [pc, #196]	; (18002b04 <prefix_print+0xfc>)
		print_formatted(output, "%s", log_color);
18002a40:	4638      	mov	r0, r7
		const char *log_color = start && (colors[level] != NULL) ?
18002a42:	f853 2028 	ldr.w	r2, [r3, r8, lsl #2]
		print_formatted(output, "%s", log_color);
18002a46:	4b30      	ldr	r3, [pc, #192]	; (18002b08 <prefix_print+0x100>)
18002a48:	4930      	ldr	r1, [pc, #192]	; (18002b0c <prefix_print+0x104>)
18002a4a:	2a00      	cmp	r2, #0
18002a4c:	bf08      	it	eq
18002a4e:	461a      	moveq	r2, r3
18002a50:	f7ff ff5a 	bl	18002908 <print_formatted>
	if (level_on) {
18002a54:	b13d      	cbz	r5, 18002a66 <prefix_print+0x5e>
		total += print_formatted(output, "<%s> ", severity[level]);
18002a56:	4b2e      	ldr	r3, [pc, #184]	; (18002b10 <prefix_print+0x108>)
18002a58:	4638      	mov	r0, r7
18002a5a:	f853 2028 	ldr.w	r2, [r3, r8, lsl #2]
18002a5e:	492d      	ldr	r1, [pc, #180]	; (18002b14 <prefix_print+0x10c>)
18002a60:	f7ff ff52 	bl	18002908 <print_formatted>
18002a64:	4605      	mov	r5, r0
	if (source_id >= 0) {
18002a66:	f1b9 0f00 	cmp.w	r9, #0
18002a6a:	db16      	blt.n	18002a9a <prefix_print+0x92>
		total += print_formatted(output,
18002a6c:	9b05      	ldr	r3, [sp, #20]
18002a6e:	2b00      	cmp	r3, #0
18002a70:	d043      	beq.n	18002afa <prefix_print+0xf2>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
18002a72:	2301      	movs	r3, #1
18002a74:	fa03 f808 	lsl.w	r8, r3, r8
		total += print_formatted(output,
18002a78:	4b27      	ldr	r3, [pc, #156]	; (18002b18 <prefix_print+0x110>)
18002a7a:	f018 0f10 	tst.w	r8, #16
18002a7e:	4c27      	ldr	r4, [pc, #156]	; (18002b1c <prefix_print+0x114>)
18002a80:	bf18      	it	ne
18002a82:	461c      	movne	r4, r3
18002a84:	4649      	mov	r1, r9
18002a86:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
18002a8a:	f7ff fe11 	bl	180026b0 <log_source_name_get>
18002a8e:	4621      	mov	r1, r4
18002a90:	4602      	mov	r2, r0
18002a92:	4638      	mov	r0, r7
18002a94:	f7ff ff38 	bl	18002908 <print_formatted>
18002a98:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
18002a9a:	19a8      	adds	r0, r5, r6
18002a9c:	b007      	add	sp, #28
18002a9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
18002aa2:	4b1f      	ldr	r3, [pc, #124]	; (18002b20 <prefix_print+0x118>)
18002aa4:	6819      	ldr	r1, [r3, #0]
18002aa6:	b331      	cbz	r1, 18002af6 <prefix_print+0xee>
		timestamp /= timestamp_div;
18002aa8:	4b1e      	ldr	r3, [pc, #120]	; (18002b24 <prefix_print+0x11c>)
18002aaa:	f44f 6661 	mov.w	r6, #3600	; 0xe10
18002aae:	681b      	ldr	r3, [r3, #0]
		ms = (remainder * 1000U) / freq;
18002ab0:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
		timestamp /= timestamp_div;
18002ab4:	fbb2 f3f3 	udiv	r3, r2, r3
		total_seconds = timestamp / freq;
18002ab8:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
18002abc:	fbb4 f2f6 	udiv	r2, r4, r6
18002ac0:	fb06 4612 	mls	r6, r6, r2, r4
		remainder = timestamp % freq;
18002ac4:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
18002ac8:	fb0b f404 	mul.w	r4, fp, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
18002acc:	fbb4 fef1 	udiv	lr, r4, r1
		mins = seconds / 60U;
18002ad0:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
18002ad4:	fb01 441e 	mls	r4, r1, lr, r4
		mins = seconds / 60U;
18002ad8:	fbb6 f3fc 	udiv	r3, r6, ip
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
18002adc:	fb0b f404 	mul.w	r4, fp, r4
18002ae0:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(output,
18002ae4:	fb0c 6613 	mls	r6, ip, r3, r6
18002ae8:	e9cd e101 	strd	lr, r1, [sp, #4]
18002aec:	9600      	str	r6, [sp, #0]
18002aee:	490e      	ldr	r1, [pc, #56]	; (18002b28 <prefix_print+0x120>)
18002af0:	f7ff ff0a 	bl	18002908 <print_formatted>
18002af4:	e79f      	b.n	18002a36 <prefix_print+0x2e>
		length = 0;
18002af6:	4608      	mov	r0, r1
18002af8:	e79d      	b.n	18002a36 <prefix_print+0x2e>
		total += print_formatted(output,
18002afa:	4c08      	ldr	r4, [pc, #32]	; (18002b1c <prefix_print+0x114>)
18002afc:	e7c2      	b.n	18002a84 <prefix_print+0x7c>
18002afe:	bf00      	nop
18002b00:	1800c7a2 	.word	0x1800c7a2
18002b04:	1800b508 	.word	0x1800b508
18002b08:	1800c794 	.word	0x1800c794
18002b0c:	1800d0a2 	.word	0x1800d0a2
18002b10:	1800b51c 	.word	0x1800b51c
18002b14:	1800c7c7 	.word	0x1800c7c7
18002b18:	1800c79e 	.word	0x1800c79e
18002b1c:	1800c799 	.word	0x1800c799
18002b20:	30180578 	.word	0x30180578
18002b24:	3018057c 	.word	0x3018057c
18002b28:	1800c7ab 	.word	0x1800c7ab

18002b2c <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
18002b2c:	b538      	push	{r3, r4, r5, lr}
18002b2e:	460c      	mov	r4, r1
	if (color) {
18002b30:	07e1      	lsls	r1, r4, #31
{
18002b32:	4605      	mov	r5, r0
	if (color) {
18002b34:	d503      	bpl.n	18002b3e <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
18002b36:	4a08      	ldr	r2, [pc, #32]	; (18002b58 <postfix_print+0x2c>)
18002b38:	4908      	ldr	r1, [pc, #32]	; (18002b5c <postfix_print+0x30>)
18002b3a:	f7ff fee5 	bl	18002908 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
18002b3e:	06e2      	lsls	r2, r4, #27
18002b40:	d408      	bmi.n	18002b54 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
18002b42:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
18002b44:	4628      	mov	r0, r5
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
18002b46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
18002b4a:	bf4c      	ite	mi
18002b4c:	4904      	ldrmi	r1, [pc, #16]	; (18002b60 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
18002b4e:	4905      	ldrpl	r1, [pc, #20]	; (18002b64 <postfix_print+0x38>)
18002b50:	f7ff beda 	b.w	18002908 <print_formatted>
}
18002b54:	bd38      	pop	{r3, r4, r5, pc}
18002b56:	bf00      	nop
18002b58:	1800c794 	.word	0x1800c794
18002b5c:	1800d0a2 	.word	0x1800d0a2
18002b60:	1800ccbd 	.word	0x1800ccbd
18002b64:	1800c8a9 	.word	0x1800c8a9

18002b68 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
18002b68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
18002b6c:	7a8b      	ldrb	r3, [r1, #10]
18002b6e:	4605      	mov	r5, r0
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
18002b70:	f013 0807 	ands.w	r8, r3, #7
{
18002b74:	460e      	mov	r6, r1
18002b76:	4617      	mov	r7, r2
18002b78:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(output, flags, std_msg, timestamp,
18002b7a:	d022      	beq.n	18002bc2 <log_output_msg_process+0x5a>
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
18002b7c:	7a0a      	ldrb	r2, [r1, #8]
	return msg->hdr.ids.source_id;
18002b7e:	8949      	ldrh	r1, [r1, #10]
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
18002b80:	43d2      	mvns	r2, r2
18002b82:	f3c1 1189 	ubfx	r1, r1, #6, #10
18002b86:	f3c3 03c2 	ubfx	r3, r3, #3, #3
18002b8a:	e9cd 8300 	strd	r8, r3, [sp]
18002b8e:	9102      	str	r1, [sp, #8]
18002b90:	68f3      	ldr	r3, [r6, #12]
18002b92:	4639      	mov	r1, r7
18002b94:	f002 0201 	and.w	r2, r2, #1
18002b98:	f7ff ff36 	bl	18002a08 <prefix_print>
18002b9c:	4681      	mov	r9, r0
18002b9e:	7a34      	ldrb	r4, [r6, #8]
18002ba0:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
18002ba2:	f014 0401 	ands.w	r4, r4, #1
18002ba6:	d00e      	beq.n	18002bc6 <log_output_msg_process+0x5e>
		std_print(msg, output);
18002ba8:	4629      	mov	r1, r5
18002baa:	4630      	mov	r0, r6
18002bac:	f005 ff00 	bl	180089b0 <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
18002bb0:	f1b8 0f00 	cmp.w	r8, #0
18002bb4:	d02b      	beq.n	18002c0e <log_output_msg_process+0xa6>
		postfix_print(output, flags, level);
18002bb6:	4642      	mov	r2, r8
18002bb8:	4639      	mov	r1, r7
18002bba:	4628      	mov	r0, r5
18002bbc:	f7ff ffb6 	bl	18002b2c <postfix_print>
18002bc0:	e025      	b.n	18002c0e <log_output_msg_process+0xa6>
			0 : prefix_print(output, flags, std_msg, timestamp,
18002bc2:	46c1      	mov	r9, r8
18002bc4:	e7eb      	b.n	18002b9e <log_output_msg_process+0x36>
	} else if (raw_string) {
18002bc6:	f1b8 0f00 	cmp.w	r8, #0
18002bca:	d126      	bne.n	18002c1a <log_output_msg_process+0xb2>
	size_t offset = 0;
18002bcc:	4627      	mov	r7, r4
		length = output->size;
18002bce:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
18002bd0:	aa06      	add	r2, sp, #24
		length = output->size;
18002bd2:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
18002bd4:	4630      	mov	r0, r6
18002bd6:	463b      	mov	r3, r7
18002bd8:	68a9      	ldr	r1, [r5, #8]
18002bda:	f005 fed5 	bl	18008988 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
18002bde:	9a06      	ldr	r2, [sp, #24]
18002be0:	686b      	ldr	r3, [r5, #4]
18002be2:	601a      	str	r2, [r3, #0]
		if (length != 0) {
18002be4:	b13a      	cbz	r2, 18002bf6 <log_output_msg_process+0x8e>
			eol = (output->buf[length - 1] == '\n');
18002be6:	68ab      	ldr	r3, [r5, #8]
18002be8:	4413      	add	r3, r2
18002bea:	f813 4c01 	ldrb.w	r4, [r3, #-1]
18002bee:	f1a4 030a 	sub.w	r3, r4, #10
18002bf2:	425c      	negs	r4, r3
18002bf4:	415c      	adcs	r4, r3
		log_output_flush(output);
18002bf6:	4628      	mov	r0, r5
18002bf8:	f006 f837 	bl	18008c6a <log_output_flush>
		offset += length;
18002bfc:	9b06      	ldr	r3, [sp, #24]
18002bfe:	441f      	add	r7, r3
	} while (length > 0);
18002c00:	2b00      	cmp	r3, #0
18002c02:	d1e4      	bne.n	18002bce <log_output_msg_process+0x66>
	if (eol) {
18002c04:	b11c      	cbz	r4, 18002c0e <log_output_msg_process+0xa6>
		print_formatted(output, "\r");
18002c06:	4628      	mov	r0, r5
18002c08:	4913      	ldr	r1, [pc, #76]	; (18002c58 <log_output_msg_process+0xf0>)
18002c0a:	f7ff fe7d 	bl	18002908 <print_formatted>
	}

	log_output_flush(output);
18002c0e:	4628      	mov	r0, r5
}
18002c10:	b00a      	add	sp, #40	; 0x28
18002c12:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(output);
18002c16:	f006 b828 	b.w	18008c6a <log_output_flush>
	print_formatted(output, "%s", log_msg_str_get(msg));
18002c1a:	4630      	mov	r0, r6
18002c1c:	f005 feb2 	bl	18008984 <log_msg_str_get>
18002c20:	490e      	ldr	r1, [pc, #56]	; (18002c5c <log_output_msg_process+0xf4>)
18002c22:	4602      	mov	r2, r0
18002c24:	4628      	mov	r0, r5
18002c26:	f7ff fe6f 	bl	18002908 <print_formatted>
		length = sizeof(buf);
18002c2a:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
18002c2e:	aa05      	add	r2, sp, #20
18002c30:	4623      	mov	r3, r4
18002c32:	4630      	mov	r0, r6
18002c34:	a906      	add	r1, sp, #24
		length = sizeof(buf);
18002c36:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
18002c3a:	f005 fea5 	bl	18008988 <log_msg_hexdump_data_get>
		if (length) {
18002c3e:	9a05      	ldr	r2, [sp, #20]
18002c40:	2a00      	cmp	r2, #0
18002c42:	d0b8      	beq.n	18002bb6 <log_output_msg_process+0x4e>
			hexdump_line_print(output, buf, length,
18002c44:	464b      	mov	r3, r9
18002c46:	4628      	mov	r0, r5
18002c48:	9700      	str	r7, [sp, #0]
18002c4a:	a906      	add	r1, sp, #24
18002c4c:	f7ff fe6e 	bl	1800292c <hexdump_line_print>
			offset += length;
18002c50:	9b05      	ldr	r3, [sp, #20]
18002c52:	441c      	add	r4, r3
		length = sizeof(buf);
18002c54:	e7eb      	b.n	18002c2e <log_output_msg_process+0xc6>
18002c56:	bf00      	nop
18002c58:	1800c7cd 	.word	0x1800c7cd
18002c5c:	1800d0a2 	.word	0x1800d0a2

18002c60 <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
18002c60:	f242 730f 	movw	r3, #9999	; 0x270f
{
18002c64:	b573      	push	{r0, r1, r4, r5, r6, lr}
	len = snprintk(buf, sizeof(buf), "%d", cnt);
18002c66:	428b      	cmp	r3, r1
18002c68:	bf28      	it	cs
18002c6a:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
18002c6c:	6805      	ldr	r5, [r0, #0]
{
18002c6e:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
18002c70:	2105      	movs	r1, #5
18002c72:	4668      	mov	r0, sp
18002c74:	4a0d      	ldr	r2, [pc, #52]	; (18002cac <log_output_dropped_process+0x4c>)
18002c76:	f005 fa0c 	bl	18008092 <snprintk>
18002c7a:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
18002c7c:	6863      	ldr	r3, [r4, #4]
18002c7e:	4628      	mov	r0, r5
18002c80:	2204      	movs	r2, #4
18002c82:	685b      	ldr	r3, [r3, #4]
18002c84:	490a      	ldr	r1, [pc, #40]	; (18002cb0 <log_output_dropped_process+0x50>)
18002c86:	f005 fe86 	bl	18008996 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
18002c8a:	6863      	ldr	r3, [r4, #4]
18002c8c:	4632      	mov	r2, r6
18002c8e:	4669      	mov	r1, sp
18002c90:	4628      	mov	r0, r5
18002c92:	685b      	ldr	r3, [r3, #4]
18002c94:	f005 fe7f 	bl	18008996 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
18002c98:	6863      	ldr	r3, [r4, #4]
18002c9a:	2217      	movs	r2, #23
18002c9c:	4628      	mov	r0, r5
18002c9e:	685b      	ldr	r3, [r3, #4]
18002ca0:	4904      	ldr	r1, [pc, #16]	; (18002cb4 <log_output_dropped_process+0x54>)
18002ca2:	f005 fe78 	bl	18008996 <buffer_write>
		     output->control_block->ctx);
}
18002ca6:	b002      	add	sp, #8
18002ca8:	bd70      	pop	{r4, r5, r6, pc}
18002caa:	bf00      	nop
18002cac:	1800d0b9 	.word	0x1800d0b9
18002cb0:	1800c807 	.word	0x1800c807
18002cb4:	1800c7ef 	.word	0x1800c7ef

18002cb8 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
18002cb8:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
18002cba:	2100      	movs	r1, #0
	timestamp_div = 1U;
18002cbc:	4a07      	ldr	r2, [pc, #28]	; (18002cdc <log_output_timestamp_freq_set+0x24>)
{
18002cbe:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
18002cc0:	4c07      	ldr	r4, [pc, #28]	; (18002ce0 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
18002cc2:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
18002cc4:	42a0      	cmp	r0, r4
18002cc6:	d804      	bhi.n	18002cd2 <log_output_timestamp_freq_set+0x1a>
18002cc8:	b101      	cbz	r1, 18002ccc <log_output_timestamp_freq_set+0x14>
18002cca:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
18002ccc:	4b05      	ldr	r3, [pc, #20]	; (18002ce4 <log_output_timestamp_freq_set+0x2c>)
18002cce:	6018      	str	r0, [r3, #0]
}
18002cd0:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
18002cd2:	2101      	movs	r1, #1
		frequency /= 2U;
18002cd4:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
18002cd6:	005b      	lsls	r3, r3, #1
18002cd8:	e7f4      	b.n	18002cc4 <log_output_timestamp_freq_set+0xc>
18002cda:	bf00      	nop
18002cdc:	3018057c 	.word	0x3018057c
18002ce0:	000f4240 	.word	0x000f4240
18002ce4:	30180578 	.word	0x30180578

18002ce8 <severity_lvl_get>:
}


static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
18002ce8:	2300      	movs	r3, #0
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
18002cea:	2804      	cmp	r0, #4
	entry->handler = NULL;
18002cec:	60cb      	str	r3, [r1, #12]
	entry->help  = NULL;
18002cee:	604b      	str	r3, [r1, #4]
					severity_lvls_sorted[idx] : NULL;
18002cf0:	bf98      	it	ls
18002cf2:	4b04      	ldrls	r3, [pc, #16]	; (18002d04 <severity_lvl_get+0x1c>)
	entry->subcmd = &dsub_module_name;
18002cf4:	4a04      	ldr	r2, [pc, #16]	; (18002d08 <severity_lvl_get+0x20>)
					severity_lvls_sorted[idx] : NULL;
18002cf6:	bf98      	it	ls
18002cf8:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
	entry->subcmd = &dsub_module_name;
18002cfc:	608a      	str	r2, [r1, #8]
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
18002cfe:	600b      	str	r3, [r1, #0]
}
18002d00:	4770      	bx	lr
18002d02:	bf00      	nop
18002d04:	1800b570 	.word	0x1800b570
18002d08:	1800b54c 	.word	0x1800b54c

18002d0c <backend_name_get>:
	SHELL_SUBCMD_SET_END
);

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
18002d0c:	2300      	movs	r3, #0
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
18002d0e:	4a08      	ldr	r2, [pc, #32]	; (18002d30 <backend_name_get+0x24>)
	entry->syntax  = NULL;
18002d10:	600b      	str	r3, [r1, #0]
	entry->handler = NULL;
18002d12:	60cb      	str	r3, [r1, #12]
	entry->help  = NULL;
18002d14:	604b      	str	r3, [r1, #4]
	entry->subcmd = &sub_log_backend;
18002d16:	608a      	str	r2, [r1, #8]
	return __log_backends_end - __log_backends_start;
18002d18:	4b06      	ldr	r3, [pc, #24]	; (18002d34 <backend_name_get+0x28>)
18002d1a:	4a07      	ldr	r2, [pc, #28]	; (18002d38 <backend_name_get+0x2c>)
18002d1c:	1ad2      	subs	r2, r2, r3

	if (idx < log_backend_count_get()) {
18002d1e:	ebb0 1f22 	cmp.w	r0, r2, asr #4
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
18002d22:	bf3e      	ittt	cc
18002d24:	eb03 1300 	addcc.w	r3, r3, r0, lsl #4
18002d28:	689b      	ldrcc	r3, [r3, #8]
18002d2a:	600b      	strcc	r3, [r1, #0]
	}
}
18002d2c:	4770      	bx	lr
18002d2e:	bf00      	nop
18002d30:	1800b6c4 	.word	0x1800b6c4
18002d34:	1800b3f8 	.word	0x1800b3f8
18002d38:	1800b408 	.word	0x1800b408

18002d3c <cmd_log_memory_slabs>:
{
18002d3c:	b538      	push	{r3, r4, r5, lr}
18002d3e:	4604      	mov	r4, r0
	slabs_free = log_msg_mem_get_free();
18002d40:	f7ff fdd4 	bl	180028ec <log_msg_mem_get_free>
18002d44:	4605      	mov	r5, r0
	used = log_msg_mem_get_used();
18002d46:	f7ff fdd9 	bl	180028fc <log_msg_mem_get_used>
	shell_print(sh, "Blocks used:\t%d", used);
18002d4a:	2108      	movs	r1, #8
	used = log_msg_mem_get_used();
18002d4c:	4603      	mov	r3, r0
	shell_print(sh, "Blocks used:\t%d", used);
18002d4e:	4a08      	ldr	r2, [pc, #32]	; (18002d70 <cmd_log_memory_slabs+0x34>)
18002d50:	4620      	mov	r0, r4
18002d52:	f006 f931 	bl	18008fb8 <shell_fprintf>
	shell_print(sh, "Blocks free:\t%d", slabs_free);
18002d56:	462b      	mov	r3, r5
18002d58:	4620      	mov	r0, r4
18002d5a:	2108      	movs	r1, #8
18002d5c:	4a05      	ldr	r2, [pc, #20]	; (18002d74 <cmd_log_memory_slabs+0x38>)
18002d5e:	f006 f92b 	bl	18008fb8 <shell_fprintf>
		shell_print(
18002d62:	4620      	mov	r0, r4
18002d64:	2108      	movs	r1, #8
18002d66:	4a04      	ldr	r2, [pc, #16]	; (18002d78 <cmd_log_memory_slabs+0x3c>)
18002d68:	f006 f926 	bl	18008fb8 <shell_fprintf>
}
18002d6c:	2000      	movs	r0, #0
18002d6e:	bd38      	pop	{r3, r4, r5, pc}
18002d70:	1800c80c 	.word	0x1800c80c
18002d74:	1800c81d 	.word	0x1800c81d
18002d78:	1800c82e 	.word	0x1800c82e

18002d7c <cmd_log_backends_list>:
{
18002d7c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
18002d80:	4607      	mov	r7, r0
	for (int i = 0; i < backend_count; i++) {
18002d82:	2500      	movs	r5, #0
18002d84:	4c10      	ldr	r4, [pc, #64]	; (18002dc8 <cmd_log_backends_list+0x4c>)
18002d86:	4b11      	ldr	r3, [pc, #68]	; (18002dcc <cmd_log_backends_list+0x50>)
		shell_fprintf(shell, SHELL_NORMAL,
18002d88:	f8df 8044 	ldr.w	r8, [pc, #68]	; 18002dd0 <cmd_log_backends_list+0x54>
18002d8c:	1b1b      	subs	r3, r3, r4
18002d8e:	f8df 9044 	ldr.w	r9, [pc, #68]	; 18002dd4 <cmd_log_backends_list+0x58>
18002d92:	f8df a044 	ldr.w	sl, [pc, #68]	; 18002dd8 <cmd_log_backends_list+0x5c>
18002d96:	111e      	asrs	r6, r3, #4
	for (int i = 0; i < backend_count; i++) {
18002d98:	42b5      	cmp	r5, r6
18002d9a:	db03      	blt.n	18002da4 <cmd_log_backends_list+0x28>
}
18002d9c:	2000      	movs	r0, #0
18002d9e:	b002      	add	sp, #8
18002da0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			      backend->cb->active ? "enabled" : "disabled",
18002da4:	6863      	ldr	r3, [r4, #4]
		shell_fprintf(shell, SHELL_NORMAL,
18002da6:	4638      	mov	r0, r7
18002da8:	7959      	ldrb	r1, [r3, #5]
18002daa:	791b      	ldrb	r3, [r3, #4]
18002dac:	2900      	cmp	r1, #0
18002dae:	bf14      	ite	ne
18002db0:	4642      	movne	r2, r8
18002db2:	464a      	moveq	r2, r9
18002db4:	2108      	movs	r1, #8
18002db6:	e9cd 2300 	strd	r2, r3, [sp]
18002dba:	68a3      	ldr	r3, [r4, #8]
18002dbc:	4652      	mov	r2, sl
18002dbe:	f006 f8fb 	bl	18008fb8 <shell_fprintf>
	for (int i = 0; i < backend_count; i++) {
18002dc2:	3501      	adds	r5, #1
18002dc4:	3410      	adds	r4, #16
18002dc6:	e7e7      	b.n	18002d98 <cmd_log_backends_list+0x1c>
18002dc8:	1800b3f8 	.word	0x1800b3f8
18002dcc:	1800b408 	.word	0x1800b408
18002dd0:	1800c87a 	.word	0x1800c87a
18002dd4:	1800c882 	.word	0x1800c882
18002dd8:	1800c88b 	.word	0x1800c88b

18002ddc <log_status>:
{
18002ddc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18002de0:	4b24      	ldr	r3, [pc, #144]	; (18002e74 <log_status+0x98>)
18002de2:	4c25      	ldr	r4, [pc, #148]	; (18002e78 <log_status+0x9c>)
18002de4:	4605      	mov	r5, r0
18002de6:	1ae4      	subs	r4, r4, r3
	return backend->cb->active;
18002de8:	684b      	ldr	r3, [r1, #4]
18002dea:	460e      	mov	r6, r1
	if (!log_backend_is_active(backend)) {
18002dec:	795b      	ldrb	r3, [r3, #5]
{
18002dee:	b085      	sub	sp, #20
18002df0:	08e4      	lsrs	r4, r4, #3
	if (!log_backend_is_active(backend)) {
18002df2:	b91b      	cbnz	r3, 18002dfc <log_status+0x20>
		shell_warn(shell, "Logs are halted!");
18002df4:	2103      	movs	r1, #3
18002df6:	4a21      	ldr	r2, [pc, #132]	; (18002e7c <log_status+0xa0>)
18002df8:	f006 f8de 	bl	18008fb8 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
18002dfc:	2108      	movs	r1, #8
18002dfe:	4628      	mov	r0, r5
18002e00:	4b1f      	ldr	r3, [pc, #124]	; (18002e80 <log_status+0xa4>)
18002e02:	4a20      	ldr	r2, [pc, #128]	; (18002e84 <log_status+0xa8>)
18002e04:	f006 f8d8 	bl	18008fb8 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL,
18002e08:	2108      	movs	r1, #8
18002e0a:	4628      	mov	r0, r5
18002e0c:	4a1e      	ldr	r2, [pc, #120]	; (18002e88 <log_status+0xac>)
18002e0e:	f006 f8d3 	bl	18008fb8 <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
18002e12:	f04f 0800 	mov.w	r8, #0
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
18002e16:	f8df a074 	ldr.w	sl, [pc, #116]	; 18002e8c <log_status+0xb0>
18002e1a:	f8df b074 	ldr.w	fp, [pc, #116]	; 18002e90 <log_status+0xb4>
18002e1e:	fa0f f788 	sxth.w	r7, r8
	for (int16_t i = 0U; i < modules_cnt; i++) {
18002e22:	42a7      	cmp	r7, r4
18002e24:	f108 0801 	add.w	r8, r8, #1
18002e28:	d303      	bcc.n	18002e32 <log_status+0x56>
}
18002e2a:	2000      	movs	r0, #0
18002e2c:	b005      	add	sp, #20
18002e2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
18002e32:	463a      	mov	r2, r7
18002e34:	2301      	movs	r3, #1
18002e36:	2100      	movs	r1, #0
18002e38:	4630      	mov	r0, r6
18002e3a:	f7ff fcc9 	bl	180027d0 <log_filter_get>
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
18002e3e:	2300      	movs	r3, #0
18002e40:	463a      	mov	r2, r7
18002e42:	4619      	mov	r1, r3
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
18002e44:	4681      	mov	r9, r0
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
18002e46:	4630      	mov	r0, r6
18002e48:	f7ff fcc2 	bl	180027d0 <log_filter_get>
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
18002e4c:	4639      	mov	r1, r7
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
18002e4e:	9003      	str	r0, [sp, #12]
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
18002e50:	2000      	movs	r0, #0
18002e52:	f7ff fc2d 	bl	180026b0 <log_source_name_get>
18002e56:	9a03      	ldr	r2, [sp, #12]
18002e58:	4603      	mov	r3, r0
18002e5a:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
18002e5e:	2108      	movs	r1, #8
18002e60:	9201      	str	r2, [sp, #4]
18002e62:	f85a 2029 	ldr.w	r2, [sl, r9, lsl #2]
18002e66:	4628      	mov	r0, r5
18002e68:	9200      	str	r2, [sp, #0]
18002e6a:	465a      	mov	r2, fp
18002e6c:	f006 f8a4 	bl	18008fb8 <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
18002e70:	e7d5      	b.n	18002e1e <log_status+0x42>
18002e72:	bf00      	nop
18002e74:	1800b3c0 	.word	0x1800b3c0
18002e78:	1800b3f8 	.word	0x1800b3f8
18002e7c:	1800c8ac 	.word	0x1800c8ac
18002e80:	1800c8be 	.word	0x1800c8be
18002e84:	1800c8ca 	.word	0x1800c8ca
18002e88:	1800c8e8 	.word	0x1800c8e8
18002e8c:	1800b55c 	.word	0x1800b55c
18002e90:	1800c925 	.word	0x1800c925

18002e94 <module_name_get>:
	entry->handler = NULL;
18002e94:	2300      	movs	r3, #0
	entry->subcmd = &dsub_module_name;
18002e96:	4a06      	ldr	r2, [pc, #24]	; (18002eb0 <module_name_get+0x1c>)
{
18002e98:	b510      	push	{r4, lr}
18002e9a:	460c      	mov	r4, r1
	entry->handler = NULL;
18002e9c:	60cb      	str	r3, [r1, #12]
	entry->help  = NULL;
18002e9e:	604b      	str	r3, [r1, #4]
	entry->subcmd = &dsub_module_name;
18002ea0:	608a      	str	r2, [r1, #8]
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
18002ea2:	4601      	mov	r1, r0
18002ea4:	4618      	mov	r0, r3
18002ea6:	f7ff fc03 	bl	180026b0 <log_source_name_get>
18002eaa:	6020      	str	r0, [r4, #0]
}
18002eac:	bd10      	pop	{r4, pc}
18002eae:	bf00      	nop
18002eb0:	1800b54c 	.word	0x1800b54c

18002eb4 <shell_backend_cmd_execute>:
{
18002eb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char const *name = argv[-1];
18002eb8:	f852 ac04 	ldr.w	sl, [r2, #-4]
{
18002ebc:	b085      	sub	sp, #20
18002ebe:	4606      	mov	r6, r0
	size_t slen = strlen(name);
18002ec0:	4650      	mov	r0, sl
{
18002ec2:	4689      	mov	r9, r1
18002ec4:	4690      	mov	r8, r2
18002ec6:	9302      	str	r3, [sp, #8]
	size_t slen = strlen(name);
18002ec8:	f007 f8ed 	bl	1800a0a6 <strlen>
	return __log_backends_end - __log_backends_start;
18002ecc:	4c14      	ldr	r4, [pc, #80]	; (18002f20 <shell_backend_cmd_execute+0x6c>)
18002ece:	4602      	mov	r2, r0
	for (int i = 0; i < log_backend_count_get(); i++) {
18002ed0:	2700      	movs	r7, #0
18002ed2:	46a3      	mov	fp, r4
18002ed4:	4913      	ldr	r1, [pc, #76]	; (18002f24 <shell_backend_cmd_execute+0x70>)
18002ed6:	1b09      	subs	r1, r1, r4
18002ed8:	110b      	asrs	r3, r1, #4
18002eda:	9301      	str	r3, [sp, #4]
18002edc:	9b01      	ldr	r3, [sp, #4]
18002ede:	429f      	cmp	r7, r3
18002ee0:	db08      	blt.n	18002ef4 <shell_backend_cmd_execute+0x40>
		shell_error(shell, "Invalid backend: %s", name);
18002ee2:	4653      	mov	r3, sl
18002ee4:	2101      	movs	r1, #1
18002ee6:	4630      	mov	r0, r6
18002ee8:	4a0f      	ldr	r2, [pc, #60]	; (18002f28 <shell_backend_cmd_execute+0x74>)
18002eea:	f006 f865 	bl	18008fb8 <shell_fprintf>
		return -ENOEXEC;
18002eee:	f06f 0507 	mvn.w	r5, #7
18002ef2:	e00f      	b.n	18002f14 <shell_backend_cmd_execute+0x60>
		if (strncmp(name, backend->name, slen) == 0) {
18002ef4:	68a1      	ldr	r1, [r4, #8]
18002ef6:	4650      	mov	r0, sl
18002ef8:	9203      	str	r2, [sp, #12]
18002efa:	f007 f8f0 	bl	1800a0de <strncmp>
18002efe:	3410      	adds	r4, #16
18002f00:	4605      	mov	r5, r0
18002f02:	9a03      	ldr	r2, [sp, #12]
18002f04:	b950      	cbnz	r0, 18002f1c <shell_backend_cmd_execute+0x68>
		func(shell, backend, argc, argv);
18002f06:	4643      	mov	r3, r8
18002f08:	464a      	mov	r2, r9
18002f0a:	4630      	mov	r0, r6
18002f0c:	9c02      	ldr	r4, [sp, #8]
18002f0e:	eb0b 1107 	add.w	r1, fp, r7, lsl #4
18002f12:	47a0      	blx	r4
}
18002f14:	4628      	mov	r0, r5
18002f16:	b005      	add	sp, #20
18002f18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (int i = 0; i < log_backend_count_get(); i++) {
18002f1c:	3701      	adds	r7, #1
18002f1e:	e7dd      	b.n	18002edc <shell_backend_cmd_execute+0x28>
18002f20:	1800b3f8 	.word	0x1800b3f8
18002f24:	1800b408 	.word	0x1800b408
18002f28:	1800c939 	.word	0x1800c939

18002f2c <cmd_log_backend_status>:
{
18002f2c:	b508      	push	{r3, lr}
	shell_backend_cmd_execute(shell, argc, argv, log_status);
18002f2e:	4b02      	ldr	r3, [pc, #8]	; (18002f38 <cmd_log_backend_status+0xc>)
18002f30:	f7ff ffc0 	bl	18002eb4 <shell_backend_cmd_execute>
}
18002f34:	2000      	movs	r0, #0
18002f36:	bd08      	pop	{r3, pc}
18002f38:	18002ddd 	.word	0x18002ddd

18002f3c <cmd_log_backend_halt>:
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
18002f3c:	4b01      	ldr	r3, [pc, #4]	; (18002f44 <cmd_log_backend_halt+0x8>)
18002f3e:	f7ff bfb9 	b.w	18002eb4 <shell_backend_cmd_execute>
18002f42:	bf00      	nop
18002f44:	18008cb3 	.word	0x18008cb3

18002f48 <cmd_log_backend_go>:
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
18002f48:	4b01      	ldr	r3, [pc, #4]	; (18002f50 <cmd_log_backend_go+0x8>)
18002f4a:	f7ff bfb3 	b.w	18002eb4 <shell_backend_cmd_execute>
18002f4e:	bf00      	nop
18002f50:	18008cbb 	.word	0x18008cbb

18002f54 <cmd_log_backend_enable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
18002f54:	4b01      	ldr	r3, [pc, #4]	; (18002f5c <cmd_log_backend_enable+0x8>)
18002f56:	f7ff bfad 	b.w	18002eb4 <shell_backend_cmd_execute>
18002f5a:	bf00      	nop
18002f5c:	1800305d 	.word	0x1800305d

18002f60 <cmd_log_backend_disable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
18002f60:	4b01      	ldr	r3, [pc, #4]	; (18002f68 <cmd_log_backend_disable+0x8>)
18002f62:	f7ff bfa7 	b.w	18002eb4 <shell_backend_cmd_execute>
18002f66:	bf00      	nop
18002f68:	18008d07 	.word	0x18008d07

18002f6c <shell_state_precheck>:
{
18002f6c:	b510      	push	{r4, lr}
	if (shell->log_backend->control_block->state
18002f6e:	69c3      	ldr	r3, [r0, #28]
18002f70:	68db      	ldr	r3, [r3, #12]
18002f72:	791c      	ldrb	r4, [r3, #4]
18002f74:	b92c      	cbnz	r4, 18002f82 <shell_state_precheck+0x16>
		shell_error(shell, "Shell log backend not initialized.");
18002f76:	2101      	movs	r1, #1
18002f78:	4a03      	ldr	r2, [pc, #12]	; (18002f88 <shell_state_precheck+0x1c>)
18002f7a:	f006 f81d 	bl	18008fb8 <shell_fprintf>
18002f7e:	4620      	mov	r0, r4
}
18002f80:	bd10      	pop	{r4, pc}
	return true;
18002f82:	2001      	movs	r0, #1
18002f84:	e7fc      	b.n	18002f80 <shell_state_precheck+0x14>
18002f86:	bf00      	nop
18002f88:	1800c94e 	.word	0x1800c94e

18002f8c <filters_set>:
{
18002f8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18002f90:	461f      	mov	r7, r3
18002f92:	4e2c      	ldr	r6, [pc, #176]	; (18003044 <filters_set+0xb8>)
18002f94:	4b2c      	ldr	r3, [pc, #176]	; (18003048 <filters_set+0xbc>)
	int cnt = all ? z_log_sources_count() : argc;
18002f96:	1e15      	subs	r5, r2, #0
18002f98:	eba6 0603 	sub.w	r6, r6, r3
18002f9c:	ea4f 06d6 	mov.w	r6, r6, lsr #3
18002fa0:	bf14      	ite	ne
18002fa2:	462b      	movne	r3, r5
18002fa4:	4633      	moveq	r3, r6
{
18002fa6:	b085      	sub	sp, #20
	int cnt = all ? z_log_sources_count() : argc;
18002fa8:	9302      	str	r3, [sp, #8]
	if (!backend->cb->active) {
18002faa:	684b      	ldr	r3, [r1, #4]
{
18002fac:	4680      	mov	r8, r0
	if (!backend->cb->active) {
18002fae:	795b      	ldrb	r3, [r3, #5]
{
18002fb0:	4689      	mov	r9, r1
	if (!backend->cb->active) {
18002fb2:	b91b      	cbnz	r3, 18002fbc <filters_set+0x30>
		shell_warn(shell, "Backend not active.");
18002fb4:	2103      	movs	r1, #3
18002fb6:	4a25      	ldr	r2, [pc, #148]	; (1800304c <filters_set+0xc0>)
18002fb8:	f005 fffe 	bl	18008fb8 <shell_fprintf>
	for (i = 0U; i < modules_cnt; i++) {
18002fbc:	2400      	movs	r4, #0
				shell_warn(shell, "%s: level set to %s.",
18002fbe:	f8df a090 	ldr.w	sl, [pc, #144]	; 18003050 <filters_set+0xc4>
	for (i = 0; i < cnt; i++) {
18002fc2:	9b02      	ldr	r3, [sp, #8]
18002fc4:	429c      	cmp	r4, r3
18002fc6:	db02      	blt.n	18002fce <filters_set+0x42>
}
18002fc8:	b005      	add	sp, #20
18002fca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		id = all ? i : module_id_get(argv[i]);
18002fce:	b3bd      	cbz	r5, 18003040 <filters_set+0xb4>
	for (i = 0U; i < modules_cnt; i++) {
18002fd0:	2300      	movs	r3, #0
		id = all ? i : module_id_get(argv[i]);
18002fd2:	f857 b024 	ldr.w	fp, [r7, r4, lsl #2]
	for (i = 0U; i < modules_cnt; i++) {
18002fd6:	429e      	cmp	r6, r3
18002fd8:	d107      	bne.n	18002fea <filters_set+0x5e>
			shell_error(shell, "%s: unknown source name.", argv[i]);
18002fda:	2101      	movs	r1, #1
18002fdc:	4640      	mov	r0, r8
18002fde:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
18002fe2:	4a1c      	ldr	r2, [pc, #112]	; (18003054 <filters_set+0xc8>)
18002fe4:	f005 ffe8 	bl	18008fb8 <shell_fprintf>
18002fe8:	e023      	b.n	18003032 <filters_set+0xa6>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
18002fea:	4619      	mov	r1, r3
18002fec:	2000      	movs	r0, #0
18002fee:	9303      	str	r3, [sp, #12]
18002ff0:	f7ff fb5e 	bl	180026b0 <log_source_name_get>
		if (strncmp(tmp_name, name, 64) == 0) {
18002ff4:	2240      	movs	r2, #64	; 0x40
18002ff6:	4659      	mov	r1, fp
18002ff8:	f007 f871 	bl	1800a0de <strncmp>
18002ffc:	9b03      	ldr	r3, [sp, #12]
18002ffe:	b9d0      	cbnz	r0, 18003036 <filters_set+0xaa>
			return i;
18003000:	461a      	mov	r2, r3
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
18003002:	2100      	movs	r1, #0
18003004:	9b0e      	ldr	r3, [sp, #56]	; 0x38
18003006:	4648      	mov	r0, r9
18003008:	b212      	sxth	r2, r2
1800300a:	f7ff fb5f 	bl	180026cc <z_impl_log_filter_set>
			if (set_lvl != level) {
1800300e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
18003010:	4683      	mov	fp, r0
18003012:	4283      	cmp	r3, r0
18003014:	d00d      	beq.n	18003032 <filters_set+0xa6>
						CONFIG_LOG_DOMAIN_ID, i) :
18003016:	b985      	cbnz	r5, 1800303a <filters_set+0xae>
					log_source_name_get(
18003018:	4621      	mov	r1, r4
1800301a:	4628      	mov	r0, r5
1800301c:	f7ff fb48 	bl	180026b0 <log_source_name_get>
18003020:	4603      	mov	r3, r0
				shell_warn(shell, "%s: level set to %s.",
18003022:	f85a 202b 	ldr.w	r2, [sl, fp, lsl #2]
18003026:	2103      	movs	r1, #3
18003028:	9200      	str	r2, [sp, #0]
1800302a:	4640      	mov	r0, r8
1800302c:	4a0a      	ldr	r2, [pc, #40]	; (18003058 <filters_set+0xcc>)
1800302e:	f005 ffc3 	bl	18008fb8 <shell_fprintf>
	for (i = 0; i < cnt; i++) {
18003032:	3401      	adds	r4, #1
18003034:	e7c5      	b.n	18002fc2 <filters_set+0x36>
	for (i = 0U; i < modules_cnt; i++) {
18003036:	3301      	adds	r3, #1
18003038:	e7cd      	b.n	18002fd6 <filters_set+0x4a>
						CONFIG_LOG_DOMAIN_ID, i) :
1800303a:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
1800303e:	e7f0      	b.n	18003022 <filters_set+0x96>
18003040:	4622      	mov	r2, r4
18003042:	e7de      	b.n	18003002 <filters_set+0x76>
18003044:	1800b3f8 	.word	0x1800b3f8
18003048:	1800b3c0 	.word	0x1800b3c0
1800304c:	1800c972 	.word	0x1800c972
18003050:	1800b55c 	.word	0x1800b55c
18003054:	1800c99d 	.word	0x1800c99d
18003058:	1800c987 	.word	0x1800c987

1800305c <log_enable>:
{
1800305c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
18003060:	4606      	mov	r6, r0
18003062:	4688      	mov	r8, r1
18003064:	4691      	mov	r9, r2
18003066:	461d      	mov	r5, r3
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
18003068:	2700      	movs	r7, #0
	severity_level = severity_level_get(argv[1]);
1800306a:	f8d3 b004 	ldr.w	fp, [r3, #4]
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
1800306e:	f8df a044 	ldr.w	sl, [pc, #68]	; 180030b4 <log_enable+0x58>
		if (strncmp(str, severity_lvls[i], 4) == 0) {
18003072:	2204      	movs	r2, #4
18003074:	4658      	mov	r0, fp
18003076:	f85a 1b04 	ldr.w	r1, [sl], #4
1800307a:	f007 f830 	bl	1800a0de <strncmp>
1800307e:	4604      	mov	r4, r0
18003080:	b170      	cbz	r0, 180030a0 <log_enable+0x44>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
18003082:	3701      	adds	r7, #1
18003084:	2f05      	cmp	r7, #5
18003086:	d1f4      	bne.n	18003072 <log_enable+0x16>
		shell_error(shell, "Invalid severity: %s", argv[1]);
18003088:	2101      	movs	r1, #1
1800308a:	4630      	mov	r0, r6
1800308c:	686b      	ldr	r3, [r5, #4]
1800308e:	4a0a      	ldr	r2, [pc, #40]	; (180030b8 <log_enable+0x5c>)
18003090:	f005 ff92 	bl	18008fb8 <shell_fprintf>
18003094:	f06f 0407 	mvn.w	r4, #7
}
18003098:	4620      	mov	r0, r4
1800309a:	b003      	add	sp, #12
1800309c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
180030a0:	4641      	mov	r1, r8
180030a2:	4630      	mov	r0, r6
180030a4:	9700      	str	r7, [sp, #0]
180030a6:	f105 0308 	add.w	r3, r5, #8
180030aa:	f1a9 0202 	sub.w	r2, r9, #2
180030ae:	f7ff ff6d 	bl	18002f8c <filters_set>
	return 0;
180030b2:	e7f1      	b.n	18003098 <log_enable+0x3c>
180030b4:	1800b55c 	.word	0x1800b55c
180030b8:	1800c9b7 	.word	0x1800c9b7

180030bc <cmd_kernel_version>:
#include <drivers/timer/system_timer.h>
#include <kernel.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
180030bc:	b513      	push	{r0, r1, r4, lr}
180030be:	4604      	mov	r4, r0
	uint32_t version = sys_kernel_version_get();
180030c0:	f003 fec4 	bl	18006e4c <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
180030c4:	f3c0 2307 	ubfx	r3, r0, #8, #8
180030c8:	9301      	str	r3, [sp, #4]
180030ca:	f3c0 4307 	ubfx	r3, r0, #16, #8
180030ce:	9300      	str	r3, [sp, #0]
180030d0:	2108      	movs	r1, #8
180030d2:	0e03      	lsrs	r3, r0, #24
180030d4:	4a03      	ldr	r2, [pc, #12]	; (180030e4 <cmd_kernel_version+0x28>)
180030d6:	4620      	mov	r0, r4
180030d8:	f005 ff6e 	bl	18008fb8 <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
180030dc:	2000      	movs	r0, #0
180030de:	b002      	add	sp, #8
180030e0:	bd10      	pop	{r4, pc}
180030e2:	bf00      	nop
180030e4:	1800cb72 	.word	0x1800cb72

180030e8 <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
180030e8:	b510      	push	{r4, lr}
180030ea:	4604      	mov	r4, r0
	return z_impl_k_uptime_ticks();
180030ec:	f007 fe32 	bl	1800ad54 <z_impl_k_uptime_ticks>
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
180030f0:	220a      	movs	r2, #10
180030f2:	2300      	movs	r3, #0
180030f4:	f7fe f91c 	bl	18001330 <__aeabi_uldivmod>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
180030f8:	2108      	movs	r1, #8
180030fa:	4603      	mov	r3, r0
180030fc:	4a02      	ldr	r2, [pc, #8]	; (18003108 <cmd_kernel_uptime+0x20>)
180030fe:	4620      	mov	r0, r4
18003100:	f005 ff5a 	bl	18008fb8 <shell_fprintf>
	return 0;
}
18003104:	2000      	movs	r0, #0
18003106:	bd10      	pop	{r4, pc}
18003108:	1800cb8b 	.word	0x1800cb8b

1800310c <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *shell,
			      size_t argc, char **argv)
{
1800310c:	b510      	push	{r4, lr}
1800310e:	4604      	mov	r4, r0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Scheduler: %u since last call", sys_clock_elapsed());
18003110:	f002 fdc4 	bl	18005c9c <sys_clock_elapsed>
18003114:	2108      	movs	r1, #8
18003116:	4603      	mov	r3, r0
18003118:	4a07      	ldr	r2, [pc, #28]	; (18003138 <cmd_kernel_threads+0x2c>)
1800311a:	4620      	mov	r0, r4
1800311c:	f005 ff4c 	bl	18008fb8 <shell_fprintf>
	shell_print(shell, "Threads:");
18003120:	4620      	mov	r0, r4
18003122:	4a06      	ldr	r2, [pc, #24]	; (1800313c <cmd_kernel_threads+0x30>)
18003124:	2108      	movs	r1, #8
18003126:	f005 ff47 	bl	18008fb8 <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)shell);
1800312a:	4621      	mov	r1, r4
1800312c:	4804      	ldr	r0, [pc, #16]	; (18003140 <cmd_kernel_threads+0x34>)
1800312e:	f003 fd33 	bl	18006b98 <k_thread_foreach>
	return 0;
}
18003132:	2000      	movs	r0, #0
18003134:	bd10      	pop	{r4, pc}
18003136:	bf00      	nop
18003138:	1800cb9a 	.word	0x1800cb9a
1800313c:	1800cbb9 	.word	0x1800cbb9
18003140:	180031a1 	.word	0x180031a1

18003144 <cmd_kernel_stacks>:
extern K_KERNEL_STACK_ARRAY_DEFINE(z_interrupt_stacks, CONFIG_MP_NUM_CPUS,
				   CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *shell,
			     size_t argc, char **argv)
{
18003144:	b530      	push	{r4, r5, lr}
	uint8_t *buf;
	size_t size, unused;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	k_thread_foreach(shell_stack_dump, (void *)shell);
18003146:	4601      	mov	r1, r0
{
18003148:	4604      	mov	r4, r0
1800314a:	b087      	sub	sp, #28
	k_thread_foreach(shell_stack_dump, (void *)shell);
1800314c:	4811      	ldr	r0, [pc, #68]	; (18003194 <cmd_kernel_stacks+0x50>)
1800314e:	f003 fd23 	bl	18006b98 <k_thread_foreach>
	 */
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
		buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);

		unused = 0;
18003152:	2300      	movs	r3, #0
18003154:	4a10      	ldr	r2, [pc, #64]	; (18003198 <cmd_kernel_stacks+0x54>)
		for (size_t i = 0; i < size; i++) {
			if (buf[i] == 0xAAU) {
18003156:	f812 1b01 	ldrb.w	r1, [r2], #1
1800315a:	29aa      	cmp	r1, #170	; 0xaa
1800315c:	d103      	bne.n	18003166 <cmd_kernel_stacks+0x22>
				unused++;
1800315e:	3301      	adds	r3, #1
		for (size_t i = 0; i < size; i++) {
18003160:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
18003164:	d1f7      	bne.n	18003156 <cmd_kernel_stacks+0x12>
			} else {
				break;
			}
		}

		shell_print(shell,
18003166:	2264      	movs	r2, #100	; 0x64
18003168:	f5c3 6100 	rsb	r1, r3, #2048	; 0x800
1800316c:	434a      	muls	r2, r1
1800316e:	0ad2      	lsrs	r2, r2, #11
18003170:	2500      	movs	r5, #0
18003172:	9205      	str	r2, [sp, #20]
18003174:	f44f 6200 	mov.w	r2, #2048	; 0x800
18003178:	4620      	mov	r0, r4
1800317a:	e9cd 1203 	strd	r1, r2, [sp, #12]
1800317e:	e9cd 2301 	strd	r2, r3, [sp, #4]
18003182:	2108      	movs	r1, #8
18003184:	4b04      	ldr	r3, [pc, #16]	; (18003198 <cmd_kernel_stacks+0x54>)
18003186:	4a05      	ldr	r2, [pc, #20]	; (1800319c <cmd_kernel_stacks+0x58>)
18003188:	9500      	str	r5, [sp, #0]
1800318a:	f005 ff15 	bl	18008fb8 <shell_fprintf>
			      size - unused, size,
			      ((size - unused) * 100U) / size);
	}

	return 0;
}
1800318e:	4628      	mov	r0, r5
18003190:	b007      	add	sp, #28
18003192:	bd30      	pop	{r4, r5, pc}
18003194:	18003281 	.word	0x18003281
18003198:	30182298 	.word	0x30182298
1800319c:	1800cbc3 	.word	0x1800cbc3

180031a0 <shell_tdata_dump>:
{
180031a0:	b5f0      	push	{r4, r5, r6, r7, lr}
180031a2:	b087      	sub	sp, #28
180031a4:	4604      	mov	r4, r0
180031a6:	460d      	mov	r5, r1
	size_t size = thread->stack_info.size;
180031a8:	f8d0 70a0 	ldr.w	r7, [r0, #160]	; 0xa0
	tname = k_thread_name_get(thread);
180031ac:	f007 fc55 	bl	1800aa5a <k_thread_name_get>
180031b0:	4606      	mov	r6, r0
	return z_impl_z_current_get();
180031b2:	f004 faf1 	bl	18007798 <z_impl_z_current_get>
	shell_print(shell, "%s%p %-10s",
180031b6:	4b23      	ldr	r3, [pc, #140]	; (18003244 <shell_tdata_dump+0xa4>)
180031b8:	4a23      	ldr	r2, [pc, #140]	; (18003248 <shell_tdata_dump+0xa8>)
180031ba:	2e00      	cmp	r6, #0
180031bc:	bf08      	it	eq
180031be:	461e      	moveq	r6, r3
180031c0:	4b22      	ldr	r3, [pc, #136]	; (1800324c <shell_tdata_dump+0xac>)
180031c2:	2108      	movs	r1, #8
180031c4:	4284      	cmp	r4, r0
180031c6:	bf18      	it	ne
180031c8:	4613      	movne	r3, r2
180031ca:	e9cd 4600 	strd	r4, r6, [sp]
180031ce:	4628      	mov	r0, r5
180031d0:	4a1f      	ldr	r2, [pc, #124]	; (18003250 <shell_tdata_dump+0xb0>)
180031d2:	f005 fef1 	bl	18008fb8 <shell_fprintf>
	shell_print(shell, "\toptions: 0x%x, priority: %d timeout: %" PRId64,
180031d6:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
180031da:	e9cd 2302 	strd	r2, r3, [sp, #8]
180031de:	f994 300e 	ldrsb.w	r3, [r4, #14]
180031e2:	2108      	movs	r1, #8
180031e4:	4628      	mov	r0, r5
180031e6:	4a1b      	ldr	r2, [pc, #108]	; (18003254 <shell_tdata_dump+0xb4>)
180031e8:	9300      	str	r3, [sp, #0]
180031ea:	7b23      	ldrb	r3, [r4, #12]
180031ec:	f005 fee4 	bl	18008fb8 <shell_fprintf>
	shell_print(shell, "\tstate: %s, entry: %p", k_thread_state_str(thread),
180031f0:	4620      	mov	r0, r4
180031f2:	f003 fd19 	bl	18006c28 <k_thread_state_str>
180031f6:	6e62      	ldr	r2, [r4, #100]	; 0x64
180031f8:	4603      	mov	r3, r0
180031fa:	9200      	str	r2, [sp, #0]
180031fc:	2108      	movs	r1, #8
180031fe:	4628      	mov	r0, r5
18003200:	4a15      	ldr	r2, [pc, #84]	; (18003258 <shell_tdata_dump+0xb8>)
18003202:	f005 fed9 	bl	18008fb8 <shell_fprintf>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
18003206:	4620      	mov	r0, r4
18003208:	a905      	add	r1, sp, #20
1800320a:	f007 fc2a 	bl	1800aa62 <z_impl_k_thread_stack_space_get>
	if (ret) {
1800320e:	4603      	mov	r3, r0
18003210:	b130      	cbz	r0, 18003220 <shell_tdata_dump+0x80>
		shell_print(shell,
18003212:	2108      	movs	r1, #8
18003214:	4628      	mov	r0, r5
18003216:	4a11      	ldr	r2, [pc, #68]	; (1800325c <shell_tdata_dump+0xbc>)
18003218:	f005 fece 	bl	18008fb8 <shell_fprintf>
}
1800321c:	b007      	add	sp, #28
1800321e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pcnt = ((size - unused) * 100U) / size;
18003220:	2364      	movs	r3, #100	; 0x64
18003222:	9a05      	ldr	r2, [sp, #20]
		shell_print(shell,
18003224:	4628      	mov	r0, r5
		pcnt = ((size - unused) * 100U) / size;
18003226:	1ab9      	subs	r1, r7, r2
18003228:	434b      	muls	r3, r1
1800322a:	fbb3 f3f7 	udiv	r3, r3, r7
		shell_print(shell,
1800322e:	e9cd 2100 	strd	r2, r1, [sp]
18003232:	e9cd 7302 	strd	r7, r3, [sp, #8]
18003236:	2108      	movs	r1, #8
18003238:	463b      	mov	r3, r7
1800323a:	4a09      	ldr	r2, [pc, #36]	; (18003260 <shell_tdata_dump+0xc0>)
1800323c:	f005 febc 	bl	18008fb8 <shell_fprintf>
}
18003240:	e7ec      	b.n	1800321c <shell_tdata_dump+0x7c>
18003242:	bf00      	nop
18003244:	1800cc09 	.word	0x1800cc09
18003248:	1800c790 	.word	0x1800c790
1800324c:	1800dc18 	.word	0x1800dc18
18003250:	1800cc0c 	.word	0x1800cc0c
18003254:	1800cc18 	.word	0x1800cc18
18003258:	1800cc44 	.word	0x1800cc44
1800325c:	1800cc5b 	.word	0x1800cc5b
18003260:	1800cc88 	.word	0x1800cc88

18003264 <cmd_kernel_cycles>:
{
18003264:	b510      	push	{r4, lr}
18003266:	4604      	mov	r4, r0
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
18003268:	f002 fd34 	bl	18005cd4 <sys_clock_cycle_get_32>
	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
1800326c:	2108      	movs	r1, #8
1800326e:	4603      	mov	r3, r0
18003270:	4a02      	ldr	r2, [pc, #8]	; (1800327c <cmd_kernel_cycles+0x18>)
18003272:	4620      	mov	r0, r4
18003274:	f005 fea0 	bl	18008fb8 <shell_fprintf>
}
18003278:	2000      	movs	r0, #0
1800327a:	bd10      	pop	{r4, pc}
1800327c:	1800ccbf 	.word	0x1800ccbf

18003280 <shell_stack_dump>:
{
18003280:	b5f0      	push	{r4, r5, r6, r7, lr}
18003282:	4604      	mov	r4, r0
18003284:	460d      	mov	r5, r1
	size_t size = thread->stack_info.size;
18003286:	f8d0 60a0 	ldr.w	r6, [r0, #160]	; 0xa0
{
1800328a:	b089      	sub	sp, #36	; 0x24
1800328c:	a907      	add	r1, sp, #28
1800328e:	f007 fbe8 	bl	1800aa62 <z_impl_k_thread_stack_space_get>
	if (ret) {
18003292:	4603      	mov	r3, r0
18003294:	b130      	cbz	r0, 180032a4 <shell_stack_dump+0x24>
		shell_print(shell,
18003296:	2108      	movs	r1, #8
18003298:	4628      	mov	r0, r5
1800329a:	4a0f      	ldr	r2, [pc, #60]	; (180032d8 <shell_stack_dump+0x58>)
1800329c:	f005 fe8c 	bl	18008fb8 <shell_fprintf>
}
180032a0:	b009      	add	sp, #36	; 0x24
180032a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	tname = k_thread_name_get((struct k_thread *)thread);
180032a4:	4620      	mov	r0, r4
180032a6:	f007 fbd8 	bl	1800aa5a <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
180032aa:	2364      	movs	r3, #100	; 0x64
180032ac:	9907      	ldr	r1, [sp, #28]
	shell_print((const struct shell *)user_data,
180032ae:	4a0b      	ldr	r2, [pc, #44]	; (180032dc <shell_stack_dump+0x5c>)
	pcnt = ((size - unused) * 100U) / size;
180032b0:	1a77      	subs	r7, r6, r1
180032b2:	437b      	muls	r3, r7
	shell_print((const struct shell *)user_data,
180032b4:	2800      	cmp	r0, #0
180032b6:	bf18      	it	ne
180032b8:	4602      	movne	r2, r0
	pcnt = ((size - unused) * 100U) / size;
180032ba:	fbb3 f3f6 	udiv	r3, r3, r6
	shell_print((const struct shell *)user_data,
180032be:	e9cd 1702 	strd	r1, r7, [sp, #8]
180032c2:	e9cd 6304 	strd	r6, r3, [sp, #16]
180032c6:	e9cd 2600 	strd	r2, r6, [sp]
180032ca:	4623      	mov	r3, r4
180032cc:	2108      	movs	r1, #8
180032ce:	4628      	mov	r0, r5
180032d0:	4a03      	ldr	r2, [pc, #12]	; (180032e0 <shell_stack_dump+0x60>)
180032d2:	f005 fe71 	bl	18008fb8 <shell_fprintf>
180032d6:	e7e3      	b.n	180032a0 <shell_stack_dump+0x20>
180032d8:	1800cc5b 	.word	0x1800cc5b
180032dc:	1800cc09 	.word	0x1800cc09
180032e0:	1800ccd5 	.word	0x1800ccd5

180032e4 <cmd_devmem>:
{
	mem_addr_t phys_addr, addr;
	uint32_t value = 0;
	uint8_t width;

	if (argc < 2 || argc > 4) {
180032e4:	1e8b      	subs	r3, r1, #2
180032e6:	2b02      	cmp	r3, #2
{
180032e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
180032ec:	4607      	mov	r7, r0
180032ee:	4688      	mov	r8, r1
180032f0:	4614      	mov	r4, r2
	if (argc < 2 || argc > 4) {
180032f2:	d833      	bhi.n	1800335c <cmd_devmem+0x78>
		return -EINVAL;
	}

	phys_addr = strtoul(argv[1], NULL, 16);
180032f4:	2210      	movs	r2, #16
180032f6:	2100      	movs	r1, #0
180032f8:	6860      	ldr	r0, [r4, #4]
180032fa:	f006 fe11 	bl	18009f20 <strtoul>
	shell_print(sh, "Mapped 0x%lx to 0x%lx\n", phys_addr, addr);
#else
	addr = phys_addr;
#endif /* defined(CONFIG_MMU) || defined(CONFIG_PCIE) */

	if (argc < 3) {
180032fe:	f1b8 0f02 	cmp.w	r8, #2
	phys_addr = strtoul(argv[1], NULL, 16);
18003302:	4606      	mov	r6, r0
	if (argc < 3) {
18003304:	d01e      	beq.n	18003344 <cmd_devmem+0x60>
		width = 32;
	} else {
		width = strtoul(argv[2], NULL, 10);
18003306:	220a      	movs	r2, #10
18003308:	2100      	movs	r1, #0
1800330a:	68a0      	ldr	r0, [r4, #8]
1800330c:	f006 fe08 	bl	18009f20 <strtoul>
18003310:	b2c5      	uxtb	r5, r0
	}

	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
18003312:	462b      	mov	r3, r5
18003314:	2108      	movs	r1, #8
18003316:	4638      	mov	r0, r7
18003318:	4a1f      	ldr	r2, [pc, #124]	; (18003398 <cmd_devmem+0xb4>)
1800331a:	f005 fe4d 	bl	18008fb8 <shell_fprintf>

	if (argc <= 3) {
1800331e:	f1b8 0f04 	cmp.w	r8, #4
18003322:	d01e      	beq.n	18003362 <cmd_devmem+0x7e>
	switch (width) {
18003324:	2d10      	cmp	r5, #16
18003326:	d00f      	beq.n	18003348 <cmd_devmem+0x64>
18003328:	2d20      	cmp	r5, #32
1800332a:	d010      	beq.n	1800334e <cmd_devmem+0x6a>
1800332c:	2d08      	cmp	r5, #8
1800332e:	d110      	bne.n	18003352 <cmd_devmem+0x6e>
extern "C" {
#endif

static ALWAYS_INLINE uint8_t sys_read8(mem_addr_t addr)
{
	return *(volatile uint8_t *)addr;
18003330:	7833      	ldrb	r3, [r6, #0]
18003332:	b2db      	uxtb	r3, r3
		shell_fprintf(sh, SHELL_NORMAL, "Read value 0x%x\n", value);
18003334:	2108      	movs	r1, #8
18003336:	4638      	mov	r0, r7
18003338:	4a18      	ldr	r2, [pc, #96]	; (1800339c <cmd_devmem+0xb8>)
1800333a:	f005 fe3d 	bl	18008fb8 <shell_fprintf>
	int err = 0;
1800333e:	2000      	movs	r0, #0
	value = strtoul(argv[3], NULL, 16);

	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);

	return memory_write(sh, addr, width, value);
}
18003340:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		width = 32;
18003344:	2520      	movs	r5, #32
18003346:	e7e4      	b.n	18003312 <cmd_devmem+0x2e>
	*(volatile uint8_t *)addr = data;
}

static ALWAYS_INLINE uint16_t sys_read16(mem_addr_t addr)
{
	return *(volatile uint16_t *)addr;
18003348:	8833      	ldrh	r3, [r6, #0]
1800334a:	b29b      	uxth	r3, r3
	if (err == 0) {
1800334c:	e7f2      	b.n	18003334 <cmd_devmem+0x50>
	*(volatile uint16_t *)addr = data;
}

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	return *(volatile uint32_t *)addr;
1800334e:	6833      	ldr	r3, [r6, #0]
18003350:	e7f0      	b.n	18003334 <cmd_devmem+0x50>
		shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
18003352:	2108      	movs	r1, #8
18003354:	4638      	mov	r0, r7
18003356:	4a12      	ldr	r2, [pc, #72]	; (180033a0 <cmd_devmem+0xbc>)
18003358:	f005 fe2e 	bl	18008fb8 <shell_fprintf>
		return -EINVAL;
1800335c:	f06f 0015 	mvn.w	r0, #21
18003360:	e7ee      	b.n	18003340 <cmd_devmem+0x5c>
	value = strtoul(argv[3], NULL, 16);
18003362:	2210      	movs	r2, #16
18003364:	2100      	movs	r1, #0
18003366:	68e0      	ldr	r0, [r4, #12]
18003368:	f006 fdda 	bl	18009f20 <strtoul>
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
1800336c:	2108      	movs	r1, #8
1800336e:	4603      	mov	r3, r0
	value = strtoul(argv[3], NULL, 16);
18003370:	4604      	mov	r4, r0
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
18003372:	4a0c      	ldr	r2, [pc, #48]	; (180033a4 <cmd_devmem+0xc0>)
18003374:	4638      	mov	r0, r7
18003376:	f005 fe1f 	bl	18008fb8 <shell_fprintf>
	switch (width) {
1800337a:	2d10      	cmp	r5, #16
1800337c:	d006      	beq.n	1800338c <cmd_devmem+0xa8>
1800337e:	2d20      	cmp	r5, #32
18003380:	d007      	beq.n	18003392 <cmd_devmem+0xae>
18003382:	2d08      	cmp	r5, #8
18003384:	d1e5      	bne.n	18003352 <cmd_devmem+0x6e>
		sys_write8(value, addr);
18003386:	b2e4      	uxtb	r4, r4
	*(volatile uint8_t *)addr = data;
18003388:	7034      	strb	r4, [r6, #0]
1800338a:	e7d8      	b.n	1800333e <cmd_devmem+0x5a>
		sys_write16(value, addr);
1800338c:	b2a4      	uxth	r4, r4
	*(volatile uint16_t *)addr = data;
1800338e:	8034      	strh	r4, [r6, #0]
18003390:	e7d5      	b.n	1800333e <cmd_devmem+0x5a>
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
18003392:	6034      	str	r4, [r6, #0]
18003394:	e7d3      	b.n	1800333e <cmd_devmem+0x5a>
18003396:	bf00      	nop
18003398:	1800cddf 	.word	0x1800cddf
1800339c:	1800ce0a 	.word	0x1800ce0a
180033a0:	1800cdf4 	.word	0x1800cdf4
180033a4:	1800ce1b 	.word	0x1800ce1b

180033a8 <set_bypass.isra.0>:
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
180033a8:	b570      	push	{r4, r5, r6, lr}
	if (bypass && in_use) {
180033aa:	4e0e      	ldr	r6, [pc, #56]	; (180033e4 <set_bypass.isra.0+0x3c>)
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
180033ac:	4604      	mov	r4, r0
	if (bypass && in_use) {
180033ae:	460d      	mov	r5, r1
180033b0:	7833      	ldrb	r3, [r6, #0]
180033b2:	b131      	cbz	r1, 180033c2 <set_bypass.isra.0+0x1a>
180033b4:	b12b      	cbz	r3, 180033c2 <set_bypass.isra.0+0x1a>
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
180033b6:	2101      	movs	r1, #1
}
180033b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
180033bc:	4a0a      	ldr	r2, [pc, #40]	; (180033e8 <set_bypass.isra.0+0x40>)
180033be:	f005 bdfb 	b.w	18008fb8 <shell_fprintf>
	in_use = !in_use;
180033c2:	f083 0301 	eor.w	r3, r3, #1
180033c6:	7033      	strb	r3, [r6, #0]
	if (in_use) {
180033c8:	b133      	cbz	r3, 180033d8 <set_bypass.isra.0+0x30>
		shell_print(sh, "Loading...\npress ctrl-x ctrl-q to escape");
180033ca:	2108      	movs	r1, #8
180033cc:	4620      	mov	r0, r4
180033ce:	4a07      	ldr	r2, [pc, #28]	; (180033ec <set_bypass.isra.0+0x44>)
180033d0:	f005 fdf2 	bl	18008fb8 <shell_fprintf>
		in_use = true;
180033d4:	2301      	movs	r3, #1
180033d6:	7033      	strb	r3, [r6, #0]
	shell_set_bypass(sh, bypass);
180033d8:	4629      	mov	r1, r5
180033da:	4620      	mov	r0, r4
}
180033dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	shell_set_bypass(sh, bypass);
180033e0:	f005 bdf7 	b.w	18008fd2 <shell_set_bypass>
180033e4:	30180a64 	.word	0x30180a64
180033e8:	1800ce2f 	.word	0x1800ce2f
180033ec:	1800ce6a 	.word	0x1800ce6a

180033f0 <bypass_cb>:
{
180033f0:	b570      	push	{r4, r5, r6, lr}
180033f2:	4604      	mov	r4, r0
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
180033f4:	483c      	ldr	r0, [pc, #240]	; (180034e8 <bypass_cb+0xf8>)
180033f6:	7803      	ldrb	r3, [r0, #0]
180033f8:	2b18      	cmp	r3, #24
180033fa:	d102      	bne.n	18003402 <bypass_cb+0x12>
180033fc:	780b      	ldrb	r3, [r1, #0]
180033fe:	2b11      	cmp	r3, #17
18003400:	d031      	beq.n	18003466 <bypass_cb+0x76>
18003402:	460b      	mov	r3, r1
18003404:	3a01      	subs	r2, #1
18003406:	1855      	adds	r5, r2, r1
		for (int i = 0; i < (len - 1); i++) {
18003408:	429d      	cmp	r5, r3
1800340a:	d125      	bne.n	18003458 <bypass_cb+0x68>
	tail = recv[len - 1];
1800340c:	5c8b      	ldrb	r3, [r1, r2]
	if (is_ascii(*recv)) {
1800340e:	780a      	ldrb	r2, [r1, #0]
	tail = recv[len - 1];
18003410:	7003      	strb	r3, [r0, #0]
	return (data >= 0x30 && data <= 0x39) || (data >= 0x61 && data <= 0x66) ||
18003412:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
18003416:	2b09      	cmp	r3, #9
18003418:	4c34      	ldr	r4, [pc, #208]	; (180034ec <bypass_cb+0xfc>)
1800341a:	d904      	bls.n	18003426 <bypass_cb+0x36>
	if (is_ascii(*recv)) {
1800341c:	f022 0320 	bic.w	r3, r2, #32
18003420:	3b41      	subs	r3, #65	; 0x41
18003422:	2b05      	cmp	r3, #5
18003424:	d804      	bhi.n	18003430 <bypass_cb+0x40>
		chunk[chunk_element] = *recv;
18003426:	6823      	ldr	r3, [r4, #0]
18003428:	4931      	ldr	r1, [pc, #196]	; (180034f0 <bypass_cb+0x100>)
1800342a:	54ca      	strb	r2, [r1, r3]
		chunk_element++;
1800342c:	3301      	adds	r3, #1
1800342e:	6023      	str	r3, [r4, #0]
	if (chunk_element == 2) {
18003430:	6823      	ldr	r3, [r4, #0]
18003432:	2b02      	cmp	r3, #2
18003434:	d134      	bne.n	180034a0 <bypass_cb+0xb0>
		byte = (uint8_t)strtoul(chunk, NULL, 16);
18003436:	2210      	movs	r2, #16
18003438:	2100      	movs	r1, #0
1800343a:	482d      	ldr	r0, [pc, #180]	; (180034f0 <bypass_cb+0x100>)
1800343c:	f006 fd70 	bl	18009f20 <strtoul>
		*bytes = byte;
18003440:	4a2c      	ldr	r2, [pc, #176]	; (180034f4 <bypass_cb+0x104>)
		byte = (uint8_t)strtoul(chunk, NULL, 16);
18003442:	6813      	ldr	r3, [r2, #0]
18003444:	f803 0b01 	strb.w	r0, [r3], #1
		bytes++;
18003448:	6013      	str	r3, [r2, #0]
		sum++;
1800344a:	4a2b      	ldr	r2, [pc, #172]	; (180034f8 <bypass_cb+0x108>)
1800344c:	6813      	ldr	r3, [r2, #0]
1800344e:	3301      	adds	r3, #1
18003450:	6013      	str	r3, [r2, #0]
		chunk_element = 0;
18003452:	2300      	movs	r3, #0
18003454:	6023      	str	r3, [r4, #0]
18003456:	e023      	b.n	180034a0 <bypass_cb+0xb0>
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
18003458:	f813 6b01 	ldrb.w	r6, [r3], #1
1800345c:	2e18      	cmp	r6, #24
1800345e:	d1d3      	bne.n	18003408 <bypass_cb+0x18>
18003460:	781e      	ldrb	r6, [r3, #0]
18003462:	2e11      	cmp	r6, #17
18003464:	d1d0      	bne.n	18003408 <bypass_cb+0x18>
		shell_print(sh, "Number of bytes read: %d", sum);
18003466:	4d24      	ldr	r5, [pc, #144]	; (180034f8 <bypass_cb+0x108>)
18003468:	2108      	movs	r1, #8
1800346a:	682b      	ldr	r3, [r5, #0]
1800346c:	4620      	mov	r0, r4
1800346e:	4a23      	ldr	r2, [pc, #140]	; (180034fc <bypass_cb+0x10c>)
18003470:	f005 fda2 	bl	18008fb8 <shell_fprintf>
		set_bypass(sh, NULL);
18003474:	4620      	mov	r0, r4
18003476:	2100      	movs	r1, #0
18003478:	f7ff ff96 	bl	180033a8 <set_bypass.isra.0>
		if (!littleendian) {
1800347c:	4b20      	ldr	r3, [pc, #128]	; (18003500 <bypass_cb+0x110>)
1800347e:	7818      	ldrb	r0, [r3, #0]
18003480:	b970      	cbnz	r0, 180034a0 <bypass_cb+0xb0>
18003482:	4a20      	ldr	r2, [pc, #128]	; (18003504 <bypass_cb+0x114>)
18003484:	682b      	ldr	r3, [r5, #0]
18003486:	6811      	ldr	r1, [r2, #0]
			while (sum > 4) {
18003488:	2b04      	cmp	r3, #4
1800348a:	dc0a      	bgt.n	180034a2 <bypass_cb+0xb2>
1800348c:	b108      	cbz	r0, 18003492 <bypass_cb+0xa2>
1800348e:	6011      	str	r1, [r2, #0]
18003490:	602b      	str	r3, [r5, #0]
			if (sum % 4 == 0) {
18003492:	f013 0103 	ands.w	r1, r3, #3
18003496:	d10b      	bne.n	180034b0 <bypass_cb+0xc0>
				*data = __bswap_32(*data);
18003498:	6812      	ldr	r2, [r2, #0]
1800349a:	6813      	ldr	r3, [r2, #0]
1800349c:	ba1b      	rev	r3, r3
				*data = __bswap_16(*data);
1800349e:	6013      	str	r3, [r2, #0]
}
180034a0:	bd70      	pop	{r4, r5, r6, pc}
				*data = __bswap_32(*data);
180034a2:	6808      	ldr	r0, [r1, #0]
180034a4:	3b04      	subs	r3, #4
180034a6:	ba00      	rev	r0, r0
180034a8:	f841 0b04 	str.w	r0, [r1], #4
				data++;
180034ac:	2001      	movs	r0, #1
180034ae:	e7eb      	b.n	18003488 <bypass_cb+0x98>
			} else if (sum % 4 == 2) {
180034b0:	425b      	negs	r3, r3
180034b2:	f003 0303 	and.w	r3, r3, #3
180034b6:	bf58      	it	pl
180034b8:	4259      	negpl	r1, r3
180034ba:	2902      	cmp	r1, #2
180034bc:	d104      	bne.n	180034c8 <bypass_cb+0xd8>
				*data = __bswap_16(*data);
180034be:	6812      	ldr	r2, [r2, #0]
180034c0:	8813      	ldrh	r3, [r2, #0]
180034c2:	ba5b      	rev16	r3, r3
180034c4:	b29b      	uxth	r3, r3
180034c6:	e7ea      	b.n	1800349e <bypass_cb+0xae>
			} else if (sum % 4 == 3) {
180034c8:	2903      	cmp	r1, #3
180034ca:	d1e9      	bne.n	180034a0 <bypass_cb+0xb0>
				*data = __bswap_24(*data);
180034cc:	6810      	ldr	r0, [r2, #0]
180034ce:	6802      	ldr	r2, [r0, #0]
180034d0:	0411      	lsls	r1, r2, #16
180034d2:	f3c2 4307 	ubfx	r3, r2, #16, #8
180034d6:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
180034da:	430b      	orrs	r3, r1
180034dc:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
180034e0:	4313      	orrs	r3, r2
180034e2:	6003      	str	r3, [r0, #0]
180034e4:	e7dc      	b.n	180034a0 <bypass_cb+0xb0>
180034e6:	bf00      	nop
180034e8:	30180a66 	.word	0x30180a66
180034ec:	30180584 	.word	0x30180584
180034f0:	30180a62 	.word	0x30180a62
180034f4:	30180580 	.word	0x30180580
180034f8:	3018058c 	.word	0x3018058c
180034fc:	1800ce94 	.word	0x1800ce94
18003500:	30180a65 	.word	0x30180a65
18003504:	30180588 	.word	0x30180588

18003508 <cmd_load>:
	littleendian = false;
18003508:	2300      	movs	r3, #0
{
1800350a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
1800350e:	4606      	mov	r6, r0
	littleendian = false;
18003510:	4614      	mov	r4, r2
{
18003512:	460d      	mov	r5, r1
	chunk_element = 0;
18003514:	492b      	ldr	r1, [pc, #172]	; (180035c4 <cmd_load+0xbc>)
	littleendian = false;
18003516:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 180035c8 <cmd_load+0xc0>
	chunk_element = 0;
1800351a:	600b      	str	r3, [r1, #0]
	sum = 0;
1800351c:	492b      	ldr	r1, [pc, #172]	; (180035cc <cmd_load+0xc4>)
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
1800351e:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 180035d0 <cmd_load+0xc8>
			shell_print(sh, "Unknown option \"%s\"", arg);
18003522:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 180035d4 <cmd_load+0xcc>
	littleendian = false;
18003526:	f888 3000 	strb.w	r3, [r8]
	sum = 0;
1800352a:	600b      	str	r3, [r1, #0]
	while (argc >= 2) {
1800352c:	2d01      	cmp	r5, #1
1800352e:	4627      	mov	r7, r4
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
18003530:	f854 3f04 	ldr.w	r3, [r4, #4]!
	while (argc >= 2) {
18003534:	d921      	bls.n	1800357a <cmd_load+0x72>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
18003536:	4618      	mov	r0, r3
18003538:	2202      	movs	r2, #2
1800353a:	4649      	mov	r1, r9
1800353c:	9301      	str	r3, [sp, #4]
1800353e:	f006 fdce 	bl	1800a0de <strncmp>
18003542:	9b01      	ldr	r3, [sp, #4]
18003544:	b988      	cbnz	r0, 1800356a <cmd_load+0x62>
18003546:	6822      	ldr	r2, [r4, #0]
18003548:	7892      	ldrb	r2, [r2, #2]
1800354a:	3a00      	subs	r2, #0
1800354c:	bf18      	it	ne
1800354e:	2201      	movne	r2, #1
18003550:	eb03 0a02 	add.w	sl, r3, r2
		if (!strncmp(arg, "-e", 2)) {
18003554:	4650      	mov	r0, sl
18003556:	2202      	movs	r2, #2
18003558:	491f      	ldr	r1, [pc, #124]	; (180035d8 <cmd_load+0xd0>)
1800355a:	f006 fdc0 	bl	1800a0de <strncmp>
1800355e:	b930      	cbnz	r0, 1800356e <cmd_load+0x66>
			littleendian = true;
18003560:	2301      	movs	r3, #1
18003562:	f888 3000 	strb.w	r3, [r8]
		argc--;
18003566:	3d01      	subs	r5, #1
18003568:	e7e0      	b.n	1800352c <cmd_load+0x24>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
1800356a:	2200      	movs	r2, #0
1800356c:	e7f0      	b.n	18003550 <cmd_load+0x48>
		} else if (!strcmp(arg, "--")) {
1800356e:	4649      	mov	r1, r9
18003570:	4650      	mov	r0, sl
18003572:	f006 fda8 	bl	1800a0c6 <strcmp>
18003576:	b9b0      	cbnz	r0, 180035a6 <cmd_load+0x9e>
			argv++;
18003578:	3704      	adds	r7, #4
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
1800357a:	2200      	movs	r2, #0
1800357c:	6878      	ldr	r0, [r7, #4]
1800357e:	4611      	mov	r1, r2
18003580:	f006 fc5a 	bl	18009e38 <strtol>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
18003584:	2200      	movs	r2, #0
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
18003586:	4b15      	ldr	r3, [pc, #84]	; (180035dc <cmd_load+0xd4>)
	data = (uint32_t *)strtol(argv[1], NULL, 0);
18003588:	4611      	mov	r1, r2
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
1800358a:	6018      	str	r0, [r3, #0]
	data = (uint32_t *)strtol(argv[1], NULL, 0);
1800358c:	6878      	ldr	r0, [r7, #4]
1800358e:	f006 fc53 	bl	18009e38 <strtol>
18003592:	4b13      	ldr	r3, [pc, #76]	; (180035e0 <cmd_load+0xd8>)
	set_bypass(sh, bypass_cb);
18003594:	4913      	ldr	r1, [pc, #76]	; (180035e4 <cmd_load+0xdc>)
	data = (uint32_t *)strtol(argv[1], NULL, 0);
18003596:	6018      	str	r0, [r3, #0]
	set_bypass(sh, bypass_cb);
18003598:	4630      	mov	r0, r6
1800359a:	f7ff ff05 	bl	180033a8 <set_bypass.isra.0>
}
1800359e:	2000      	movs	r0, #0
180035a0:	b003      	add	sp, #12
180035a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (arg[0] == '-' && arg[1]) {
180035a6:	f89a 2000 	ldrb.w	r2, [sl]
180035aa:	2a2d      	cmp	r2, #45	; 0x2d
180035ac:	d1e5      	bne.n	1800357a <cmd_load+0x72>
180035ae:	f89a 2001 	ldrb.w	r2, [sl, #1]
180035b2:	2a00      	cmp	r2, #0
180035b4:	d0e1      	beq.n	1800357a <cmd_load+0x72>
			shell_print(sh, "Unknown option \"%s\"", arg);
180035b6:	4653      	mov	r3, sl
180035b8:	465a      	mov	r2, fp
180035ba:	2108      	movs	r1, #8
180035bc:	4630      	mov	r0, r6
180035be:	f005 fcfb 	bl	18008fb8 <shell_fprintf>
180035c2:	e7d0      	b.n	18003566 <cmd_load+0x5e>
180035c4:	30180584 	.word	0x30180584
180035c8:	30180a65 	.word	0x30180a65
180035cc:	3018058c 	.word	0x3018058c
180035d0:	1800ceae 	.word	0x1800ceae
180035d4:	1800ceb4 	.word	0x1800ceb4
180035d8:	1800ceb1 	.word	0x1800ceb1
180035dc:	30180580 	.word	0x30180580
180035e0:	30180588 	.word	0x30180588
180035e4:	180033f1 	.word	0x180033f1

180035e8 <timer_handler>:
	uart_irq_rx_enable(dev);
#endif
}

static void timer_handler(struct k_timer *timer)
{
180035e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
180035ea:	4e14      	ldr	r6, [pc, #80]	; (1800363c <timer_handler+0x54>)
180035ec:	4c14      	ldr	r4, [pc, #80]	; (18003640 <timer_handler+0x58>)
	return timer->user_data;
180035ee:	6b45      	ldr	r5, [r0, #52]	; 0x34
180035f0:	1b34      	subs	r4, r6, r4
180035f2:	08a4      	lsrs	r4, r4, #2
	const struct shell_uart *sh_uart = k_timer_user_data_get(timer);

	while (uart_poll_in(sh_uart->ctrl_blk->dev, &c) == 0) {
		if (ring_buf_put(sh_uart->rx_ringbuf, &c, 1) == 0U) {
			/* ring buffer full. */
			LOG_WRN("RX ring buffer full.");
180035f4:	01a4      	lsls	r4, r4, #6
180035f6:	4f13      	ldr	r7, [pc, #76]	; (18003644 <timer_handler+0x5c>)
180035f8:	f044 0402 	orr.w	r4, r4, #2
	while (uart_poll_in(sh_uart->ctrl_blk->dev, &c) == 0) {
180035fc:	682b      	ldr	r3, [r5, #0]
180035fe:	6818      	ldr	r0, [r3, #0]
				      unsigned char *p_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	if (api->poll_in == NULL) {
18003600:	6883      	ldr	r3, [r0, #8]
18003602:	681b      	ldr	r3, [r3, #0]
18003604:	b11b      	cbz	r3, 1800360e <timer_handler+0x26>
		return -ENOSYS;
	}

	return api->poll_in(dev, p_char);
18003606:	f10d 0107 	add.w	r1, sp, #7
1800360a:	4798      	blx	r3
1800360c:	b108      	cbz	r0, 18003612 <timer_handler+0x2a>
		}
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
					   sh_uart->ctrl_blk->context);
	}
}
1800360e:	b003      	add	sp, #12
18003610:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ring_buf_put(sh_uart->rx_ringbuf, &c, 1) == 0U) {
18003612:	2201      	movs	r2, #1
18003614:	68e8      	ldr	r0, [r5, #12]
18003616:	f10d 0107 	add.w	r1, sp, #7
1800361a:	f004 fec4 	bl	180083a6 <ring_buf_put>
1800361e:	b938      	cbnz	r0, 18003630 <timer_handler+0x48>
			LOG_WRN("RX ring buffer full.");
18003620:	6833      	ldr	r3, [r6, #0]
18003622:	f013 0f06 	tst.w	r3, #6
18003626:	d003      	beq.n	18003630 <timer_handler+0x48>
18003628:	4621      	mov	r1, r4
1800362a:	4638      	mov	r0, r7
1800362c:	f005 f8bf 	bl	180087ae <log_0>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
18003630:	682b      	ldr	r3, [r5, #0]
18003632:	2000      	movs	r0, #0
18003634:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
18003638:	4790      	blx	r2
1800363a:	e7df      	b.n	180035fc <timer_handler+0x14>
1800363c:	301800a4 	.word	0x301800a4
18003640:	3018008c 	.word	0x3018008c
18003644:	1800cf56 	.word	0x1800cf56

18003648 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(const struct device *arg)
{
18003648:	b507      	push	{r0, r1, r2, lr}
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
1800364a:	480a      	ldr	r0, [pc, #40]	; (18003674 <enable_shell_uart+0x2c>)
1800364c:	f007 f9a7 	bl	1800a99e <z_device_ready>
18003650:	b160      	cbz	r0, 1800366c <enable_shell_uart+0x24>

	if (IS_ENABLED(CONFIG_MCUMGR_SMP_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, cfg_flags, log_backend, level);
18003652:	2304      	movs	r3, #4
18003654:	4a08      	ldr	r2, [pc, #32]	; (18003678 <enable_shell_uart+0x30>)
18003656:	9300      	str	r3, [sp, #0]
18003658:	6812      	ldr	r2, [r2, #0]
1800365a:	2301      	movs	r3, #1
1800365c:	4905      	ldr	r1, [pc, #20]	; (18003674 <enable_shell_uart+0x2c>)
1800365e:	4807      	ldr	r0, [pc, #28]	; (1800367c <enable_shell_uart+0x34>)
18003660:	f000 fd58 	bl	18004114 <shell_init>

	return 0;
18003664:	2000      	movs	r0, #0
}
18003666:	b003      	add	sp, #12
18003668:	f85d fb04 	ldr.w	pc, [sp], #4
		return -ENODEV;
1800366c:	f06f 0012 	mvn.w	r0, #18
18003670:	e7f9      	b.n	18003666 <enable_shell_uart+0x1e>
18003672:	bf00      	nop
18003674:	1800b180 	.word	0x1800b180
18003678:	1800b804 	.word	0x1800b804
1800367c:	1800b408 	.word	0x1800b408

18003680 <init>:
{
18003680:	b513      	push	{r0, r1, r4, lr}
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
18003682:	6844      	ldr	r4, [r0, #4]
	sh_uart->ctrl_blk->dev = (const struct device *)config;
18003684:	6820      	ldr	r0, [r4, #0]
	sh_uart->ctrl_blk->handler = evt_handler;
18003686:	e9c0 1200 	strd	r1, r2, [r0]
	sh_uart->ctrl_blk->context = context;
1800368a:	6083      	str	r3, [r0, #8]
		k_timer_init(sh_uart->timer, timer_handler, NULL);
1800368c:	2200      	movs	r2, #0
1800368e:	4908      	ldr	r1, [pc, #32]	; (180036b0 <init+0x30>)
18003690:	6860      	ldr	r0, [r4, #4]
18003692:	f007 fb61 	bl	1800ad58 <k_timer_init>
		k_timer_user_data_set(sh_uart->timer, (void *)sh_uart);
18003696:	6863      	ldr	r3, [r4, #4]
	timer->user_data = user_data;
18003698:	2264      	movs	r2, #100	; 0x64
1800369a:	635c      	str	r4, [r3, #52]	; 0x34
		k_timer_start(sh_uart->timer, RX_POLL_PERIOD, RX_POLL_PERIOD);
1800369c:	6860      	ldr	r0, [r4, #4]
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
1800369e:	2300      	movs	r3, #0
	z_impl_k_timer_start(timer, duration, period);
180036a0:	e9cd 2300 	strd	r2, r3, [sp]
180036a4:	f004 faa8 	bl	18007bf8 <z_impl_k_timer_start>
}
180036a8:	2000      	movs	r0, #0
180036aa:	b002      	add	sp, #8
180036ac:	bd10      	pop	{r4, pc}
180036ae:	bf00      	nop
180036b0:	180035e9 	.word	0x180035e9

180036b4 <shell_internal_help_print>:
	shell->ctx->cmd_buff_pos = 0;
	shell->ctx->cmd_buff_len = 0;
}

static void shell_internal_help_print(const struct shell *shell)
{
180036b4:	b510      	push	{r4, lr}
180036b6:	4604      	mov	r4, r0
	if (!IS_ENABLED(CONFIG_SHELL_HELP)) {
		return;
	}

	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
180036b8:	6881      	ldr	r1, [r0, #8]
180036ba:	3108      	adds	r1, #8
180036bc:	f001 f852 	bl	18004764 <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
180036c0:	68a1      	ldr	r1, [r4, #8]
180036c2:	4620      	mov	r0, r4
				  "Subcommands:\n");
}
180036c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
180036c8:	4a01      	ldr	r2, [pc, #4]	; (180036d0 <shell_internal_help_print+0x1c>)
180036ca:	3108      	adds	r1, #8
180036cc:	f000 bff2 	b.w	180046b4 <z_shell_help_subcmd_print>
180036d0:	1800cf99 	.word	0x1800cf99

180036d4 <z_cursor_next_line_move.isra.0>:
/* Function forcing new line - cannot be replaced with function
 * cursor_down_move.
 */
static inline void z_cursor_next_line_move(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
180036d4:	4901      	ldr	r1, [pc, #4]	; (180036dc <z_cursor_next_line_move.isra.0+0x8>)
180036d6:	f005 bbb3 	b.w	18008e40 <z_shell_raw_fprintf>
180036da:	bf00      	nop
180036dc:	1800ccbd 	.word	0x1800ccbd

180036e0 <history_handle>:

	z_shell_history_put(shell->history, line, length);
}

static void history_handle(const struct shell *shell, bool up)
{
180036e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
180036e2:	4604      	mov	r4, r0
	return sh->ctx->ctx.flags.history_exit == 1;
180036e4:	6880      	ldr	r0, [r0, #8]
180036e6:	460d      	mov	r5, r1
180036e8:	f8d0 3264 	ldr.w	r3, [r0, #612]	; 0x264
	if (!IS_ENABLED(CONFIG_SHELL_HISTORY)) {
		return;
	}

	/* Checking if history process has been stopped */
	if (z_flag_history_exit_get(shell)) {
180036ec:	075a      	lsls	r2, r3, #29
180036ee:	d505      	bpl.n	180036fc <history_handle+0x1c>
		z_flag_history_exit_set(shell, false);
180036f0:	2100      	movs	r1, #0
180036f2:	f005 fbe6 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(shell->history);
180036f6:	68e0      	ldr	r0, [r4, #12]
180036f8:	f006 fa74 	bl	18009be4 <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
180036fc:	68e3      	ldr	r3, [r4, #12]
	}

	/* Backup command if history is entered */
	if (!z_shell_history_active(shell->history)) {
180036fe:	68db      	ldr	r3, [r3, #12]
18003700:	b96b      	cbnz	r3, 1800371e <history_handle+0x3e>
		if (up) {
18003702:	2d00      	cmp	r5, #0
18003704:	d037      	beq.n	18003776 <history_handle+0x96>
			uint16_t cmd_len = z_shell_strlen(shell->ctx->cmd_buff);
18003706:	68a0      	ldr	r0, [r4, #8]
18003708:	3042      	adds	r0, #66	; 0x42
1800370a:	f005 fb93 	bl	18008e34 <z_shell_strlen>

			if (cmd_len) {
1800370e:	68a3      	ldr	r3, [r4, #8]
18003710:	b398      	cbz	r0, 1800377a <history_handle+0x9a>
				strcpy(shell->ctx->temp_buff,
18003712:	f103 0142 	add.w	r1, r3, #66	; 0x42
18003716:	f503 70a1 	add.w	r0, r3, #322	; 0x142
1800371a:	f006 fc9a 	bl	1800a052 <strcpy>
		}
	}

	/* Start by checking if history is not empty. */
	history_mode = z_shell_history_get(shell->history, up,
					   shell->ctx->cmd_buff, &len);
1800371e:	68a2      	ldr	r2, [r4, #8]
	history_mode = z_shell_history_get(shell->history, up,
18003720:	4629      	mov	r1, r5
18003722:	68e0      	ldr	r0, [r4, #12]
18003724:	f10d 0306 	add.w	r3, sp, #6
18003728:	3242      	adds	r2, #66	; 0x42
1800372a:	f006 fa5e 	bl	18009bea <z_shell_history_get>

	/* On exiting history mode print backed up command. */
	if (!history_mode) {
1800372e:	b958      	cbnz	r0, 18003748 <history_handle+0x68>
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
18003730:	68a0      	ldr	r0, [r4, #8]
18003732:	f500 71a1 	add.w	r1, r0, #322	; 0x142
18003736:	3042      	adds	r0, #66	; 0x42
18003738:	f006 fc8b 	bl	1800a052 <strcpy>
		len = z_shell_strlen(shell->ctx->cmd_buff);
1800373c:	68a0      	ldr	r0, [r4, #8]
1800373e:	3042      	adds	r0, #66	; 0x42
18003740:	f005 fb78 	bl	18008e34 <z_shell_strlen>
18003744:	f8ad 0006 	strh.w	r0, [sp, #6]
	}

	z_shell_op_cursor_home_move(shell);
18003748:	4620      	mov	r0, r4
1800374a:	f005 ff15 	bl	18009578 <z_shell_op_cursor_home_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
1800374e:	68a3      	ldr	r3, [r4, #8]
18003750:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
18003754:	069b      	lsls	r3, r3, #26
18003756:	d503      	bpl.n	18003760 <history_handle+0x80>
18003758:	4909      	ldr	r1, [pc, #36]	; (18003780 <history_handle+0xa0>)
1800375a:	6960      	ldr	r0, [r4, #20]
1800375c:	f005 fb70 	bl	18008e40 <z_shell_raw_fprintf>
	z_clear_eos(shell);
	z_shell_print_cmd(shell);
18003760:	4620      	mov	r0, r4
18003762:	f000 fe77 	bl	18004454 <z_shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
18003766:	68a3      	ldr	r3, [r4, #8]
18003768:	f8bd 2006 	ldrh.w	r2, [sp, #6]
	shell->ctx->cmd_buff_len = len;
	z_shell_op_cond_next_line(shell);
1800376c:	4620      	mov	r0, r4
	shell->ctx->cmd_buff_pos = len;
1800376e:	87da      	strh	r2, [r3, #62]	; 0x3e
	shell->ctx->cmd_buff_len = len;
18003770:	879a      	strh	r2, [r3, #60]	; 0x3c
	z_shell_op_cond_next_line(shell);
18003772:	f005 fe6f 	bl	18009454 <z_shell_op_cond_next_line>
}
18003776:	b003      	add	sp, #12
18003778:	bd30      	pop	{r4, r5, pc}
				shell->ctx->temp_buff[0] = '\0';
1800377a:	f883 0142 	strb.w	r0, [r3, #322]	; 0x142
1800377e:	e7ce      	b.n	1800371e <history_handle+0x3e>
18003780:	1800b4a8 	.word	0x1800b4a8

18003784 <execute>:
	struct shell_static_entry dloc; /* Memory for dynamic commands. */
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1]; /* +1 reserved for NULL */
	const struct shell_static_entry *parent = selected_cmd_get(shell);
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry help_entry;
	size_t cmd_lvl = 0;
18003784:	2300      	movs	r3, #0
{
18003786:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1800378a:	4604      	mov	r4, r0
1800378c:	b09f      	sub	sp, #124	; 0x7c
	size_t cmd_with_handler_lvl = 0;
	bool wildcard_found = false;
	size_t argc = 0, args_left = SIZE_MAX;
1800378e:	e9cd 3305 	strd	r3, r3, [sp, #20]
	char quote;
	const char **argvp;
	char *cmd_buf = shell->ctx->cmd_buff;
18003792:	6883      	ldr	r3, [r0, #8]
18003794:	3342      	adds	r3, #66	; 0x42
18003796:	9303      	str	r3, [sp, #12]
	bool has_last_handler = false;

	z_shell_op_cursor_end_move(shell);
18003798:	f005 fef4 	bl	18009584 <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(shell)) {
1800379c:	4620      	mov	r0, r4
1800379e:	f005 fe45 	bl	1800942c <z_shell_cursor_in_empty_line>
180037a2:	b910      	cbnz	r0, 180037aa <execute+0x26>
		z_cursor_next_line_move(shell);
180037a4:	6960      	ldr	r0, [r4, #20]
180037a6:	f7ff ff95 	bl	180036d4 <z_cursor_next_line_move.isra.0>
		argvp = &argv[1];
		active_cmd_prepare(parent, &shell->ctx->active_cmd, &help_entry,
				   &cmd_lvl, &cmd_with_handler_lvl, &args_left);
		cmd_lvl++;
	} else {
		help_entry.help = NULL;
180037aa:	2600      	movs	r6, #0
	size_t argc = 0, args_left = SIZE_MAX;
180037ac:	f04f 38ff 	mov.w	r8, #4294967295
	size_t cmd_with_handler_lvl = 0;
180037b0:	46b1      	mov	r9, r6
		z_shell_wildcard_prepare(shell);
180037b2:	46b2      	mov	sl, r6
180037b4:	4635      	mov	r5, r6
180037b6:	46b3      	mov	fp, r6
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
180037b8:	68a0      	ldr	r0, [r4, #8]
180037ba:	2214      	movs	r2, #20
180037bc:	2100      	movs	r1, #0
180037be:	3008      	adds	r0, #8
180037c0:	f006 fcd2 	bl	1800a168 <memset>
		z_shell_cmd_trim(shell);
180037c4:	4620      	mov	r0, r4
180037c6:	f005 fdde 	bl	18009386 <z_shell_cmd_trim>
		history_put(shell, shell->ctx->cmd_buff,
180037ca:	68a1      	ldr	r1, [r4, #8]
	z_shell_history_put(shell->history, line, length);
180037cc:	68e0      	ldr	r0, [r4, #12]
180037ce:	8f8a      	ldrh	r2, [r1, #60]	; 0x3c
180037d0:	3142      	adds	r1, #66	; 0x42
180037d2:	f006 fa41 	bl	18009c58 <z_shell_history_put>
		z_shell_wildcard_prepare(shell);
180037d6:	4620      	mov	r0, r4
180037d8:	f006 fac4 	bl	18009d64 <z_shell_wildcard_prepare>
180037dc:	af11      	add	r7, sp, #68	; 0x44
180037de:	9602      	str	r6, [sp, #8]
		argvp = &argv[0];
	}

	/* Below loop is analyzing subcommands of found root command. */
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
180037e0:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
180037e4:	2a01      	cmp	r2, #1
180037e6:	f000 80d6 	beq.w	18003996 <execute+0x212>
180037ea:	2b0b      	cmp	r3, #11
180037ec:	f240 80ae 	bls.w	1800394c <execute+0x1c8>
			cmd_lvl++;
		}

	}

	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
180037f0:	9b06      	ldr	r3, [sp, #24]
180037f2:	2b02      	cmp	r3, #2
180037f4:	f040 80ae 	bne.w	18003954 <execute+0x1d0>
		/* argc == 2 indicates that when command string was parsed
		 * there was more characters remaining. It means that number of
		 * arguments exceeds the limit.
		 */
		z_shell_fprintf(shell, SHELL_ERROR, "%s\n",
180037f8:	2101      	movs	r1, #1
180037fa:	4b89      	ldr	r3, [pc, #548]	; (18003a20 <execute+0x29c>)
180037fc:	4a89      	ldr	r2, [pc, #548]	; (18003a24 <execute+0x2a0>)
180037fe:	e014      	b.n	1800382a <execute+0xa6>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
18003800:	2302      	movs	r3, #2
18003802:	4639      	mov	r1, r7
18003804:	9a03      	ldr	r2, [sp, #12]
18003806:	a806      	add	r0, sp, #24
18003808:	f005 fc4e 	bl	180090a8 <z_shell_make_argv>
		cmd_buf = (char *)argvp[1];
1800380c:	687a      	ldr	r2, [r7, #4]
		if (argc == 0) {
1800380e:	9906      	ldr	r1, [sp, #24]
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
18003810:	4603      	mov	r3, r0
		cmd_buf = (char *)argvp[1];
18003812:	9203      	str	r2, [sp, #12]
		if (argc == 0) {
18003814:	b929      	cbnz	r1, 18003822 <execute+0x9e>
			return -ENOEXEC;
18003816:	f06f 0507 	mvn.w	r5, #7
	/* terminate arguments with NULL */
	argv[cmd_lvl] = NULL;
	/* Executing the deepest found handler. */
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
			&argv[cmd_with_handler_lvl], &help_entry);
}
1800381a:	4628      	mov	r0, r5
1800381c:	b01f      	add	sp, #124	; 0x7c
1800381e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if ((argc == 1) && (quote != 0)) {
18003822:	2901      	cmp	r1, #1
18003824:	d105      	bne.n	18003832 <execute+0xae>
18003826:	b120      	cbz	r0, 18003832 <execute+0xae>
			z_shell_fprintf(shell, SHELL_ERROR,
18003828:	4a7f      	ldr	r2, [pc, #508]	; (18003a28 <execute+0x2a4>)
1800382a:	4620      	mov	r0, r4
1800382c:	f005 ff52 	bl	180096d4 <z_shell_fprintf>
18003830:	e7f1      	b.n	18003816 <execute+0x92>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
18003832:	9b05      	ldr	r3, [sp, #20]
18003834:	b34b      	cbz	r3, 1800388a <execute+0x106>
		    z_shell_help_request(argvp[0])) {
18003836:	6838      	ldr	r0, [r7, #0]
18003838:	f000 ffb8 	bl	180047ac <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
1800383c:	b198      	cbz	r0, 18003866 <execute+0xe2>
			if (help_entry.help) {
1800383e:	b166      	cbz	r6, 1800385a <execute+0xd6>
				shell->ctx->active_cmd = help_entry;
18003840:	68a5      	ldr	r5, [r4, #8]
18003842:	960d      	str	r6, [sp, #52]	; 0x34
18003844:	3508      	adds	r5, #8
				shell->ctx->active_cmd = *help_entry;
18003846:	ae0c      	add	r6, sp, #48	; 0x30
18003848:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
1800384a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
1800384c:	6833      	ldr	r3, [r6, #0]
1800384e:	602b      	str	r3, [r5, #0]
			shell_internal_help_print(shell);
18003850:	4620      	mov	r0, r4
18003852:	f7ff ff2f 	bl	180036b4 <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
18003856:	2501      	movs	r5, #1
18003858:	e7df      	b.n	1800381a <execute+0x96>
			z_shell_fprintf(shell, SHELL_ERROR,
1800385a:	4a74      	ldr	r2, [pc, #464]	; (18003a2c <execute+0x2a8>)
		z_shell_fprintf(shell, SHELL_ERROR,
1800385c:	2101      	movs	r1, #1
1800385e:	4620      	mov	r0, r4
18003860:	f005 ff38 	bl	180096d4 <z_shell_fprintf>
		return false;
18003864:	e7d7      	b.n	18003816 <execute+0x92>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
18003866:	9b05      	ldr	r3, [sp, #20]
18003868:	b17b      	cbz	r3, 1800388a <execute+0x106>
			status = z_shell_wildcard_process(shell, entry,
1800386a:	4629      	mov	r1, r5
1800386c:	4620      	mov	r0, r4
1800386e:	683a      	ldr	r2, [r7, #0]
18003870:	f001 f8fe 	bl	18004a70 <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
18003874:	2802      	cmp	r0, #2
18003876:	f000 808e 	beq.w	18003996 <execute+0x212>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
1800387a:	2803      	cmp	r0, #3
1800387c:	d005      	beq.n	1800388a <execute+0x106>
				++cmd_lvl;
1800387e:	9b05      	ldr	r3, [sp, #20]
18003880:	3301      	adds	r3, #1
18003882:	9305      	str	r3, [sp, #20]
				wildcard_found = true;
18003884:	2301      	movs	r3, #1
18003886:	9302      	str	r3, [sp, #8]
				continue;
18003888:	e7aa      	b.n	180037e0 <execute+0x5c>
		if (has_last_handler == false) {
1800388a:	f1ba 0f00 	cmp.w	sl, #0
1800388e:	d105      	bne.n	1800389c <execute+0x118>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
18003890:	4658      	mov	r0, fp
18003892:	6839      	ldr	r1, [r7, #0]
18003894:	aa07      	add	r2, sp, #28
18003896:	f005 fcf2 	bl	1800927e <z_shell_find_cmd>
1800389a:	4605      	mov	r5, r0
		argvp++;
1800389c:	3704      	adds	r7, #4
		args_left--;
1800389e:	f108 38ff 	add.w	r8, r8, #4294967295
		if (entry) {
180038a2:	2d00      	cmp	r5, #0
180038a4:	d040      	beq.n	18003928 <execute+0x1a4>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
180038a6:	9a02      	ldr	r2, [sp, #8]
180038a8:	68eb      	ldr	r3, [r5, #12]
180038aa:	b142      	cbz	r2, 180038be <execute+0x13a>
180038ac:	b313      	cbz	r3, 180038f4 <execute+0x170>
		z_shell_op_cursor_end_move(shell);
180038ae:	4620      	mov	r0, r4
180038b0:	f005 fe68 	bl	18009584 <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(shell);
180038b4:	4620      	mov	r0, r4
180038b6:	f005 fdcd 	bl	18009454 <z_shell_op_cond_next_line>
		z_shell_fprintf(shell, SHELL_ERROR,
180038ba:	4a5d      	ldr	r2, [pc, #372]	; (18003a30 <execute+0x2ac>)
180038bc:	e7ce      	b.n	1800385c <execute+0xd8>
	if (entry->handler) {
180038be:	b1cb      	cbz	r3, 180038f4 <execute+0x170>
		*active_cmd = *entry;
180038c0:	46ae      	mov	lr, r5
180038c2:	68a3      	ldr	r3, [r4, #8]
		*handler_lvl = *lvl;
180038c4:	f8dd 9014 	ldr.w	r9, [sp, #20]
		*active_cmd = *entry;
180038c8:	f103 0c08 	add.w	ip, r3, #8
180038cc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
180038d0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
180038d4:	f8de 3000 	ldr.w	r3, [lr]
180038d8:	f8cc 3000 	str.w	r3, [ip]
		if ((entry->subcmd == NULL)
180038dc:	68ab      	ldr	r3, [r5, #8]
180038de:	b94b      	cbnz	r3, 180038f4 <execute+0x170>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
180038e0:	7c6b      	ldrb	r3, [r5, #17]
180038e2:	2bfe      	cmp	r3, #254	; 0xfe
			*args_left = entry->args.mandatory - 1;
180038e4:	bf01      	itttt	eq
180038e6:	f895 8010 	ldrbeq.w	r8, [r5, #16]
			*lvl = *lvl + 1;
180038ea:	f109 0301 	addeq.w	r3, r9, #1
			*args_left = entry->args.mandatory - 1;
180038ee:	f108 38ff 	addeq.w	r8, r8, #4294967295
			*lvl = *lvl + 1;
180038f2:	9305      	streq	r3, [sp, #20]
	if (entry->help) {
180038f4:	f8d5 c004 	ldr.w	ip, [r5, #4]
180038f8:	f1bc 0f00 	cmp.w	ip, #0
180038fc:	d008      	beq.n	18003910 <execute+0x18c>
		*help_entry = *entry;
180038fe:	46ae      	mov	lr, r5
18003900:	ae0c      	add	r6, sp, #48	; 0x30
18003902:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
18003906:	c60f      	stmia	r6!, {r0, r1, r2, r3}
18003908:	f8de 3000 	ldr.w	r3, [lr]
1800390c:	6033      	str	r3, [r6, #0]
1800390e:	4666      	mov	r6, ip
18003910:	46ab      	mov	fp, r5
		if (args_left || (argc == 2)) {
18003912:	f1b8 0f00 	cmp.w	r8, #0
18003916:	d103      	bne.n	18003920 <execute+0x19c>
18003918:	9b06      	ldr	r3, [sp, #24]
1800391a:	2b02      	cmp	r3, #2
1800391c:	f47f af60 	bne.w	180037e0 <execute+0x5c>
			cmd_lvl++;
18003920:	9b05      	ldr	r3, [sp, #20]
18003922:	3301      	adds	r3, #1
18003924:	9305      	str	r3, [sp, #20]
18003926:	e75b      	b.n	180037e0 <execute+0x5c>
			if (cmd_lvl == 0 &&
18003928:	9b05      	ldr	r3, [sp, #20]
1800392a:	b963      	cbnz	r3, 18003946 <execute+0x1c2>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
1800392c:	68a3      	ldr	r3, [r4, #8]
1800392e:	69db      	ldr	r3, [r3, #28]
18003930:	b10b      	cbz	r3, 18003936 <execute+0x1b2>
				(!z_shell_in_select_mode(shell) ||
18003932:	68db      	ldr	r3, [r3, #12]
18003934:	b93b      	cbnz	r3, 18003946 <execute+0x1c2>
				z_shell_fprintf(shell, SHELL_ERROR,
18003936:	4b3f      	ldr	r3, [pc, #252]	; (18003a34 <execute+0x2b0>)
18003938:	2101      	movs	r1, #1
1800393a:	9300      	str	r3, [sp, #0]
1800393c:	4620      	mov	r0, r4
1800393e:	9b11      	ldr	r3, [sp, #68]	; 0x44
18003940:	4a3d      	ldr	r2, [pc, #244]	; (18003a38 <execute+0x2b4>)
18003942:	f005 fec7 	bl	180096d4 <z_shell_fprintf>
			has_last_handler = true;
18003946:	f04f 0a01 	mov.w	sl, #1
1800394a:	e7e2      	b.n	18003912 <execute+0x18e>
		&& args_left > 0) {
1800394c:	f1b8 0f00 	cmp.w	r8, #0
18003950:	f47f af56 	bne.w	18003800 <execute+0x7c>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
18003954:	9b02      	ldr	r3, [sp, #8]
18003956:	b14b      	cbz	r3, 1800396c <execute+0x1e8>
		z_shell_wildcard_finalize(shell);
18003958:	4620      	mov	r0, r4
1800395a:	f006 fa28 	bl	18009dae <z_shell_wildcard_finalize>
					shell->ctx->cmd_buff,
1800395e:	68a2      	ldr	r2, [r4, #8]
		(void)z_shell_make_argv(&cmd_lvl,
18003960:	230c      	movs	r3, #12
18003962:	3242      	adds	r2, #66	; 0x42
18003964:	a911      	add	r1, sp, #68	; 0x44
18003966:	a805      	add	r0, sp, #20
18003968:	f005 fb9e 	bl	180090a8 <z_shell_make_argv>
	argv[cmd_lvl] = NULL;
1800396c:	2200      	movs	r2, #0
1800396e:	9d05      	ldr	r5, [sp, #20]
	if (shell->ctx->active_cmd.handler == NULL) {
18003970:	68a0      	ldr	r0, [r4, #8]
	argv[cmd_lvl] = NULL;
18003972:	ab1e      	add	r3, sp, #120	; 0x78
18003974:	eb03 0385 	add.w	r3, r3, r5, lsl #2
18003978:	f843 2c34 	str.w	r2, [r3, #-52]
	if (shell->ctx->active_cmd.handler == NULL) {
1800397c:	6943      	ldr	r3, [r0, #20]
1800397e:	b973      	cbnz	r3, 1800399e <execute+0x21a>
			if (help_entry->help == NULL) {
18003980:	2e00      	cmp	r6, #0
18003982:	f43f af48 	beq.w	18003816 <execute+0x92>
			if (help_entry->help != shell->ctx->active_cmd.help) {
18003986:	68c3      	ldr	r3, [r0, #12]
18003988:	42b3      	cmp	r3, r6
1800398a:	f43f af61 	beq.w	18003850 <execute+0xcc>
				shell->ctx->active_cmd = *help_entry;
1800398e:	960d      	str	r6, [sp, #52]	; 0x34
18003990:	f100 0508 	add.w	r5, r0, #8
18003994:	e757      	b.n	18003846 <execute+0xc2>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
18003996:	9b05      	ldr	r3, [sp, #20]
18003998:	2b0b      	cmp	r3, #11
1800399a:	d9db      	bls.n	18003954 <execute+0x1d0>
1800399c:	e728      	b.n	180037f0 <execute+0x6c>
	if (shell->ctx->active_cmd.args.mandatory) {
1800399e:	7e03      	ldrb	r3, [r0, #24]
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
180039a0:	eba5 0509 	sub.w	r5, r5, r9
	if (shell->ctx->active_cmd.args.mandatory) {
180039a4:	b1b3      	cbz	r3, 180039d4 <execute+0x250>
				UINT16_MAX : opt8;
180039a6:	f64f 72ff 	movw	r2, #65535	; 0xffff
		uint8_t opt8 = shell->ctx->active_cmd.args.optional;
180039aa:	7e41      	ldrb	r1, [r0, #25]
				UINT16_MAX : opt8;
180039ac:	29ff      	cmp	r1, #255	; 0xff
180039ae:	bf18      	it	ne
180039b0:	460a      	movne	r2, r1
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
180039b2:	429d      	cmp	r5, r3
180039b4:	d302      	bcc.n	180039bc <execute+0x238>
180039b6:	4413      	add	r3, r2
	if (!arg_cnt_ok) {
180039b8:	429d      	cmp	r5, r3
180039ba:	d90b      	bls.n	180039d4 <execute+0x250>
		z_shell_fprintf(shell, SHELL_ERROR,
180039bc:	6883      	ldr	r3, [r0, #8]
180039be:	2101      	movs	r1, #1
180039c0:	4620      	mov	r0, r4
180039c2:	4a1e      	ldr	r2, [pc, #120]	; (18003a3c <execute+0x2b8>)
180039c4:	f005 fe86 	bl	180096d4 <z_shell_fprintf>
			shell_internal_help_print(shell);
180039c8:	4620      	mov	r0, r4
180039ca:	f7ff fe73 	bl	180036b4 <shell_internal_help_print>
		return -EINVAL;
180039ce:	f06f 0515 	mvn.w	r5, #21
180039d2:	e722      	b.n	1800381a <execute+0x96>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, cmd_ctx, val, ret);
180039d4:	f44f 6100 	mov.w	r1, #2048	; 0x800
180039d8:	f500 7019 	add.w	r0, r0, #612	; 0x264
180039dc:	f005 f9fe 	bl	18008ddc <atomic_or>
		k_mutex_unlock(&shell->ctx->wr_mtx);
180039e0:	68a0      	ldr	r0, [r4, #8]
180039e2:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
180039e6:	f005 fa85 	bl	18008ef4 <k_mutex_unlock.isra.0>
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
180039ea:	68a3      	ldr	r3, [r4, #8]
180039ec:	aa11      	add	r2, sp, #68	; 0x44
180039ee:	4629      	mov	r1, r5
180039f0:	eb02 0289 	add.w	r2, r2, r9, lsl #2
180039f4:	4620      	mov	r0, r4
180039f6:	695b      	ldr	r3, [r3, #20]
180039f8:	4798      	blx	r3
180039fa:	4605      	mov	r5, r0
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
180039fc:	68a0      	ldr	r0, [r4, #8]
180039fe:	f04f 32ff 	mov.w	r2, #4294967295
18003a02:	f04f 33ff 	mov.w	r3, #4294967295
18003a06:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
18003a0a:	f005 fa26 	bl	18008e5a <k_mutex_lock.constprop.0.isra.0>
18003a0e:	68a0      	ldr	r0, [r4, #8]
18003a10:	f46f 6100 	mvn.w	r1, #2048	; 0x800
18003a14:	f500 7019 	add.w	r0, r0, #612	; 0x264
18003a18:	f005 f9eb 	bl	18008df2 <atomic_and>
	return ret;
18003a1c:	e6fd      	b.n	1800381a <execute+0x96>
18003a1e:	bf00      	nop
18003a20:	1800d01c 	.word	0x1800d01c
18003a24:	1800c94a 	.word	0x1800c94a
18003a28:	1800cfa7 	.word	0x1800cfa7
18003a2c:	1800cfbb 	.word	0x1800cfbb
18003a30:	1800cfd9 	.word	0x1800cfd9
18003a34:	1800d008 	.word	0x1800d008
18003a38:	1800d2cb 	.word	0x1800d2cb
18003a3c:	1800d040 	.word	0x1800d040

18003a40 <state_set.constprop.0>:
	shell->ctx->state = state;
18003a40:	2202      	movs	r2, #2
18003a42:	6883      	ldr	r3, [r0, #8]
static inline void state_set(const struct shell *shell, enum shell_state state)
18003a44:	b510      	push	{r4, lr}
	shell->ctx->state = state;
18003a46:	711a      	strb	r2, [r3, #4]
	if (state == SHELL_STATE_ACTIVE && !shell->ctx->bypass) {
18003a48:	6b9a      	ldr	r2, [r3, #56]	; 0x38
static inline void state_set(const struct shell *shell, enum shell_state state)
18003a4a:	4604      	mov	r4, r0
	if (state == SHELL_STATE_ACTIVE && !shell->ctx->bypass) {
18003a4c:	b9ba      	cbnz	r2, 18003a7e <state_set.constprop.0+0x3e>
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
18003a4e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
	shell->ctx->cmd_buff_len = 0;
18003a52:	63da      	str	r2, [r3, #60]	; 0x3c
	return sh->ctx->ctx.flags.print_noinit == 1;
18003a54:	f8d3 3264 	ldr.w	r3, [r3, #612]	; 0x264
		if (z_flag_print_noinit_get(shell)) {
18003a58:	04db      	lsls	r3, r3, #19
18003a5a:	d50b      	bpl.n	18003a74 <state_set.constprop.0+0x34>
			z_shell_fprintf(shell, SHELL_WARNING, "%s",
18003a5c:	2103      	movs	r1, #3
18003a5e:	4b08      	ldr	r3, [pc, #32]	; (18003a80 <state_set.constprop.0+0x40>)
18003a60:	4a08      	ldr	r2, [pc, #32]	; (18003a84 <state_set.constprop.0+0x44>)
18003a62:	f005 fe37 	bl	180096d4 <z_shell_fprintf>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
18003a66:	68a0      	ldr	r0, [r4, #8]
18003a68:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
18003a6c:	f500 7019 	add.w	r0, r0, #612	; 0x264
18003a70:	f005 f9bf 	bl	18008df2 <atomic_and>
		z_shell_print_prompt_and_cmd(shell);
18003a74:	4620      	mov	r0, r4
}
18003a76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_print_prompt_and_cmd(shell);
18003a7a:	f000 bdfd 	b.w	18004678 <z_shell_print_prompt_and_cmd>
}
18003a7e:	bd10      	pop	{r4, pc}
18003a80:	1800d05b 	.word	0x1800d05b
18003a84:	1800d0a2 	.word	0x1800d0a2

18003a88 <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
18003a88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18003a8c:	4604      	mov	r4, r0
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, processing, val, ret);
18003a8e:	6880      	ldr	r0, [r0, #8]
18003a90:	2101      	movs	r1, #1
18003a92:	b0ab      	sub	sp, #172	; 0xac
18003a94:	f500 7019 	add.w	r0, r0, #612	; 0x264
18003a98:	f005 f9a0 	bl	18008ddc <atomic_or>
	__ASSERT_NO_MSG(shell->ctx);

	/* atomically set the processing flag */
	z_flag_processing_set(shell, true);

	switch (shell->ctx->state) {
18003a9c:	68a3      	ldr	r3, [r4, #8]
18003a9e:	791b      	ldrb	r3, [r3, #4]
18003aa0:	2b02      	cmp	r3, #2
18003aa2:	d117      	bne.n	18003ad4 <shell_process+0x4c>
	size_t count = 0;
18003aa4:	2300      	movs	r3, #0
18003aa6:	930b      	str	r3, [sp, #44]	; 0x2c
		shell_bypass_cb_t bypass = shell->ctx->bypass;
18003aa8:	68a3      	ldr	r3, [r4, #8]
			(void)shell->iface->api->read(shell->iface, buf,
18003aaa:	6860      	ldr	r0, [r4, #4]
		shell_bypass_cb_t bypass = shell->ctx->bypass;
18003aac:	6b9e      	ldr	r6, [r3, #56]	; 0x38
			(void)shell->iface->api->read(shell->iface, buf,
18003aae:	6803      	ldr	r3, [r0, #0]
18003ab0:	691d      	ldr	r5, [r3, #16]
18003ab2:	ab0b      	add	r3, sp, #44	; 0x2c
		if (bypass) {
18003ab4:	b1c6      	cbz	r6, 18003ae8 <shell_process+0x60>
			(void)shell->iface->api->read(shell->iface, buf,
18003ab6:	2210      	movs	r2, #16
18003ab8:	a91d      	add	r1, sp, #116	; 0x74
18003aba:	47a8      	blx	r5
			if (count) {
18003abc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
18003abe:	b14a      	cbz	r2, 18003ad4 <shell_process+0x4c>
				bypass(shell, buf, count);
18003ac0:	4620      	mov	r0, r4
18003ac2:	a91d      	add	r1, sp, #116	; 0x74
18003ac4:	47b0      	blx	r6
				if (!(volatile shell_bypass_cb_t *)shell->ctx->bypass) {
18003ac6:	68a3      	ldr	r3, [r4, #8]
18003ac8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
18003aca:	2b00      	cmp	r3, #0
18003acc:	d1ec      	bne.n	18003aa8 <shell_process+0x20>
					state_set(shell, SHELL_STATE_ACTIVE);
18003ace:	4620      	mov	r0, r4
18003ad0:	f7ff ffb6 	bl	18003a40 <state_set.constprop.0>
18003ad4:	f06f 0101 	mvn.w	r1, #1
18003ad8:	68a0      	ldr	r0, [r4, #8]
18003ada:	f500 7019 	add.w	r0, r0, #612	; 0x264
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(shell, false);
}
18003ade:	b02b      	add	sp, #172	; 0xac
18003ae0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18003ae4:	f005 b985 	b.w	18008df2 <atomic_and>
		(void)shell->iface->api->read(shell->iface, &data,
18003ae8:	2201      	movs	r2, #1
18003aea:	f10d 012b 	add.w	r1, sp, #43	; 0x2b
18003aee:	47a8      	blx	r5
		if (count == 0) {
18003af0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
18003af2:	2b00      	cmp	r3, #0
18003af4:	d0ee      	beq.n	18003ad4 <shell_process+0x4c>
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
18003af6:	f99d 202b 	ldrsb.w	r2, [sp, #43]	; 0x2b
		if (ascii_filter(data) != 0) {
18003afa:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
18003afe:	2a00      	cmp	r2, #0
		switch (shell->ctx->receive_state) {
18003b00:	68a0      	ldr	r0, [r4, #8]
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
18003b02:	dbd1      	blt.n	18003aa8 <shell_process+0x20>
		switch (shell->ctx->receive_state) {
18003b04:	7942      	ldrb	r2, [r0, #5]
18003b06:	2a03      	cmp	r2, #3
18003b08:	f200 82fd 	bhi.w	18004106 <shell_process+0x67e>
18003b0c:	e8df f012 	tbh	[pc, r2, lsl #1]
18003b10:	02750004 	.word	0x02750004
18003b14:	02fb0298 	.word	0x02fb0298
	if ((data != '\r') && (data != '\n')) {
18003b18:	2b0d      	cmp	r3, #13
18003b1a:	d01a      	beq.n	18003b52 <shell_process+0xca>
18003b1c:	2b0a      	cmp	r3, #10
18003b1e:	d018      	beq.n	18003b52 <shell_process+0xca>
	sh->ctx->ctx.flags.last_nl = val;
18003b20:	f8b0 2264 	ldrh.w	r2, [r0, #612]	; 0x264
18003b24:	f36f 02ca 	bfc	r2, #3, #8
18003b28:	f8a0 2264 	strh.w	r2, [r0, #612]	; 0x264
			switch (data) {
18003b2c:	2b09      	cmp	r3, #9
18003b2e:	d04c      	beq.n	18003bca <shell_process+0x142>
18003b30:	d832      	bhi.n	18003b98 <shell_process+0x110>
18003b32:	2b00      	cmp	r3, #0
18003b34:	d0b8      	beq.n	18003aa8 <shell_process+0x20>
18003b36:	2b08      	cmp	r3, #8
18003b38:	f000 81c3 	beq.w	18003ec2 <shell_process+0x43a>
18003b3c:	f1a3 0220 	sub.w	r2, r3, #32
				if (isprint((int) data)) {
18003b40:	2a5e      	cmp	r2, #94	; 0x5e
18003b42:	f200 81ca 	bhi.w	18003eda <shell_process+0x452>
					z_flag_history_exit_set(shell, true);
18003b46:	2101      	movs	r1, #1
18003b48:	f005 f9bb 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(shell, data);
18003b4c:	f89d 102b 	ldrb.w	r1, [sp, #43]	; 0x2b
18003b50:	e0e8      	b.n	18003d24 <shell_process+0x29c>
	return sh->ctx->ctx.flags.last_nl;
18003b52:	f8d0 2264 	ldr.w	r2, [r0, #612]	; 0x264
18003b56:	f3c2 02c7 	ubfx	r2, r2, #3, #8
	if ((z_flag_last_nl_get(shell) == 0U) ||
18003b5a:	b12a      	cbz	r2, 18003b68 <shell_process+0xe0>
18003b5c:	f8d0 2264 	ldr.w	r2, [r0, #612]	; 0x264
18003b60:	f3c2 02c7 	ubfx	r2, r2, #3, #8
18003b64:	4293      	cmp	r3, r2
18003b66:	d1e1      	bne.n	18003b2c <shell_process+0xa4>
	sh->ctx->ctx.flags.last_nl = val;
18003b68:	f8b0 2264 	ldrh.w	r2, [r0, #612]	; 0x264
				if (!shell->ctx->cmd_buff_len) {
18003b6c:	8f81      	ldrh	r1, [r0, #60]	; 0x3c
18003b6e:	f363 02ca 	bfi	r2, r3, #3, #8
18003b72:	f8a0 2264 	strh.w	r2, [r0, #612]	; 0x264
18003b76:	b959      	cbnz	r1, 18003b90 <shell_process+0x108>
	z_flag_history_exit_set(shell, false);
18003b78:	f005 f9a3 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(shell->history);
18003b7c:	68e0      	ldr	r0, [r4, #12]
18003b7e:	f006 f831 	bl	18009be4 <z_shell_history_mode_exit>
					z_cursor_next_line_move(shell);
18003b82:	6960      	ldr	r0, [r4, #20]
18003b84:	f7ff fda6 	bl	180036d4 <z_cursor_next_line_move.isra.0>
		state_set(shell, SHELL_STATE_ACTIVE);
18003b88:	4620      	mov	r0, r4
18003b8a:	f7ff ff59 	bl	18003a40 <state_set.constprop.0>
		break;
18003b8e:	e78b      	b.n	18003aa8 <shell_process+0x20>
					(void)execute(shell);
18003b90:	4620      	mov	r0, r4
18003b92:	f7ff fdf7 	bl	18003784 <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
18003b96:	e7f7      	b.n	18003b88 <shell_process+0x100>
18003b98:	2b1b      	cmp	r3, #27
18003b9a:	d013      	beq.n	18003bc4 <shell_process+0x13c>
18003b9c:	2b7f      	cmp	r3, #127	; 0x7f
18003b9e:	d1cd      	bne.n	18003b3c <shell_process+0xb4>
	return sh->ctx->cfg.flags.echo == 1;
18003ba0:	f8d0 3260 	ldr.w	r3, [r0, #608]	; 0x260
				if (z_flag_echo_get(shell)) {
18003ba4:	079a      	lsls	r2, r3, #30
18003ba6:	f57f af7f 	bpl.w	18003aa8 <shell_process+0x20>
					z_flag_history_exit_set(shell, true);
18003baa:	2101      	movs	r1, #1
18003bac:	f005 f989 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
	return sh->ctx->cfg.flags.mode_delete == 1;
18003bb0:	68a3      	ldr	r3, [r4, #8]
18003bb2:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
					if (z_flag_mode_delete_get(shell)) {
18003bb6:	071b      	lsls	r3, r3, #28
18003bb8:	f100 818b 	bmi.w	18003ed2 <shell_process+0x44a>
		z_shell_op_char_delete(shell);
18003bbc:	4620      	mov	r0, r4
18003bbe:	f005 fdc9 	bl	18009754 <z_shell_op_char_delete>
		break;
18003bc2:	e771      	b.n	18003aa8 <shell_process+0x20>
	shell->ctx->receive_state = state;
18003bc4:	2301      	movs	r3, #1
18003bc6:	7143      	strb	r3, [r0, #5]
}
18003bc8:	e76e      	b.n	18003aa8 <shell_process+0x20>
	return sh->ctx->cfg.flags.echo == 1;
18003bca:	f8d0 3260 	ldr.w	r3, [r0, #608]	; 0x260
				if (z_flag_echo_get(shell) &&
18003bce:	079e      	lsls	r6, r3, #30
18003bd0:	f57f af6a 	bpl.w	18003aa8 <shell_process+0x20>
					z_flag_history_exit_set(shell, true);
18003bd4:	2101      	movs	r1, #1
18003bd6:	f005 f974 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
			shell->ctx->cmd_buff_len;
18003bda:	68a0      	ldr	r0, [r4, #8]
	if (compl_space == 0U) {
18003bdc:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
18003bde:	2bff      	cmp	r3, #255	; 0xff
18003be0:	f43f af62 	beq.w	18003aa8 <shell_process+0x20>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
18003be4:	2500      	movs	r5, #0
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
18003be6:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
18003be8:	f100 0142 	add.w	r1, r0, #66	; 0x42
18003bec:	f500 70a1 	add.w	r0, r0, #322	; 0x142
18003bf0:	f006 faaf 	bl	1800a152 <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
18003bf4:	68a2      	ldr	r2, [r4, #8]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
18003bf6:	a91d      	add	r1, sp, #116	; 0x74
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
18003bf8:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
18003bfa:	a80d      	add	r0, sp, #52	; 0x34
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
18003bfc:	4413      	add	r3, r2
18003bfe:	f883 5142 	strb.w	r5, [r3, #322]	; 0x142
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
18003c02:	f502 72a1 	add.w	r2, r2, #322	; 0x142
18003c06:	230c      	movs	r3, #12
18003c08:	f005 fa4e 	bl	180090a8 <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
18003c0c:	990d      	ldr	r1, [sp, #52]	; 0x34
18003c0e:	290c      	cmp	r1, #12
18003c10:	f63f af4a 	bhi.w	18003aa8 <shell_process+0x20>
	(*argv)[*argc] = NULL;
18003c14:	ab2a      	add	r3, sp, #168	; 0xa8
18003c16:	eb03 0381 	add.w	r3, r3, r1, lsl #2
18003c1a:	f843 5c34 	str.w	r5, [r3, #-52]
	int space = isspace((int)shell->ctx->cmd_buff[
18003c1e:	68a3      	ldr	r3, [r4, #8]
						shell->ctx->cmd_buff_pos - 1]);
18003c20:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
	int space = isspace((int)shell->ctx->cmd_buff[
18003c22:	4413      	add	r3, r2
18003c24:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
18003c28:	2b20      	cmp	r3, #32
18003c2a:	f000 826e 	beq.w	1800410a <shell_process+0x682>
18003c2e:	3b09      	subs	r3, #9
18003c30:	2b04      	cmp	r3, #4
18003c32:	f240 826a 	bls.w	1800410a <shell_process+0x682>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
18003c36:	2901      	cmp	r1, #1
18003c38:	d84f      	bhi.n	18003cda <shell_process+0x252>
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
18003c3a:	2500      	movs	r5, #0
18003c3c:	950c      	str	r5, [sp, #48]	; 0x30
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
18003c3e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
18003c40:	aa2a      	add	r2, sp, #168	; 0xa8
18003c42:	eb02 0383 	add.w	r3, r2, r3, lsl #2
18003c46:	f853 ac34 	ldr.w	sl, [r3, #-52]
	*cnt = 0;
18003c4a:	2600      	movs	r6, #0
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
18003c4c:	4650      	mov	r0, sl
18003c4e:	f005 f8f1 	bl	18008e34 <z_shell_strlen>
	size_t first = 0;
18003c52:	46b0      	mov	r8, r6
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
18003c54:	4681      	mov	r9, r0
	size_t idx = 0;
18003c56:	4637      	mov	r7, r6
	*longest = 0U;
18003c58:	9604      	str	r6, [sp, #16]
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
18003c5a:	4639      	mov	r1, r7
18003c5c:	4628      	mov	r0, r5
18003c5e:	aa18      	add	r2, sp, #96	; 0x60
18003c60:	f000 fb94 	bl	1800438c <z_shell_cmd_get>
18003c64:	4683      	mov	fp, r0
18003c66:	2800      	cmp	r0, #0
18003c68:	d144      	bne.n	18003cf4 <shell_process+0x26c>
	if (cnt == 1) {
18003c6a:	2e01      	cmp	r6, #1
18003c6c:	d163      	bne.n	18003d36 <shell_process+0x2ae>
		autocomplete(shell, cmd, argv[arg_idx], first);
18003c6e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
18003c70:	aa2a      	add	r2, sp, #168	; 0xa8
18003c72:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	uint16_t arg_len = z_shell_strlen(arg);
18003c76:	f853 0c34 	ldr.w	r0, [r3, #-52]
18003c7a:	f005 f8db 	bl	18008e34 <z_shell_strlen>
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
18003c7e:	68a2      	ldr	r2, [r4, #8]
	uint16_t arg_len = z_shell_strlen(arg);
18003c80:	4606      	mov	r6, r0
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
18003c82:	4641      	mov	r1, r8
18003c84:	4628      	mov	r0, r5
18003c86:	3208      	adds	r2, #8
18003c88:	f000 fb80 	bl	1800438c <z_shell_cmd_get>
18003c8c:	4605      	mov	r5, r0
	cmd_len = z_shell_strlen(match->syntax);
18003c8e:	6800      	ldr	r0, [r0, #0]
18003c90:	f005 f8d0 	bl	18008e34 <z_shell_strlen>
	if (cmd_len != arg_len) {
18003c94:	4286      	cmp	r6, r0
18003c96:	d006      	beq.n	18003ca6 <shell_process+0x21e>
		z_shell_op_completion_insert(shell,
18003c98:	6829      	ldr	r1, [r5, #0]
18003c9a:	1b82      	subs	r2, r0, r6
18003c9c:	b292      	uxth	r2, r2
18003c9e:	4620      	mov	r0, r4
18003ca0:	4431      	add	r1, r6
18003ca2:	f005 fd55 	bl	18009750 <z_shell_op_completion_insert>
	if (!isspace((int) shell->ctx->cmd_buff[
18003ca6:	68a0      	ldr	r0, [r4, #8]
					shell->ctx->cmd_buff_pos])) {
18003ca8:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
	if (!isspace((int) shell->ctx->cmd_buff[
18003caa:	4403      	add	r3, r0
18003cac:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
18003cb0:	2b20      	cmp	r3, #32
18003cb2:	d03b      	beq.n	18003d2c <shell_process+0x2a4>
18003cb4:	3b09      	subs	r3, #9
18003cb6:	2b04      	cmp	r3, #4
18003cb8:	d938      	bls.n	18003d2c <shell_process+0x2a4>
	return sh->ctx->cfg.flags.insert_mode == 1;
18003cba:	f8d0 3260 	ldr.w	r3, [r0, #608]	; 0x260
		if (z_flag_insert_mode_get(shell)) {
18003cbe:	07dd      	lsls	r5, r3, #31
18003cc0:	d52f      	bpl.n	18003d22 <shell_process+0x29a>
			z_flag_insert_mode_set(shell, false);
18003cc2:	2100      	movs	r1, #0
18003cc4:	f005 f907 	bl	18008ed6 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(shell, ' ');
18003cc8:	2120      	movs	r1, #32
18003cca:	4620      	mov	r0, r4
18003ccc:	f000 fca0 	bl	18004610 <z_shell_op_char_insert>
			z_flag_insert_mode_set(shell, true);
18003cd0:	2101      	movs	r1, #1
18003cd2:	68a0      	ldr	r0, [r4, #8]
				z_flag_insert_mode_set(shell, !status);
18003cd4:	f005 f8ff 	bl	18008ed6 <z_flag_insert_mode_set.isra.0>
				break;
18003cd8:	e6e6      	b.n	18003aa8 <shell_process+0x20>
	search_argc = space ? *argc : *argc - 1;
18003cda:	3901      	subs	r1, #1
	*cmd = z_shell_get_last_command(selected_cmd_get(shell), search_argc,
18003cdc:	2000      	movs	r0, #0
18003cde:	ab0e      	add	r3, sp, #56	; 0x38
18003ce0:	9300      	str	r3, [sp, #0]
18003ce2:	9001      	str	r0, [sp, #4]
18003ce4:	ab0c      	add	r3, sp, #48	; 0x30
18003ce6:	aa1d      	add	r2, sp, #116	; 0x74
18003ce8:	f005 fae9 	bl	180092be <z_shell_get_last_command>
	if ((*cmd == NULL) && (search_argc != 0)) {
18003cec:	4605      	mov	r5, r0
18003cee:	2800      	cmp	r0, #0
18003cf0:	d1a5      	bne.n	18003c3e <shell_process+0x1b6>
18003cf2:	e6d9      	b.n	18003aa8 <shell_process+0x20>
	return (strncmp(candidate, str, len) == 0) ? true : false;
18003cf4:	464a      	mov	r2, r9
18003cf6:	4651      	mov	r1, sl
18003cf8:	f8db 0000 	ldr.w	r0, [fp]
18003cfc:	f006 f9ef 	bl	1800a0de <strncmp>
		if (is_candidate) {
18003d00:	b968      	cbnz	r0, 18003d1e <shell_process+0x296>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
18003d02:	f8db 0000 	ldr.w	r0, [fp]
18003d06:	f006 f9ce 	bl	1800a0a6 <strlen>
18003d0a:	9b04      	ldr	r3, [sp, #16]
18003d0c:	4283      	cmp	r3, r0
18003d0e:	bf38      	it	cc
18003d10:	4603      	movcc	r3, r0
18003d12:	b29b      	uxth	r3, r3
				*first_idx = idx;
18003d14:	2e00      	cmp	r6, #0
18003d16:	bf08      	it	eq
18003d18:	46b8      	moveq	r8, r7
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
18003d1a:	9304      	str	r3, [sp, #16]
			(*cnt)++;
18003d1c:	3601      	adds	r6, #1
		idx++;
18003d1e:	3701      	adds	r7, #1
18003d20:	e79b      	b.n	18003c5a <shell_process+0x1d2>
			z_shell_op_char_insert(shell, ' ');
18003d22:	2120      	movs	r1, #32
					z_shell_op_char_insert(shell, data);
18003d24:	4620      	mov	r0, r4
18003d26:	f000 fc73 	bl	18004610 <z_shell_op_char_insert>
18003d2a:	e6bd      	b.n	18003aa8 <shell_process+0x20>
		z_shell_op_cursor_move(shell, 1);
18003d2c:	2101      	movs	r1, #1
18003d2e:	4620      	mov	r0, r4
18003d30:	f005 fbc3 	bl	180094ba <z_shell_op_cursor_move>
18003d34:	e6b8      	b.n	18003aa8 <shell_process+0x20>
	} else if (cnt > 1) {
18003d36:	f67f aeb7 	bls.w	18003aa8 <shell_process+0x20>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
18003d3a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
18003d3c:	aa2a      	add	r2, sp, #168	; 0xa8
18003d3e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
18003d42:	f853 ac34 	ldr.w	sl, [r3, #-52]
	size_t str_len = z_shell_strlen(str);
18003d46:	4650      	mov	r0, sl
18003d48:	f005 f874 	bl	18008e34 <z_shell_strlen>
		shell->ctx->vt100_ctx.printed_cmd = 0;
18003d4c:	68a3      	ldr	r3, [r4, #8]
	size_t str_len = z_shell_strlen(str);
18003d4e:	9006      	str	r0, [sp, #24]
		shell->ctx->vt100_ctx.printed_cmd = 0;
18003d50:	f8a3 b030 	strh.w	fp, [r3, #48]	; 0x30
	longest_option += z_shell_strlen(tab);
18003d54:	f8df b2d0 	ldr.w	fp, [pc, #720]	; 18004028 <shell_process+0x5a0>
		shell->ctx->vt100_ctx.printed_cmd = 0;
18003d58:	9605      	str	r6, [sp, #20]
18003d5a:	f8cd 800c 	str.w	r8, [sp, #12]
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
18003d5e:	68a2      	ldr	r2, [r4, #8]
18003d60:	4628      	mov	r0, r5
18003d62:	9903      	ldr	r1, [sp, #12]
18003d64:	3208      	adds	r2, #8
18003d66:	f000 fb11 	bl	1800438c <z_shell_cmd_get>
		idx++;
18003d6a:	9b03      	ldr	r3, [sp, #12]
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
18003d6c:	4607      	mov	r7, r0
		idx++;
18003d6e:	3301      	adds	r3, #1
18003d70:	9303      	str	r3, [sp, #12]
		if (str && match->syntax &&
18003d72:	f1ba 0f00 	cmp.w	sl, #0
18003d76:	d151      	bne.n	18003e1c <shell_process+0x394>
		tab_item_print(shell, match->syntax, longest);
18003d78:	683f      	ldr	r7, [r7, #0]
	if (option == NULL) {
18003d7a:	2f00      	cmp	r7, #0
18003d7c:	d158      	bne.n	18003e30 <shell_process+0x3a8>
		shell->ctx->vt100_ctx.printed_cmd = 0;
18003d7e:	68a2      	ldr	r2, [r4, #8]
18003d80:	8617      	strh	r7, [r2, #48]	; 0x30
	while (cnt) {
18003d82:	9b05      	ldr	r3, [sp, #20]
18003d84:	3b01      	subs	r3, #1
18003d86:	9305      	str	r3, [sp, #20]
18003d88:	d1e9      	bne.n	18003d5e <shell_process+0x2d6>
	z_cursor_next_line_move(shell);
18003d8a:	6960      	ldr	r0, [r4, #20]
18003d8c:	f7ff fca2 	bl	180036d4 <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(shell);
18003d90:	4620      	mov	r0, r4
18003d92:	f000 fc71 	bl	18004678 <z_shell_print_prompt_and_cmd>
		partial_autocomplete(shell, cmd, argv[arg_idx], first, cnt);
18003d96:	9b0c      	ldr	r3, [sp, #48]	; 0x30
18003d98:	aa2a      	add	r2, sp, #168	; 0xa8
18003d9a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	uint16_t arg_len = z_shell_strlen(arg);
18003d9e:	f853 0c34 	ldr.w	r0, [r3, #-52]
18003da2:	f005 f847 	bl	18008e34 <z_shell_strlen>
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
18003da6:	4641      	mov	r1, r8
18003da8:	aa13      	add	r2, sp, #76	; 0x4c
	uint16_t arg_len = z_shell_strlen(arg);
18003daa:	4607      	mov	r7, r0
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
18003dac:	4628      	mov	r0, r5
18003dae:	f000 faed 	bl	1800438c <z_shell_cmd_get>
	size_t idx = first + 1;
18003db2:	f108 0901 	add.w	r9, r8, #1
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
18003db6:	4680      	mov	r8, r0
	strncpy(shell->ctx->temp_buff, match->syntax,
18003db8:	68a0      	ldr	r0, [r4, #8]
18003dba:	f8d8 1000 	ldr.w	r1, [r8]
18003dbe:	22ff      	movs	r2, #255	; 0xff
18003dc0:	f500 70a1 	add.w	r0, r0, #322	; 0x142
18003dc4:	f006 f94f 	bl	1800a066 <strncpy>
	*str = match->syntax;
18003dc8:	f8d8 a000 	ldr.w	sl, [r8]
	uint16_t common = UINT16_MAX;
18003dcc:	f64f 78ff 	movw	r8, #65535	; 0xffff
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
18003dd0:	4649      	mov	r1, r9
18003dd2:	4628      	mov	r0, r5
18003dd4:	aa18      	add	r2, sp, #96	; 0x60
18003dd6:	f109 0b01 	add.w	fp, r9, #1
18003dda:	f000 fad7 	bl	1800438c <z_shell_cmd_get>
		if (match2 == NULL) {
18003dde:	2800      	cmp	r0, #0
18003de0:	d062      	beq.n	18003ea8 <shell_process+0x420>
	size_t common = 0;
18003de2:	2200      	movs	r2, #0
18003de4:	68a3      	ldr	r3, [r4, #8]
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
18003de6:	6800      	ldr	r0, [r0, #0]
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
18003de8:	f503 73a1 	add.w	r3, r3, #322	; 0x142
18003dec:	f813 cb01 	ldrb.w	ip, [r3], #1
18003df0:	5c81      	ldrb	r1, [r0, r2]
18003df2:	4561      	cmp	r1, ip
18003df4:	d105      	bne.n	18003e02 <shell_process+0x37a>
18003df6:	b121      	cbz	r1, 18003e02 <shell_process+0x37a>
18003df8:	f64f 71ff 	movw	r1, #65535	; 0xffff
		common++;
18003dfc:	3201      	adds	r2, #1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
18003dfe:	428a      	cmp	r2, r1
18003e00:	d1f4      	bne.n	18003dec <shell_process+0x364>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
18003e02:	b10f      	cbz	r7, 18003e08 <shell_process+0x380>
18003e04:	42ba      	cmp	r2, r7
18003e06:	db07      	blt.n	18003e18 <shell_process+0x390>
			common = (curr_common < common) ? curr_common : common;
18003e08:	4542      	cmp	r2, r8
18003e0a:	bfa8      	it	ge
18003e0c:	4642      	movge	r2, r8
			--cnt;
18003e0e:	3e01      	subs	r6, #1
	while (cnt > 1) {
18003e10:	2e01      	cmp	r6, #1
			common = (curr_common < common) ? curr_common : common;
18003e12:	fa1f f882 	uxth.w	r8, r2
	while (cnt > 1) {
18003e16:	d047      	beq.n	18003ea8 <shell_process+0x420>
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
18003e18:	46d9      	mov	r9, fp
18003e1a:	e7d9      	b.n	18003dd0 <shell_process+0x348>
		if (str && match->syntax &&
18003e1c:	6800      	ldr	r0, [r0, #0]
18003e1e:	2800      	cmp	r0, #0
18003e20:	d0aa      	beq.n	18003d78 <shell_process+0x2f0>
	return (strncmp(candidate, str, len) == 0) ? true : false;
18003e22:	4651      	mov	r1, sl
18003e24:	9a06      	ldr	r2, [sp, #24]
18003e26:	f006 f95a 	bl	1800a0de <strncmp>
		if (str && match->syntax &&
18003e2a:	2800      	cmp	r0, #0
18003e2c:	d0a4      	beq.n	18003d78 <shell_process+0x2f0>
18003e2e:	e796      	b.n	18003d5e <shell_process+0x2d6>
	longest_option += z_shell_strlen(tab);
18003e30:	4658      	mov	r0, fp
18003e32:	f004 ffff 	bl	18008e34 <z_shell_strlen>
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
18003e36:	68a1      	ldr	r1, [r4, #8]
	longest_option += z_shell_strlen(tab);
18003e38:	9b04      	ldr	r3, [sp, #16]
18003e3a:	18c2      	adds	r2, r0, r3
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
18003e3c:	8d4b      	ldrh	r3, [r1, #42]	; 0x2a
	longest_option += z_shell_strlen(tab);
18003e3e:	b292      	uxth	r2, r2
			- z_shell_strlen(tab)) / longest_option;
18003e40:	4658      	mov	r0, fp
	longest_option += z_shell_strlen(tab);
18003e42:	9209      	str	r2, [sp, #36]	; 0x24
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
18003e44:	9308      	str	r3, [sp, #32]
			- z_shell_strlen(tab)) / longest_option;
18003e46:	f004 fff5 	bl	18008e34 <z_shell_strlen>
18003e4a:	9007      	str	r0, [sp, #28]
	diff = longest_option - z_shell_strlen(option);
18003e4c:	4638      	mov	r0, r7
18003e4e:	f004 fff1 	bl	18008e34 <z_shell_strlen>
			- z_shell_strlen(tab)) / longest_option;
18003e52:	e9dd 1307 	ldrd	r1, r3, [sp, #28]
	diff = longest_option - z_shell_strlen(option);
18003e56:	9a09      	ldr	r2, [sp, #36]	; 0x24
			- z_shell_strlen(tab)) / longest_option;
18003e58:	1a59      	subs	r1, r3, r1
	diff = longest_option - z_shell_strlen(option);
18003e5a:	eba2 0900 	sub.w	r9, r2, r0
			- z_shell_strlen(tab)) / longest_option;
18003e5e:	fb91 f2f2 	sdiv	r2, r1, r2
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
18003e62:	68a0      	ldr	r0, [r4, #8]
18003e64:	b292      	uxth	r2, r2
18003e66:	f8b0 c030 	ldrh.w	ip, [r0, #48]	; 0x30
	diff = longest_option - z_shell_strlen(option);
18003e6a:	fa1f f989 	uxth.w	r9, r9
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
18003e6e:	fbbc f1f2 	udiv	r1, ip, r2
18003e72:	fb02 c211 	mls	r2, r2, r1, ip
18003e76:	f10c 0e01 	add.w	lr, ip, #1
18003e7a:	b292      	uxth	r2, r2
18003e7c:	f8a0 e030 	strh.w	lr, [r0, #48]	; 0x30
18003e80:	b95a      	cbnz	r2, 18003e9a <shell_process+0x412>
		z_shell_fprintf(shell, SHELL_OPTION, "\n%s%s", tab, option);
18003e82:	465b      	mov	r3, fp
18003e84:	2106      	movs	r1, #6
18003e86:	4620      	mov	r0, r4
18003e88:	4a68      	ldr	r2, [pc, #416]	; (1800402c <shell_process+0x5a4>)
18003e8a:	9700      	str	r7, [sp, #0]
18003e8c:	f005 fc22 	bl	180096d4 <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(shell, diff);
18003e90:	4649      	mov	r1, r9
18003e92:	4620      	mov	r0, r4
18003e94:	f000 fac8 	bl	18004428 <z_shell_op_cursor_horiz_move>
18003e98:	e773      	b.n	18003d82 <shell_process+0x2fa>
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
18003e9a:	463b      	mov	r3, r7
18003e9c:	2106      	movs	r1, #6
18003e9e:	4620      	mov	r0, r4
18003ea0:	4a63      	ldr	r2, [pc, #396]	; (18004030 <shell_process+0x5a8>)
18003ea2:	f005 fc17 	bl	180096d4 <z_shell_fprintf>
18003ea6:	e7f3      	b.n	18003e90 <shell_process+0x408>
	if (common) {
18003ea8:	f1b8 0f00 	cmp.w	r8, #0
18003eac:	f43f adfc 	beq.w	18003aa8 <shell_process+0x20>
		z_shell_op_completion_insert(shell, &completion[arg_len],
18003eb0:	eba8 0207 	sub.w	r2, r8, r7
18003eb4:	4620      	mov	r0, r4
18003eb6:	b292      	uxth	r2, r2
18003eb8:	eb0a 0107 	add.w	r1, sl, r7
18003ebc:	f005 fc48 	bl	18009750 <z_shell_op_completion_insert>
18003ec0:	e5f2      	b.n	18003aa8 <shell_process+0x20>
	return sh->ctx->cfg.flags.echo == 1;
18003ec2:	f8d0 3260 	ldr.w	r3, [r0, #608]	; 0x260
				if (z_flag_echo_get(shell)) {
18003ec6:	0799      	lsls	r1, r3, #30
18003ec8:	f57f adee 	bpl.w	18003aa8 <shell_process+0x20>
					z_flag_history_exit_set(shell, true);
18003ecc:	2101      	movs	r1, #1
18003ece:	f004 fff8 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
						z_shell_op_char_backspace(shell);
18003ed2:	4620      	mov	r0, r4
18003ed4:	f005 fc59 	bl	1800978a <z_shell_op_char_backspace>
18003ed8:	e5e6      	b.n	18003aa8 <shell_process+0x20>
18003eda:	f8d0 2260 	ldr.w	r2, [r0, #608]	; 0x260
				} else if (z_flag_echo_get(shell)) {
18003ede:	0797      	lsls	r7, r2, #30
18003ee0:	f57f ade2 	bpl.w	18003aa8 <shell_process+0x20>
	switch (data) {
18003ee4:	3b01      	subs	r3, #1
18003ee6:	2b16      	cmp	r3, #22
18003ee8:	f63f adde 	bhi.w	18003aa8 <shell_process+0x20>
18003eec:	a201      	add	r2, pc, #4	; (adr r2, 18003ef4 <shell_process+0x46c>)
18003eee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
18003ef2:	bf00      	nop
18003ef4:	180040dd 	.word	0x180040dd
18003ef8:	18003f51 	.word	0x18003f51
18003efc:	18003f59 	.word	0x18003f59
18003f00:	18003bbd 	.word	0x18003bbd
18003f04:	180040d1 	.word	0x180040d1
18003f08:	18003f77 	.word	0x18003f77
18003f0c:	18003aa9 	.word	0x18003aa9
18003f10:	18003aa9 	.word	0x18003aa9
18003f14:	18003aa9 	.word	0x18003aa9
18003f18:	18003aa9 	.word	0x18003aa9
18003f1c:	18003f7f 	.word	0x18003f7f
18003f20:	18003f87 	.word	0x18003f87
18003f24:	18003aa9 	.word	0x18003aa9
18003f28:	18003fb1 	.word	0x18003fb1
18003f2c:	18003aa9 	.word	0x18003aa9
18003f30:	18003fbb 	.word	0x18003fbb
18003f34:	18003aa9 	.word	0x18003aa9
18003f38:	18003aa9 	.word	0x18003aa9
18003f3c:	18003aa9 	.word	0x18003aa9
18003f40:	18003aa9 	.word	0x18003aa9
18003f44:	18003fbf 	.word	0x18003fbf
18003f48:	18003aa9 	.word	0x18003aa9
18003f4c:	18003feb 	.word	0x18003feb
		z_shell_op_left_arrow(shell);
18003f50:	4620      	mov	r0, r4
18003f52:	f005 fb1e 	bl	18009592 <z_shell_op_left_arrow>
		break;
18003f56:	e5a7      	b.n	18003aa8 <shell_process+0x20>
		z_shell_op_cursor_end_move(shell);
18003f58:	4620      	mov	r0, r4
18003f5a:	f005 fb13 	bl	18009584 <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(shell)) {
18003f5e:	4620      	mov	r0, r4
18003f60:	f005 fa64 	bl	1800942c <z_shell_cursor_in_empty_line>
18003f64:	b910      	cbnz	r0, 18003f6c <shell_process+0x4e4>
			z_cursor_next_line_move(shell);
18003f66:	6960      	ldr	r0, [r4, #20]
18003f68:	f7ff fbb4 	bl	180036d4 <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(shell, true);
18003f6c:	2101      	movs	r1, #1
18003f6e:	68a0      	ldr	r0, [r4, #8]
18003f70:	f004 ffa7 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
18003f74:	e608      	b.n	18003b88 <shell_process+0x100>
		z_shell_op_right_arrow(shell);
18003f76:	4620      	mov	r0, r4
18003f78:	f005 fb13 	bl	180095a2 <z_shell_op_right_arrow>
		break;
18003f7c:	e594      	b.n	18003aa8 <shell_process+0x20>
		z_shell_op_delete_from_cursor(shell);
18003f7e:	4620      	mov	r0, r4
18003f80:	f005 fb18 	bl	180095b4 <z_shell_op_delete_from_cursor>
		break;
18003f84:	e590      	b.n	18003aa8 <shell_process+0x20>
	return sh->ctx->cfg.flags.use_vt100 == 1;
18003f86:	f8d0 3260 	ldr.w	r3, [r0, #608]	; 0x260
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
18003f8a:	069e      	lsls	r6, r3, #26
18003f8c:	d503      	bpl.n	18003f96 <shell_process+0x50e>
18003f8e:	4929      	ldr	r1, [pc, #164]	; (18004034 <shell_process+0x5ac>)
18003f90:	6960      	ldr	r0, [r4, #20]
18003f92:	f004 ff55 	bl	18008e40 <z_shell_raw_fprintf>
18003f96:	68a3      	ldr	r3, [r4, #8]
18003f98:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
18003f9c:	069d      	lsls	r5, r3, #26
18003f9e:	d503      	bpl.n	18003fa8 <shell_process+0x520>
18003fa0:	4925      	ldr	r1, [pc, #148]	; (18004038 <shell_process+0x5b0>)
18003fa2:	6960      	ldr	r0, [r4, #20]
18003fa4:	f004 ff4c 	bl	18008e40 <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(shell);
18003fa8:	4620      	mov	r0, r4
18003faa:	f000 fb65 	bl	18004678 <z_shell_print_prompt_and_cmd>
		break;
18003fae:	e57b      	b.n	18003aa8 <shell_process+0x20>
		history_handle(shell, false);
18003fb0:	2100      	movs	r1, #0
		history_handle(shell, true);
18003fb2:	4620      	mov	r0, r4
18003fb4:	f7ff fb94 	bl	180036e0 <history_handle>
		break;
18003fb8:	e576      	b.n	18003aa8 <shell_process+0x20>
		history_handle(shell, true);
18003fba:	2101      	movs	r1, #1
18003fbc:	e7f9      	b.n	18003fb2 <shell_process+0x52a>
		z_shell_op_cursor_home_move(shell);
18003fbe:	4620      	mov	r0, r4
18003fc0:	f005 fada 	bl	18009578 <z_shell_op_cursor_home_move>
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
18003fc4:	2300      	movs	r3, #0
18003fc6:	68a0      	ldr	r0, [r4, #8]
		z_flag_history_exit_set(shell, true);
18003fc8:	2101      	movs	r1, #1
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
18003fca:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
	shell->ctx->cmd_buff_len = 0;
18003fce:	63c3      	str	r3, [r0, #60]	; 0x3c
		z_flag_history_exit_set(shell, true);
18003fd0:	f004 ff77 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
18003fd4:	68a3      	ldr	r3, [r4, #8]
18003fd6:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
18003fda:	0698      	lsls	r0, r3, #26
18003fdc:	f57f ad64 	bpl.w	18003aa8 <shell_process+0x20>
18003fe0:	4916      	ldr	r1, [pc, #88]	; (1800403c <shell_process+0x5b4>)
18003fe2:	6960      	ldr	r0, [r4, #20]
18003fe4:	f004 ff2c 	bl	18008e40 <z_shell_raw_fprintf>
18003fe8:	e55e      	b.n	18003aa8 <shell_process+0x20>
		z_shell_op_word_remove(shell);
18003fea:	4620      	mov	r0, r4
18003fec:	f000 fa78 	bl	180044e0 <z_shell_op_word_remove>
		z_flag_history_exit_set(shell, true);
18003ff0:	2101      	movs	r1, #1
18003ff2:	68a0      	ldr	r0, [r4, #8]
18003ff4:	f004 ff65 	bl	18008ec2 <z_flag_history_exit_set.isra.0>
		break;
18003ff8:	e556      	b.n	18003aa8 <shell_process+0x20>
			if (data == '[') {
18003ffa:	2b5b      	cmp	r3, #91	; 0x5b
18003ffc:	d101      	bne.n	18004002 <shell_process+0x57a>
	shell->ctx->receive_state = state;
18003ffe:	2302      	movs	r3, #2
18004000:	e5e1      	b.n	18003bc6 <shell_process+0x13e>
	return sh->ctx->cfg.flags.echo == 1;
18004002:	f8d0 2260 	ldr.w	r2, [r0, #608]	; 0x260
			} else if (z_flag_echo_get(shell)) {
18004006:	0791      	lsls	r1, r2, #30
18004008:	d506      	bpl.n	18004018 <shell_process+0x590>
	if (data == SHELL_VT100_ASCII_ALT_B) {
1800400a:	2b62      	cmp	r3, #98	; 0x62
1800400c:	d108      	bne.n	18004020 <shell_process+0x598>
		z_shell_op_cursor_word_move(shell, -1);
1800400e:	f04f 31ff 	mov.w	r1, #4294967295
		z_shell_op_cursor_word_move(shell, 1);
18004012:	4620      	mov	r0, r4
18004014:	f005 fa75 	bl	18009502 <z_shell_op_cursor_word_move>
	shell->ctx->receive_state = state;
18004018:	2200      	movs	r2, #0
1800401a:	68a3      	ldr	r3, [r4, #8]
1800401c:	715a      	strb	r2, [r3, #5]
}
1800401e:	e543      	b.n	18003aa8 <shell_process+0x20>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
18004020:	2b66      	cmp	r3, #102	; 0x66
18004022:	d1f9      	bne.n	18004018 <shell_process+0x590>
		z_shell_op_cursor_word_move(shell, 1);
18004024:	2101      	movs	r1, #1
18004026:	e7f4      	b.n	18004012 <shell_process+0x58a>
18004028:	1800c78f 	.word	0x1800c78f
1800402c:	1800d09f 	.word	0x1800d09f
18004030:	1800d0a2 	.word	0x1800d0a2
18004034:	1800b4ad 	.word	0x1800b4ad
18004038:	1800b4b2 	.word	0x1800b4b2
1800403c:	1800b4a8 	.word	0x1800b4a8
	shell->ctx->receive_state = state;
18004040:	2200      	movs	r2, #0
18004042:	7142      	strb	r2, [r0, #5]
18004044:	f8d0 2260 	ldr.w	r2, [r0, #608]	; 0x260
			if (!z_flag_echo_get(shell)) {
18004048:	0792      	lsls	r2, r2, #30
1800404a:	f57f ad2d 	bpl.w	18003aa8 <shell_process+0x20>
			switch (data) {
1800404e:	3b31      	subs	r3, #49	; 0x31
18004050:	2b1b      	cmp	r3, #27
18004052:	f63f ad29 	bhi.w	18003aa8 <shell_process+0x20>
18004056:	a201      	add	r2, pc, #4	; (adr r2, 1800405c <shell_process+0x5d4>)
18004058:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
1800405c:	180040d9 	.word	0x180040d9
18004060:	180040e5 	.word	0x180040e5
18004064:	180040f7 	.word	0x180040f7
18004068:	180040cd 	.word	0x180040cd
1800406c:	18003aa9 	.word	0x18003aa9
18004070:	18003aa9 	.word	0x18003aa9
18004074:	18003aa9 	.word	0x18003aa9
18004078:	18003aa9 	.word	0x18003aa9
1800407c:	18003aa9 	.word	0x18003aa9
18004080:	18003aa9 	.word	0x18003aa9
18004084:	18003aa9 	.word	0x18003aa9
18004088:	18003aa9 	.word	0x18003aa9
1800408c:	18003aa9 	.word	0x18003aa9
18004090:	18003aa9 	.word	0x18003aa9
18004094:	18003aa9 	.word	0x18003aa9
18004098:	18003aa9 	.word	0x18003aa9
1800409c:	18003fbb 	.word	0x18003fbb
180040a0:	18003fb1 	.word	0x18003fb1
180040a4:	18003f77 	.word	0x18003f77
180040a8:	18003f51 	.word	0x18003f51
180040ac:	18003aa9 	.word	0x18003aa9
180040b0:	180040d1 	.word	0x180040d1
180040b4:	18003aa9 	.word	0x18003aa9
180040b8:	180040dd 	.word	0x180040dd
180040bc:	18003aa9 	.word	0x18003aa9
180040c0:	18003aa9 	.word	0x18003aa9
180040c4:	18003aa9 	.word	0x18003aa9
180040c8:	180040e9 	.word	0x180040e9
	shell->ctx->receive_state = state;
180040cc:	2303      	movs	r3, #3
180040ce:	7143      	strb	r3, [r0, #5]
		z_shell_op_cursor_end_move(shell);
180040d0:	4620      	mov	r0, r4
180040d2:	f005 fa57 	bl	18009584 <z_shell_op_cursor_end_move>
		break;
180040d6:	e4e7      	b.n	18003aa8 <shell_process+0x20>
	shell->ctx->receive_state = state;
180040d8:	2303      	movs	r3, #3
180040da:	7143      	strb	r3, [r0, #5]
		z_shell_op_cursor_home_move(shell);
180040dc:	4620      	mov	r0, r4
180040de:	f005 fa4b 	bl	18009578 <z_shell_op_cursor_home_move>
		break;
180040e2:	e4e1      	b.n	18003aa8 <shell_process+0x20>
	shell->ctx->receive_state = state;
180040e4:	2303      	movs	r3, #3
180040e6:	7143      	strb	r3, [r0, #5]
	return sh->ctx->cfg.flags.insert_mode == 1;
180040e8:	f8d0 1260 	ldr.w	r1, [r0, #608]	; 0x260
180040ec:	f001 0101 	and.w	r1, r1, #1
				z_flag_insert_mode_set(shell, !status);
180040f0:	f081 0101 	eor.w	r1, r1, #1
180040f4:	e5ee      	b.n	18003cd4 <shell_process+0x24c>
	shell->ctx->receive_state = state;
180040f6:	2303      	movs	r3, #3
180040f8:	7143      	strb	r3, [r0, #5]
	return sh->ctx->cfg.flags.echo == 1;
180040fa:	f8d0 3260 	ldr.w	r3, [r0, #608]	; 0x260
				if (z_flag_echo_get(shell)) {
180040fe:	079b      	lsls	r3, r3, #30
18004100:	f57f acd2 	bpl.w	18003aa8 <shell_process+0x20>
18004104:	e55a      	b.n	18003bbc <shell_process+0x134>
	shell->ctx->receive_state = state;
18004106:	2300      	movs	r3, #0
18004108:	e55d      	b.n	18003bc6 <shell_process+0x13e>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
1800410a:	2900      	cmp	r1, #0
1800410c:	f43f ad95 	beq.w	18003c3a <shell_process+0x1b2>
18004110:	e5e4      	b.n	18003cdc <shell_process+0x254>
18004112:	bf00      	nop

18004114 <shell_init>:
{
18004114:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
18004118:	4604      	mov	r4, r0
	if (shell->ctx->tid) {
1800411a:	6880      	ldr	r0, [r0, #8]
{
1800411c:	4688      	mov	r8, r1
	if (shell->ctx->tid) {
1800411e:	f8d0 130c 	ldr.w	r1, [r0, #780]	; 0x30c
{
18004122:	4615      	mov	r5, r2
18004124:	461f      	mov	r7, r3
18004126:	b089      	sub	sp, #36	; 0x24
	if (shell->ctx->tid) {
18004128:	2900      	cmp	r1, #0
1800412a:	d161      	bne.n	180041f0 <shell_init+0xdc>
	memset(sh->ctx, 0, sizeof(*sh->ctx));
1800412c:	f44f 7244 	mov.w	r2, #784	; 0x310
18004130:	f006 f81a 	bl	1800a168 <memset>
	sh->ctx->prompt = sh->default_prompt;
18004134:	68a3      	ldr	r3, [r4, #8]
18004136:	6822      	ldr	r2, [r4, #0]
	z_shell_history_init(shell->history);
18004138:	68e0      	ldr	r0, [r4, #12]
	sh->ctx->prompt = sh->default_prompt;
1800413a:	601a      	str	r2, [r3, #0]
	z_shell_history_init(shell->history);
1800413c:	f005 fdf8 	bl	18009d30 <z_shell_history_init>
	k_mutex_init(&sh->ctx->wr_mtx);
18004140:	68a0      	ldr	r0, [r4, #8]
18004142:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
	return z_impl_k_mutex_init(mutex);
18004146:	f006 fcc8 	bl	1800aada <z_impl_k_mutex_init>
1800414a:	f44f 792a 	mov.w	r9, #680	; 0x2a8
1800414e:	f44f 761a 	mov.w	r6, #616	; 0x268
		k_poll_signal_init(&sh->ctx->signals[i]);
18004152:	68a0      	ldr	r0, [r4, #8]
18004154:	4430      	add	r0, r6
		arch_syscall_invoke1(*(uintptr_t *)&sig, K_SYSCALL_K_POLL_SIGNAL_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_init(sig);
18004156:	f006 ff77 	bl	1800b048 <z_impl_k_poll_signal_init>
		k_poll_event_init(&sh->ctx->events[i],
1800415a:	68a0      	ldr	r0, [r4, #8]
1800415c:	2200      	movs	r2, #0
1800415e:	1983      	adds	r3, r0, r6
18004160:	2101      	movs	r1, #1
18004162:	4448      	add	r0, r9
	for (int i = 0; i < SHELL_SIGNALS; i++) {
18004164:	3610      	adds	r6, #16
		k_poll_event_init(&sh->ctx->events[i],
18004166:	f006 ff52 	bl	1800b00e <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
1800416a:	f5b6 7f2a 	cmp.w	r6, #680	; 0x2a8
1800416e:	f109 0914 	add.w	r9, r9, #20
18004172:	d1ee      	bne.n	18004152 <shell_init+0x3e>
		sh->stats->log_lost_cnt = 0;
18004174:	2600      	movs	r6, #0
18004176:	69a3      	ldr	r3, [r4, #24]
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, tx_rdy, val, ret);
18004178:	68a0      	ldr	r0, [r4, #8]
1800417a:	2102      	movs	r1, #2
1800417c:	601e      	str	r6, [r3, #0]
1800417e:	f500 7019 	add.w	r0, r0, #612	; 0x264
18004182:	f004 fe2b 	bl	18008ddc <atomic_or>
	sh->ctx->vt100_ctx.cons.terminal_wid =
18004186:	68a3      	ldr	r3, [r4, #8]
	sh->ctx->vt100_ctx.cons.terminal_hei =
18004188:	4a1b      	ldr	r2, [pc, #108]	; (180041f8 <shell_init+0xe4>)
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
1800418a:	6818      	ldr	r0, [r3, #0]
	sh->ctx->vt100_ctx.cons.terminal_hei =
1800418c:	629a      	str	r2, [r3, #40]	; 0x28
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
1800418e:	f004 fe51 	bl	18008e34 <z_shell_strlen>
18004192:	68a3      	ldr	r3, [r4, #8]
	sh->ctx->cfg.flags = cfg_flags;
18004194:	f366 0582 	bfi	r5, r6, #2, #1
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
18004198:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
	int ret = sh->iface->api->init(sh->iface, transport_config,
1800419c:	6860      	ldr	r0, [r4, #4]
	sh->ctx->cfg.flags = cfg_flags;
1800419e:	f8c3 5260 	str.w	r5, [r3, #608]	; 0x260
	int ret = sh->iface->api->init(sh->iface, transport_config,
180041a2:	6803      	ldr	r3, [r0, #0]
180041a4:	4641      	mov	r1, r8
180041a6:	681d      	ldr	r5, [r3, #0]
180041a8:	4a14      	ldr	r2, [pc, #80]	; (180041fc <shell_init+0xe8>)
180041aa:	4623      	mov	r3, r4
180041ac:	47a8      	blx	r5
	if (ret == 0) {
180041ae:	4605      	mov	r5, r0
180041b0:	b9d0      	cbnz	r0, 180041e8 <shell_init+0xd4>
	shell->ctx->state = state;
180041b2:	2201      	movs	r2, #1
180041b4:	68a3      	ldr	r3, [r4, #8]
180041b6:	711a      	strb	r2, [r3, #4]
	k_tid_t tid = k_thread_create(shell->thread,
180041b8:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
180041bc:	2200      	movs	r2, #0
180041be:	2300      	movs	r3, #0
180041c0:	e9cd 2306 	strd	r2, r3, [sp, #24]
180041c4:	230e      	movs	r3, #14
180041c6:	9303      	str	r3, [sp, #12]
180041c8:	9b10      	ldr	r3, [sp, #64]	; 0x40
180041ca:	f640 72ce 	movw	r2, #4046	; 0xfce
180041ce:	e9cd 7301 	strd	r7, r3, [sp, #4]
180041d2:	9504      	str	r5, [sp, #16]
180041d4:	4b0a      	ldr	r3, [pc, #40]	; (18004200 <shell_init+0xec>)
180041d6:	9400      	str	r4, [sp, #0]
180041d8:	f002 fdc0 	bl	18006d5c <z_impl_k_thread_create>
	shell->ctx->tid = tid;
180041dc:	68a3      	ldr	r3, [r4, #8]
	k_thread_name_set(tid, shell->thread_name);
180041de:	6a61      	ldr	r1, [r4, #36]	; 0x24
	shell->ctx->tid = tid;
180041e0:	f8c3 030c 	str.w	r0, [r3, #780]	; 0x30c
	return z_impl_k_thread_name_set(thread, str);
180041e4:	f002 fd10 	bl	18006c08 <z_impl_k_thread_name_set>
}
180041e8:	4628      	mov	r0, r5
180041ea:	b009      	add	sp, #36	; 0x24
180041ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return -EALREADY;
180041f0:	f06f 0577 	mvn.w	r5, #119	; 0x77
180041f4:	e7f8      	b.n	180041e8 <shell_init+0xd4>
180041f6:	bf00      	nop
180041f8:	00500018 	.word	0x00500018
180041fc:	18008e5f 	.word	0x18008e5f
18004200:	18004251 	.word	0x18004251

18004204 <shell_start>:
{
18004204:	b510      	push	{r4, lr}
18004206:	4604      	mov	r4, r0
	return shell->ctx->state;
18004208:	6880      	ldr	r0, [r0, #8]
	if (state_get(shell) != SHELL_STATE_INITIALIZED) {
1800420a:	7903      	ldrb	r3, [r0, #4]
1800420c:	2b01      	cmp	r3, #1
1800420e:	d119      	bne.n	18004244 <shell_start+0x40>
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
18004210:	f04f 32ff 	mov.w	r2, #4294967295
18004214:	f04f 33ff 	mov.w	r3, #4294967295
18004218:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
1800421c:	f004 fe1d 	bl	18008e5a <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(shell, SHELL_NORMAL);
18004220:	2108      	movs	r1, #8
18004222:	4620      	mov	r0, r4
18004224:	f000 f91e 	bl	18004464 <z_shell_vt100_color_set>
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
18004228:	4908      	ldr	r1, [pc, #32]	; (1800424c <shell_start+0x48>)
1800422a:	6960      	ldr	r0, [r4, #20]
1800422c:	f004 fe08 	bl	18008e40 <z_shell_raw_fprintf>
	state_set(shell, SHELL_STATE_ACTIVE);
18004230:	4620      	mov	r0, r4
18004232:	f7ff fc05 	bl	18003a40 <state_set.constprop.0>
	k_mutex_unlock(&shell->ctx->wr_mtx);
18004236:	68a0      	ldr	r0, [r4, #8]
18004238:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
1800423c:	f004 fe5a 	bl	18008ef4 <k_mutex_unlock.isra.0>
	return 0;
18004240:	2000      	movs	r0, #0
}
18004242:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
18004244:	f06f 0085 	mvn.w	r0, #133	; 0x85
18004248:	e7fb      	b.n	18004242 <shell_start+0x3e>
1800424a:	bf00      	nop
1800424c:	1800ccbc 	.word	0x1800ccbc

18004250 <shell_thread>:
{
18004250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
18004254:	4604      	mov	r4, r0
	err = shell->iface->api->enable(shell->iface, false);
18004256:	6840      	ldr	r0, [r0, #4]
{
18004258:	460e      	mov	r6, r1
	err = shell->iface->api->enable(shell->iface, false);
1800425a:	6803      	ldr	r3, [r0, #0]
1800425c:	2100      	movs	r1, #0
1800425e:	689b      	ldr	r3, [r3, #8]
{
18004260:	4615      	mov	r5, r2
	err = shell->iface->api->enable(shell->iface, false);
18004262:	4798      	blx	r3
	if (err != 0) {
18004264:	2800      	cmp	r0, #0
18004266:	d14c      	bne.n	18004302 <shell_thread+0xb2>
	if (IS_ENABLED(CONFIG_SHELL_LOG_BACKEND) && log_backend
18004268:	b126      	cbz	r6, 18004274 <shell_thread+0x24>
		z_shell_log_backend_enable(shell->log_backend, (void *)shell,
1800426a:	462a      	mov	r2, r5
1800426c:	4621      	mov	r1, r4
1800426e:	69e0      	ldr	r0, [r4, #28]
18004270:	f005 fb35 	bl	180098de <z_shell_log_backend_enable>
	err = shell_start(shell);
18004274:	4620      	mov	r0, r4
18004276:	f7ff ffc5 	bl	18004204 <shell_start>
	if (err != 0) {
1800427a:	2800      	cmp	r0, #0
1800427c:	d141      	bne.n	18004302 <shell_thread+0xb2>
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
1800427e:	f8df 8088 	ldr.w	r8, [pc, #136]	; 18004308 <shell_thread+0xb8>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
18004282:	4f22      	ldr	r7, [pc, #136]	; (1800430c <shell_thread+0xbc>)
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
18004284:	4e22      	ldr	r6, [pc, #136]	; (18004310 <shell_thread+0xc0>)
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
18004286:	68a0      	ldr	r0, [r4, #8]
18004288:	f500 702a 	add.w	r0, r0, #680	; 0x2a8
	return z_impl_k_poll(events, num_events, timeout);
1800428c:	f04f 32ff 	mov.w	r2, #4294967295
18004290:	f04f 33ff 	mov.w	r3, #4294967295
18004294:	2103      	movs	r1, #3
18004296:	f003 fcff 	bl	18007c98 <z_impl_k_poll>
		if (err != 0) {
1800429a:	4605      	mov	r5, r0
1800429c:	68a0      	ldr	r0, [r4, #8]
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
1800429e:	f04f 32ff 	mov.w	r2, #4294967295
180042a2:	f04f 33ff 	mov.w	r3, #4294967295
180042a6:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
		if (err != 0) {
180042aa:	b175      	cbz	r5, 180042ca <shell_thread+0x7a>
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
180042ac:	f004 fdd5 	bl	18008e5a <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(shell, SHELL_ERROR,
180042b0:	4620      	mov	r0, r4
180042b2:	462b      	mov	r3, r5
180042b4:	2101      	movs	r1, #1
180042b6:	4a17      	ldr	r2, [pc, #92]	; (18004314 <shell_thread+0xc4>)
180042b8:	f005 fa0c 	bl	180096d4 <z_shell_fprintf>
			k_mutex_unlock(&shell->ctx->wr_mtx);
180042bc:	68a0      	ldr	r0, [r4, #8]
}
180042be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			k_mutex_unlock(&shell->ctx->wr_mtx);
180042c2:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
180042c6:	f004 be15 	b.w	18008ef4 <k_mutex_unlock.isra.0>
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
180042ca:	f004 fdc6 	bl	18008e5a <k_mutex_lock.constprop.0.isra.0>
		if (shell->iface->api->update) {
180042ce:	6860      	ldr	r0, [r4, #4]
180042d0:	6803      	ldr	r3, [r0, #0]
180042d2:	695b      	ldr	r3, [r3, #20]
180042d4:	b103      	cbz	r3, 180042d8 <shell_thread+0x88>
			shell->iface->api->update(shell->iface);
180042d6:	4798      	blx	r3
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
180042d8:	4642      	mov	r2, r8
180042da:	4620      	mov	r0, r4
180042dc:	2102      	movs	r1, #2
180042de:	f004 fd93 	bl	18008e08 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
180042e2:	463a      	mov	r2, r7
180042e4:	4620      	mov	r0, r4
180042e6:	2100      	movs	r1, #0
180042e8:	f004 fd8e 	bl	18008e08 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
180042ec:	4620      	mov	r0, r4
180042ee:	4632      	mov	r2, r6
180042f0:	2101      	movs	r1, #1
180042f2:	f004 fd89 	bl	18008e08 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
180042f6:	68a0      	ldr	r0, [r4, #8]
180042f8:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
180042fc:	f004 fdfa 	bl	18008ef4 <k_mutex_unlock.isra.0>
18004300:	e7c1      	b.n	18004286 <shell_thread+0x36>
}
18004302:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
18004306:	bf00      	nop
18004308:	18008e73 	.word	0x18008e73
1800430c:	18003a89 	.word	0x18003a89
18004310:	18008ef9 	.word	0x18008ef9
18004314:	1800d0a5 	.word	0x1800d0a5

18004318 <cmd_help>:
{
	sh->ctx->bypass = bypass;
}

static int cmd_help(const struct shell *shell, size_t argc, char **argv)
{
18004318:	b510      	push	{r4, lr}
1800431a:	4604      	mov	r4, r0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(shell, "Please press the <Tab> button to see all available "
1800431c:	2108      	movs	r1, #8
1800431e:	4a0c      	ldr	r2, [pc, #48]	; (18004350 <cmd_help+0x38>)
18004320:	f004 fe4a 	bl	18008fb8 <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(shell,
18004324:	4620      	mov	r0, r4
18004326:	2108      	movs	r1, #8
18004328:	4a0a      	ldr	r2, [pc, #40]	; (18004354 <cmd_help+0x3c>)
1800432a:	f004 fe45 	bl	18008fb8 <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(shell,
1800432e:	4620      	mov	r0, r4
18004330:	2108      	movs	r1, #8
18004332:	4a09      	ldr	r2, [pc, #36]	; (18004358 <cmd_help+0x40>)
18004334:	f004 fe40 	bl	18008fb8 <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(shell,
18004338:	4620      	mov	r0, r4
1800433a:	2108      	movs	r1, #8
1800433c:	4a07      	ldr	r2, [pc, #28]	; (1800435c <cmd_help+0x44>)
1800433e:	f004 fe3b 	bl	18008fb8 <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(shell, NULL,
18004342:	4620      	mov	r0, r4
18004344:	2100      	movs	r1, #0
18004346:	4a06      	ldr	r2, [pc, #24]	; (18004360 <cmd_help+0x48>)
18004348:	f000 f9b4 	bl	180046b4 <z_shell_help_subcmd_print>
			shell_print(shell, "  %s", entry->syntax);
		}
	}

	return 0;
}
1800434c:	2000      	movs	r0, #0
1800434e:	bd10      	pop	{r4, pc}
18004350:	1800d0bc 	.word	0x1800d0bc
18004354:	1800d0fa 	.word	0x1800d0fa
18004358:	1800d159 	.word	0x1800d159
1800435c:	1800d1ad 	.word	0x1800d1ad
18004360:	1800d247 	.word	0x1800d247

18004364 <z_shell_fprintf_fmt>:
	return 0;
}

void z_shell_fprintf_fmt(const struct shell_fprintf *sh_fprintf,
			 const char *fmt, va_list args)
{
18004364:	b510      	push	{r4, lr}
18004366:	4604      	mov	r4, r0
18004368:	4613      	mov	r3, r2
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
1800436a:	460a      	mov	r2, r1
1800436c:	4601      	mov	r1, r0
1800436e:	4806      	ldr	r0, [pc, #24]	; (18004388 <z_shell_fprintf_fmt+0x24>)
18004370:	f7fd fa62 	bl	18001838 <cbvprintf>

	if (sh_fprintf->ctrl_blk->autoflush) {
18004374:	6923      	ldr	r3, [r4, #16]
18004376:	791b      	ldrb	r3, [r3, #4]
18004378:	b123      	cbz	r3, 18004384 <z_shell_fprintf_fmt+0x20>
		z_shell_fprintf_buffer_flush(sh_fprintf);
1800437a:	4620      	mov	r0, r4
	}
}
1800437c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_fprintf_buffer_flush(sh_fprintf);
18004380:	f004 be2a 	b.w	18008fd8 <z_shell_fprintf_buffer_flush>
}
18004384:	bd10      	pop	{r4, pc}
18004386:	bf00      	nop
18004388:	18008ff1 	.word	0x18008ff1

1800438c <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
1800438c:	b510      	push	{r4, lr}
1800438e:	460b      	mov	r3, r1
18004390:	4614      	mov	r4, r2
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
18004392:	b950      	cbnz	r0, 180043aa <z_shell_cmd_get+0x1e>
	return ((uint8_t *)__shell_root_cmds_end -
18004394:	490e      	ldr	r1, [pc, #56]	; (180043d0 <z_shell_cmd_get+0x44>)
18004396:	4a0f      	ldr	r2, [pc, #60]	; (180043d4 <z_shell_cmd_get+0x48>)
18004398:	1a52      	subs	r2, r2, r1
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->u.entry : NULL;
1800439a:	ebb3 0fd2 	cmp.w	r3, r2, lsr #3
1800439e:	d20f      	bcs.n	180043c0 <z_shell_cmd_get+0x34>
180043a0:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
180043a4:	684c      	ldr	r4, [r1, #4]
			}
		}
	}

	return res;
}
180043a6:	4620      	mov	r0, r4
180043a8:	bd10      	pop	{r4, pc}
	if (parent->subcmd) {
180043aa:	6881      	ldr	r1, [r0, #8]
180043ac:	b141      	cbz	r1, 180043c0 <z_shell_cmd_get+0x34>
			parent->subcmd->u.dynamic_get(idx, dloc);
180043ae:	684a      	ldr	r2, [r1, #4]
		if (parent->subcmd->is_dynamic) {
180043b0:	7809      	ldrb	r1, [r1, #0]
180043b2:	b139      	cbz	r1, 180043c4 <z_shell_cmd_get+0x38>
			parent->subcmd->u.dynamic_get(idx, dloc);
180043b4:	4618      	mov	r0, r3
180043b6:	4621      	mov	r1, r4
180043b8:	4790      	blx	r2
			if (dloc->syntax != NULL) {
180043ba:	6823      	ldr	r3, [r4, #0]
180043bc:	2b00      	cmp	r3, #0
180043be:	d1f2      	bne.n	180043a6 <z_shell_cmd_get+0x1a>
	const struct shell_static_entry *res = NULL;
180043c0:	2400      	movs	r4, #0
180043c2:	e7f0      	b.n	180043a6 <z_shell_cmd_get+0x1a>
			if (parent->subcmd->u.entry[idx].syntax != NULL) {
180043c4:	2014      	movs	r0, #20
180043c6:	4343      	muls	r3, r0
180043c8:	18d4      	adds	r4, r2, r3
180043ca:	58d3      	ldr	r3, [r2, r3]
180043cc:	e7f6      	b.n	180043bc <z_shell_cmd_get+0x30>
180043ce:	bf00      	nop
180043d0:	1800b438 	.word	0x1800b438
180043d4:	1800b480 	.word	0x1800b480

180043d8 <z_clear_eos>:
	return sh->ctx->cfg.flags.use_vt100 == 1;
180043d8:	6883      	ldr	r3, [r0, #8]
180043da:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
180043de:	069b      	lsls	r3, r3, #26
180043e0:	d503      	bpl.n	180043ea <z_clear_eos+0x12>
180043e2:	4902      	ldr	r1, [pc, #8]	; (180043ec <z_clear_eos+0x14>)
180043e4:	6940      	ldr	r0, [r0, #20]
180043e6:	f005 b800 	b.w	180093ea <z_shell_raw_fprintf>
}
180043ea:	4770      	bx	lr
180043ec:	1800b4b8 	.word	0x1800b4b8

180043f0 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
180043f0:	4901      	ldr	r1, [pc, #4]	; (180043f8 <z_cursor_next_line_move.isra.0+0x8>)
180043f2:	f004 bffa 	b.w	180093ea <z_shell_raw_fprintf>
180043f6:	bf00      	nop
180043f8:	1800ccbd 	.word	0x1800ccbd

180043fc <z_shell_op_cursor_vert_move>:
#include "shell_ops.h"

#define CMD_CURSOR_LEN 8
void z_shell_op_cursor_vert_move(const struct shell *shell, int32_t delta)
{
	char dir = delta > 0 ? 'A' : 'B';
180043fc:	1e0a      	subs	r2, r1, #0
180043fe:	dc0d      	bgt.n	1800441c <z_shell_op_cursor_vert_move+0x20>

	if (delta == 0) {
18004400:	d00e      	beq.n	18004420 <z_shell_op_cursor_vert_move+0x24>
	char dir = delta > 0 ? 'A' : 'B';
18004402:	2342      	movs	r3, #66	; 0x42
	return sh->ctx->cfg.flags.use_vt100 == 1;
18004404:	6881      	ldr	r1, [r0, #8]
18004406:	f8d1 1260 	ldr.w	r1, [r1, #608]	; 0x260

	if (delta < 0) {
		delta = -delta;
	}

	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
1800440a:	0689      	lsls	r1, r1, #26
1800440c:	d508      	bpl.n	18004420 <z_shell_op_cursor_vert_move+0x24>
1800440e:	2a00      	cmp	r2, #0
18004410:	4904      	ldr	r1, [pc, #16]	; (18004424 <z_shell_op_cursor_vert_move+0x28>)
18004412:	6940      	ldr	r0, [r0, #20]
18004414:	bfb8      	it	lt
18004416:	4252      	neglt	r2, r2
18004418:	f004 bfe7 	b.w	180093ea <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'A' : 'B';
1800441c:	2341      	movs	r3, #65	; 0x41
1800441e:	e7f1      	b.n	18004404 <z_shell_op_cursor_vert_move+0x8>
}
18004420:	4770      	bx	lr
18004422:	bf00      	nop
18004424:	1800d276 	.word	0x1800d276

18004428 <z_shell_op_cursor_horiz_move>:

void z_shell_op_cursor_horiz_move(const struct shell *shell, int32_t delta)
{
	char dir = delta > 0 ? 'C' : 'D';
18004428:	1e0a      	subs	r2, r1, #0
1800442a:	dc0d      	bgt.n	18004448 <z_shell_op_cursor_horiz_move+0x20>

	if (delta == 0) {
1800442c:	d00e      	beq.n	1800444c <z_shell_op_cursor_horiz_move+0x24>
	char dir = delta > 0 ? 'C' : 'D';
1800442e:	2344      	movs	r3, #68	; 0x44
18004430:	6881      	ldr	r1, [r0, #8]
18004432:	f8d1 1260 	ldr.w	r1, [r1, #608]	; 0x260

	if (delta < 0) {
		delta = -delta;
	}

	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
18004436:	0689      	lsls	r1, r1, #26
18004438:	d508      	bpl.n	1800444c <z_shell_op_cursor_horiz_move+0x24>
1800443a:	2a00      	cmp	r2, #0
1800443c:	4904      	ldr	r1, [pc, #16]	; (18004450 <z_shell_op_cursor_horiz_move+0x28>)
1800443e:	6940      	ldr	r0, [r0, #20]
18004440:	bfb8      	it	lt
18004442:	4252      	neglt	r2, r2
18004444:	f004 bfd1 	b.w	180093ea <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'C' : 'D';
18004448:	2343      	movs	r3, #67	; 0x43
1800444a:	e7f1      	b.n	18004430 <z_shell_op_cursor_horiz_move+0x8>
}
1800444c:	4770      	bx	lr
1800444e:	bf00      	nop
18004450:	1800d276 	.word	0x1800d276

18004454 <z_shell_print_cmd>:
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *shell)
{
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
18004454:	6882      	ldr	r2, [r0, #8]
18004456:	4902      	ldr	r1, [pc, #8]	; (18004460 <z_shell_print_cmd+0xc>)
18004458:	6940      	ldr	r0, [r0, #20]
1800445a:	3242      	adds	r2, #66	; 0x42
1800445c:	f004 bfc5 	b.w	180093ea <z_shell_raw_fprintf>
18004460:	1800d0a2 	.word	0x1800d0a2

18004464 <z_shell_vt100_color_set>:
{
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	if (color >= VT100_COLOR_END) {
18004464:	2908      	cmp	r1, #8
{
18004466:	460a      	mov	r2, r1
	if (color >= VT100_COLOR_END) {
18004468:	d816      	bhi.n	18004498 <z_shell_vt100_color_set+0x34>
		return;
	}

	if (shell->ctx->vt100_ctx.col.col == color) {
1800446a:	6883      	ldr	r3, [r0, #8]
1800446c:	f893 102e 	ldrb.w	r1, [r3, #46]	; 0x2e
18004470:	4291      	cmp	r1, r2
18004472:	d011      	beq.n	18004498 <z_shell_vt100_color_set+0x34>
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;

	if (color != SHELL_NORMAL) {
18004474:	2a08      	cmp	r2, #8
	shell->ctx->vt100_ctx.col.col = color;
18004476:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
1800447a:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	if (color != SHELL_NORMAL) {
1800447e:	d005      	beq.n	1800448c <z_shell_vt100_color_set+0x28>
		Z_SHELL_VT100_CMD(shell, "\e[1;3%dm", color);
18004480:	0699      	lsls	r1, r3, #26
18004482:	d509      	bpl.n	18004498 <z_shell_vt100_color_set+0x34>
18004484:	4905      	ldr	r1, [pc, #20]	; (1800449c <z_shell_vt100_color_set+0x38>)
18004486:	6940      	ldr	r0, [r0, #20]
18004488:	f004 bfaf 	b.w	180093ea <z_shell_raw_fprintf>
	} else {
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_MODESOFF);
1800448c:	069b      	lsls	r3, r3, #26
1800448e:	d503      	bpl.n	18004498 <z_shell_vt100_color_set+0x34>
18004490:	4903      	ldr	r1, [pc, #12]	; (180044a0 <z_shell_vt100_color_set+0x3c>)
18004492:	6940      	ldr	r0, [r0, #20]
18004494:	f004 bfa9 	b.w	180093ea <z_shell_raw_fprintf>
	}
}
18004498:	4770      	bx	lr
1800449a:	bf00      	nop
1800449c:	1800d27d 	.word	0x1800d27d
180044a0:	1800b4bd 	.word	0x1800b4bd

180044a4 <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *shell,
				  const struct shell_vt100_colors *color)
{
180044a4:	b538      	push	{r3, r4, r5, lr}
180044a6:	460d      	mov	r5, r1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	z_shell_vt100_color_set(shell, color->col);
180044a8:	7809      	ldrb	r1, [r1, #0]
{
180044aa:	4604      	mov	r4, r0
	z_shell_vt100_color_set(shell, color->col);
180044ac:	f7ff ffda 	bl	18004464 <z_shell_vt100_color_set>
	vt100_bgcolor_set(shell, color->bgcol);
180044b0:	786a      	ldrb	r2, [r5, #1]
	if ((bgcolor == SHELL_NORMAL) ||
180044b2:	2a07      	cmp	r2, #7
180044b4:	d810      	bhi.n	180044d8 <z_shell_vt100_colors_restore+0x34>
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
180044b6:	68a3      	ldr	r3, [r4, #8]
	if ((bgcolor == SHELL_NORMAL) ||
180044b8:	f893 102f 	ldrb.w	r1, [r3, #47]	; 0x2f
180044bc:	4291      	cmp	r1, r2
180044be:	d00b      	beq.n	180044d8 <z_shell_vt100_colors_restore+0x34>
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
180044c0:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
180044c4:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
180044c8:	069b      	lsls	r3, r3, #26
180044ca:	d505      	bpl.n	180044d8 <z_shell_vt100_colors_restore+0x34>
180044cc:	6960      	ldr	r0, [r4, #20]
180044ce:	4903      	ldr	r1, [pc, #12]	; (180044dc <z_shell_vt100_colors_restore+0x38>)
}
180044d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
180044d4:	f004 bf89 	b.w	180093ea <z_shell_raw_fprintf>
}
180044d8:	bd38      	pop	{r3, r4, r5, pc}
180044da:	bf00      	nop
180044dc:	1800d286 	.word	0x1800d286

180044e0 <z_shell_op_word_remove>:
{
180044e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
180044e2:	6883      	ldr	r3, [r0, #8]
{
180044e4:	4605      	mov	r5, r0
	if ((shell->ctx->cmd_buff_len == 0) ||
180044e6:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
180044e8:	2a00      	cmp	r2, #0
180044ea:	d04e      	beq.n	1800458a <z_shell_op_word_remove+0xaa>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
180044ec:	8fd8      	ldrh	r0, [r3, #62]	; 0x3e
	if ((shell->ctx->cmd_buff_len == 0) ||
180044ee:	2800      	cmp	r0, #0
180044f0:	d04b      	beq.n	1800458a <z_shell_op_word_remove+0xaa>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
180044f2:	3041      	adds	r0, #65	; 0x41
180044f4:	4418      	add	r0, r3
	char *str_start = &shell->ctx->cmd_buff[0];
180044f6:	f103 0642 	add.w	r6, r3, #66	; 0x42
180044fa:	4603      	mov	r3, r0
180044fc:	1ac4      	subs	r4, r0, r3
	while ((str >= str_start) && (*str == ' ')) {
180044fe:	42b3      	cmp	r3, r6
18004500:	4619      	mov	r1, r3
18004502:	b2a4      	uxth	r4, r4
18004504:	d30d      	bcc.n	18004522 <z_shell_op_word_remove+0x42>
18004506:	f811 7901 	ldrb.w	r7, [r1], #-1
1800450a:	2f20      	cmp	r7, #32
1800450c:	d03b      	beq.n	18004586 <z_shell_op_word_remove+0xa6>
1800450e:	4619      	mov	r1, r3
	while ((str >= str_start) && (*str != ' ')) {
18004510:	7808      	ldrb	r0, [r1, #0]
18004512:	3b01      	subs	r3, #1
18004514:	2820      	cmp	r0, #32
18004516:	d004      	beq.n	18004522 <z_shell_op_word_remove+0x42>
		++chars_to_delete;
18004518:	3401      	adds	r4, #1
	while ((str >= str_start) && (*str != ' ')) {
1800451a:	429e      	cmp	r6, r3
		--str;
1800451c:	4619      	mov	r1, r3
		++chars_to_delete;
1800451e:	b2a4      	uxth	r4, r4
	while ((str >= str_start) && (*str != ' ')) {
18004520:	d9f5      	bls.n	1800450e <z_shell_op_word_remove+0x2e>
	memmove(str + 1, str + 1 + chars_to_delete,
18004522:	1c63      	adds	r3, r4, #1
18004524:	1c4e      	adds	r6, r1, #1
18004526:	1b12      	subs	r2, r2, r4
18004528:	4419      	add	r1, r3
1800452a:	4630      	mov	r0, r6
1800452c:	f005 fdf9 	bl	1800a122 <memmove>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
18004530:	2300      	movs	r3, #0
	shell->ctx->cmd_buff_len -= chars_to_delete;
18004532:	68a9      	ldr	r1, [r5, #8]
	z_shell_op_cursor_move(shell, -chars_to_delete);
18004534:	4628      	mov	r0, r5
	shell->ctx->cmd_buff_len -= chars_to_delete;
18004536:	8f8a      	ldrh	r2, [r1, #60]	; 0x3c
18004538:	1b12      	subs	r2, r2, r4
1800453a:	b292      	uxth	r2, r2
1800453c:	878a      	strh	r2, [r1, #60]	; 0x3c
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
1800453e:	440a      	add	r2, r1
	z_shell_op_cursor_move(shell, -chars_to_delete);
18004540:	4261      	negs	r1, r4
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
18004542:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
	z_shell_op_cursor_move(shell, -chars_to_delete);
18004546:	b209      	sxth	r1, r1
18004548:	f004 ffb7 	bl	180094ba <z_shell_op_cursor_move>
1800454c:	68ab      	ldr	r3, [r5, #8]
1800454e:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
18004552:	069a      	lsls	r2, r3, #26
18004554:	d503      	bpl.n	1800455e <z_shell_op_word_remove+0x7e>
18004556:	490d      	ldr	r1, [pc, #52]	; (1800458c <z_shell_op_word_remove+0xac>)
18004558:	6968      	ldr	r0, [r5, #20]
1800455a:	f004 ff46 	bl	180093ea <z_shell_raw_fprintf>
	z_shell_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
1800455e:	4633      	mov	r3, r6
18004560:	2108      	movs	r1, #8
18004562:	4628      	mov	r0, r5
18004564:	4a0a      	ldr	r2, [pc, #40]	; (18004590 <z_shell_op_word_remove+0xb0>)
18004566:	f005 f8b5 	bl	180096d4 <z_shell_fprintf>
	z_clear_eos(shell);
1800456a:	4628      	mov	r0, r5
1800456c:	f7ff ff34 	bl	180043d8 <z_clear_eos>
	return sh->ctx->cfg.flags.use_vt100 == 1;
18004570:	68ab      	ldr	r3, [r5, #8]
18004572:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
18004576:	069b      	lsls	r3, r3, #26
18004578:	d507      	bpl.n	1800458a <z_shell_op_word_remove+0xaa>
1800457a:	6968      	ldr	r0, [r5, #20]
1800457c:	4905      	ldr	r1, [pc, #20]	; (18004594 <z_shell_op_word_remove+0xb4>)
}
1800457e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
18004582:	f004 bf32 	b.w	180093ea <z_shell_raw_fprintf>
18004586:	460b      	mov	r3, r1
18004588:	e7b8      	b.n	180044fc <z_shell_op_word_remove+0x1c>
1800458a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
1800458c:	1800b4c2 	.word	0x1800b4c2
18004590:	1800d0a2 	.word	0x1800d0a2
18004594:	1800b4c6 	.word	0x1800b4c6

18004598 <reprint_from_cursor>:
{
18004598:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1800459c:	4604      	mov	r4, r0
1800459e:	460d      	mov	r5, r1
	if (data_removed) {
180045a0:	4617      	mov	r7, r2
180045a2:	b10a      	cbz	r2, 180045a8 <reprint_from_cursor+0x10>
		z_clear_eos(shell);
180045a4:	f7ff ff18 	bl	180043d8 <z_clear_eos>
	return sh->ctx->cfg.flags.obscure == 1;
180045a8:	68a3      	ldr	r3, [r4, #8]
180045aa:	f8d3 2260 	ldr.w	r2, [r3, #608]	; 0x260
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
180045ae:	8fd8      	ldrh	r0, [r3, #62]	; 0x3e
	if (z_flag_obscure_get(shell)) {
180045b0:	0752      	lsls	r2, r2, #29
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
180045b2:	f100 0042 	add.w	r0, r0, #66	; 0x42
180045b6:	4403      	add	r3, r0
	if (z_flag_obscure_get(shell)) {
180045b8:	d51f      	bpl.n	180045fa <reprint_from_cursor+0x62>
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
180045ba:	4618      	mov	r0, r3
180045bc:	f005 fd73 	bl	1800a0a6 <strlen>
180045c0:	4606      	mov	r6, r0
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
180045c2:	f8df 8044 	ldr.w	r8, [pc, #68]	; 18004608 <reprint_from_cursor+0x70>
		while (len--) {
180045c6:	b996      	cbnz	r6, 180045ee <reprint_from_cursor+0x56>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
180045c8:	68a3      	ldr	r3, [r4, #8]
	if (full_line_cmd(shell)) {
180045ca:	4620      	mov	r0, r4
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
180045cc:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
180045ce:	87da      	strh	r2, [r3, #62]	; 0x3e
	if (full_line_cmd(shell)) {
180045d0:	f004 ff18 	bl	18009404 <full_line_cmd>
180045d4:	b120      	cbz	r0, 180045e0 <reprint_from_cursor+0x48>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
180045d6:	b107      	cbz	r7, 180045da <reprint_from_cursor+0x42>
180045d8:	b115      	cbz	r5, 180045e0 <reprint_from_cursor+0x48>
			z_cursor_next_line_move(shell);
180045da:	6960      	ldr	r0, [r4, #20]
180045dc:	f7ff ff08 	bl	180043f0 <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(shell, -diff);
180045e0:	4269      	negs	r1, r5
180045e2:	4620      	mov	r0, r4
}
180045e4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_shell_op_cursor_move(shell, -diff);
180045e8:	b209      	sxth	r1, r1
180045ea:	f004 bf66 	b.w	180094ba <z_shell_op_cursor_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
180045ee:	4641      	mov	r1, r8
180045f0:	6960      	ldr	r0, [r4, #20]
180045f2:	f004 fefa 	bl	180093ea <z_shell_raw_fprintf>
180045f6:	3e01      	subs	r6, #1
180045f8:	e7e5      	b.n	180045c6 <reprint_from_cursor+0x2e>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s",
180045fa:	2108      	movs	r1, #8
180045fc:	4620      	mov	r0, r4
180045fe:	4a03      	ldr	r2, [pc, #12]	; (1800460c <reprint_from_cursor+0x74>)
18004600:	f005 f868 	bl	180096d4 <z_shell_fprintf>
18004604:	e7e0      	b.n	180045c8 <reprint_from_cursor+0x30>
18004606:	bf00      	nop
18004608:	1800dc18 	.word	0x1800dc18
1800460c:	1800d0a2 	.word	0x1800d0a2

18004610 <z_shell_op_char_insert>:
{
18004610:	b513      	push	{r0, r1, r4, lr}
	return sh->ctx->cfg.flags.insert_mode == 1;
18004612:	6883      	ldr	r3, [r0, #8]
18004614:	f88d 1007 	strb.w	r1, [sp, #7]
18004618:	f8d3 2260 	ldr.w	r2, [r3, #608]	; 0x260
1800461c:	4604      	mov	r4, r0
	if (z_flag_insert_mode_get(shell) &&
1800461e:	07d0      	lsls	r0, r2, #31
18004620:	d521      	bpl.n	18004666 <z_shell_op_char_insert+0x56>
	    (shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
18004622:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
	if (z_flag_insert_mode_get(shell) &&
18004624:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
18004626:	428a      	cmp	r2, r1
18004628:	d01d      	beq.n	18004666 <z_shell_op_char_insert+0x56>
		char_replace(shell, data);
1800462a:	f89d 2007 	ldrb.w	r2, [sp, #7]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
1800462e:	1c48      	adds	r0, r1, #1
18004630:	4419      	add	r1, r3
18004632:	87d8      	strh	r0, [r3, #62]	; 0x3e
18004634:	f881 2042 	strb.w	r2, [r1, #66]	; 0x42
	return sh->ctx->cfg.flags.echo == 1;
18004638:	f8d3 1260 	ldr.w	r1, [r3, #608]	; 0x260
	if (!z_flag_echo_get(shell)) {
1800463c:	0789      	lsls	r1, r1, #30
1800463e:	d510      	bpl.n	18004662 <z_shell_op_char_insert+0x52>
	return sh->ctx->cfg.flags.obscure == 1;
18004640:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
18004644:	6960      	ldr	r0, [r4, #20]
		data = '*';
18004646:	f013 0f04 	tst.w	r3, #4
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
1800464a:	bf18      	it	ne
1800464c:	222a      	movne	r2, #42	; 0x2a
1800464e:	4909      	ldr	r1, [pc, #36]	; (18004674 <z_shell_op_char_insert+0x64>)
18004650:	f004 fecb 	bl	180093ea <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(shell)) {
18004654:	4620      	mov	r0, r4
18004656:	f004 fee9 	bl	1800942c <z_shell_cursor_in_empty_line>
1800465a:	b110      	cbz	r0, 18004662 <z_shell_op_char_insert+0x52>
		z_cursor_next_line_move(shell);
1800465c:	6960      	ldr	r0, [r4, #20]
1800465e:	f7ff fec7 	bl	180043f0 <z_cursor_next_line_move.isra.0>
}
18004662:	b002      	add	sp, #8
18004664:	bd10      	pop	{r4, pc}
		data_insert(shell, &data, 1);
18004666:	2201      	movs	r2, #1
18004668:	4620      	mov	r0, r4
1800466a:	f10d 0107 	add.w	r1, sp, #7
1800466e:	f005 f83e 	bl	180096ee <data_insert>
}
18004672:	e7f6      	b.n	18004662 <z_shell_op_char_insert+0x52>
18004674:	1800d27a 	.word	0x1800d27a

18004678 <z_shell_print_prompt_and_cmd>:
{
18004678:	b510      	push	{r4, lr}
1800467a:	4604      	mov	r4, r0
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
1800467c:	6883      	ldr	r3, [r0, #8]
1800467e:	2102      	movs	r1, #2
18004680:	681b      	ldr	r3, [r3, #0]
18004682:	4a08      	ldr	r2, [pc, #32]	; (180046a4 <z_shell_print_prompt_and_cmd+0x2c>)
18004684:	f005 f826 	bl	180096d4 <z_shell_fprintf>
	return sh->ctx->cfg.flags.echo == 1;
18004688:	68a3      	ldr	r3, [r4, #8]
1800468a:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	if (z_flag_echo_get(shell)) {
1800468e:	079b      	lsls	r3, r3, #30
18004690:	d507      	bpl.n	180046a2 <z_shell_print_prompt_and_cmd+0x2a>
		z_shell_print_cmd(shell);
18004692:	4620      	mov	r0, r4
18004694:	f7ff fede 	bl	18004454 <z_shell_print_cmd>
		z_shell_op_cursor_position_synchronize(shell);
18004698:	4620      	mov	r0, r4
}
1800469a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_op_cursor_position_synchronize(shell);
1800469e:	f004 bee9 	b.w	18009474 <z_shell_op_cursor_position_synchronize>
}
180046a2:	bd10      	pop	{r4, pc}
180046a4:	1800d0a2 	.word	0x1800d0a2

180046a8 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
180046a8:	4901      	ldr	r1, [pc, #4]	; (180046b0 <z_cursor_next_line_move.isra.0+0x8>)
180046aa:	f005 b9aa 	b.w	18009a02 <z_shell_raw_fprintf>
180046ae:	bf00      	nop
180046b0:	1800ccbd 	.word	0x1800ccbd

180046b4 <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *shell,
			       const struct shell_static_entry *parent,
			       const char *description)
{
180046b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
180046b8:	460e      	mov	r6, r1
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
	size_t idx = 0;
180046ba:	2100      	movs	r1, #0
{
180046bc:	4604      	mov	r4, r0
180046be:	4617      	mov	r7, r2
	uint16_t longest = 0U;
180046c0:	460d      	mov	r5, r1
{
180046c2:	b08d      	sub	sp, #52	; 0x34

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
180046c4:	4630      	mov	r0, r6
180046c6:	aa07      	add	r2, sp, #28
180046c8:	f101 0801 	add.w	r8, r1, #1
180046cc:	f7ff fe5e 	bl	1800438c <z_shell_cmd_get>
180046d0:	b9a0      	cbnz	r0, 180046fc <z_shell_help_subcmd_print+0x48>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
	}

	/* No help to print */
	if (longest == 0) {
180046d2:	b185      	cbz	r5, 180046f6 <z_shell_help_subcmd_print+0x42>
		return;
	}

	if (description != NULL) {
180046d4:	b127      	cbz	r7, 180046e0 <z_shell_help_subcmd_print+0x2c>
		z_shell_fprintf(shell, SHELL_NORMAL, description);
180046d6:	463a      	mov	r2, r7
180046d8:	2108      	movs	r1, #8
180046da:	4620      	mov	r0, r4
180046dc:	f004 fffa 	bl	180096d4 <z_shell_fprintf>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
180046e0:	2100      	movs	r1, #0
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
180046e2:	4f1e      	ldr	r7, [pc, #120]	; (1800475c <z_shell_help_subcmd_print+0xa8>)
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
180046e4:	f8df 9078 	ldr.w	r9, [pc, #120]	; 18004760 <z_shell_help_subcmd_print+0xac>
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
180046e8:	4630      	mov	r0, r6
180046ea:	aa07      	add	r2, sp, #28
180046ec:	f101 0801 	add.w	r8, r1, #1
180046f0:	f7ff fe4c 	bl	1800438c <z_shell_cmd_get>
180046f4:	b960      	cbnz	r0, 18004710 <z_shell_help_subcmd_print+0x5c>
		help_item_print(shell, entry->syntax, longest, entry->help);
	}
}
180046f6:	b00d      	add	sp, #52	; 0x34
180046f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
180046fc:	6800      	ldr	r0, [r0, #0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
180046fe:	b110      	cbz	r0, 18004706 <z_shell_help_subcmd_print+0x52>
18004700:	f005 fcd1 	bl	1800a0a6 <strlen>
18004704:	b280      	uxth	r0, r0
18004706:	4285      	cmp	r5, r0
18004708:	bf38      	it	cc
1800470a:	4605      	movcc	r5, r0
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
1800470c:	4641      	mov	r1, r8
1800470e:	e7d9      	b.n	180046c4 <z_shell_help_subcmd_print+0x10>
		help_item_print(shell, entry->syntax, longest, entry->help);
18004710:	6803      	ldr	r3, [r0, #0]
18004712:	f8d0 a004 	ldr.w	sl, [r0, #4]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
18004716:	4811      	ldr	r0, [pc, #68]	; (1800475c <z_shell_help_subcmd_print+0xa8>)
		help_item_print(shell, entry->syntax, longest, entry->help);
18004718:	9305      	str	r3, [sp, #20]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
1800471a:	f005 fcc4 	bl	1800a0a6 <strlen>
	if ((item_name == NULL) || (item_name[0] == '\0')) {
1800471e:	9b05      	ldr	r3, [sp, #20]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
18004720:	4683      	mov	fp, r0
	if ((item_name == NULL) || (item_name[0] == '\0')) {
18004722:	b183      	cbz	r3, 18004746 <z_shell_help_subcmd_print+0x92>
18004724:	781a      	ldrb	r2, [r3, #0]
18004726:	b172      	cbz	r2, 18004746 <z_shell_help_subcmd_print+0x92>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
18004728:	e9cd 3701 	strd	r3, r7, [sp, #4]
1800472c:	464a      	mov	r2, r9
1800472e:	463b      	mov	r3, r7
18004730:	2108      	movs	r1, #8
18004732:	4620      	mov	r0, r4
18004734:	9500      	str	r5, [sp, #0]
18004736:	f004 ffcd 	bl	180096d4 <z_shell_fprintf>
	if (item_help == NULL) {
1800473a:	f1ba 0f00 	cmp.w	sl, #0
1800473e:	d104      	bne.n	1800474a <z_shell_help_subcmd_print+0x96>
		z_cursor_next_line_move(shell);
18004740:	6960      	ldr	r0, [r4, #20]
18004742:	f7ff ffb1 	bl	180046a8 <z_cursor_next_line_move.isra.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
18004746:	4641      	mov	r1, r8
18004748:	e7ce      	b.n	180046e8 <z_shell_help_subcmd_print+0x34>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
1800474a:	1c6a      	adds	r2, r5, #1
1800474c:	eb02 024b 	add.w	r2, r2, fp, lsl #1
	formatted_text_print(shell, item_help, offset, false);
18004750:	4651      	mov	r1, sl
18004752:	4620      	mov	r0, r4
18004754:	b292      	uxth	r2, r2
18004756:	f005 f961 	bl	18009a1c <formatted_text_print.constprop.0>
1800475a:	e7f4      	b.n	18004746 <z_shell_help_subcmd_print+0x92>
1800475c:	1800d2a7 	.word	0x1800d2a7
18004760:	1800d28f 	.word	0x1800d28f

18004764 <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *shell,
			    const struct shell_static_entry *cmd)
{
18004764:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
18004766:	4606      	mov	r6, r0
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
18004768:	6808      	ldr	r0, [r1, #0]
{
1800476a:	460d      	mov	r5, r1
1800476c:	b1b8      	cbz	r0, 1800479e <z_shell_help_cmd_print+0x3a>
1800476e:	f005 fc9a 	bl	1800a0a6 <strlen>
18004772:	b284      	uxth	r4, r0
18004774:	4f0b      	ldr	r7, [pc, #44]	; (180047a4 <z_shell_help_cmd_print+0x40>)
18004776:	4638      	mov	r0, r7
18004778:	f005 fc95 	bl	1800a0a6 <strlen>
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
1800477c:	4404      	add	r4, r0

	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
1800477e:	2108      	movs	r1, #8
18004780:	4630      	mov	r0, r6
18004782:	682b      	ldr	r3, [r5, #0]
18004784:	4a08      	ldr	r2, [pc, #32]	; (180047a8 <z_shell_help_cmd_print+0x44>)
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
18004786:	b2a4      	uxth	r4, r4
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
18004788:	9700      	str	r7, [sp, #0]
1800478a:	f004 ffa3 	bl	180096d4 <z_shell_fprintf>

	formatted_text_print(shell, cmd->help, field_width, false);
1800478e:	4622      	mov	r2, r4
18004790:	4630      	mov	r0, r6
18004792:	6869      	ldr	r1, [r5, #4]
}
18004794:	b003      	add	sp, #12
18004796:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	formatted_text_print(shell, cmd->help, field_width, false);
1800479a:	f005 b93f 	b.w	18009a1c <formatted_text_print.constprop.0>
1800479e:	4604      	mov	r4, r0
180047a0:	e7e8      	b.n	18004774 <z_shell_help_cmd_print+0x10>
180047a2:	bf00      	nop
180047a4:	1800d2a3 	.word	0x1800d2a3
180047a8:	1800d0a0 	.word	0x1800d0a0

180047ac <z_shell_help_request>:

bool z_shell_help_request(const char *str)
{
180047ac:	b510      	push	{r4, lr}
	if (!IS_ENABLED(CONFIG_SHELL_HELP_OPT_PARSE)) {
		return false;
	}

	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
180047ae:	4907      	ldr	r1, [pc, #28]	; (180047cc <z_shell_help_request+0x20>)
{
180047b0:	4604      	mov	r4, r0
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
180047b2:	f005 fc88 	bl	1800a0c6 <strcmp>
180047b6:	b138      	cbz	r0, 180047c8 <z_shell_help_request+0x1c>
180047b8:	4620      	mov	r0, r4
180047ba:	4905      	ldr	r1, [pc, #20]	; (180047d0 <z_shell_help_request+0x24>)
180047bc:	f005 fc83 	bl	1800a0c6 <strcmp>
180047c0:	fab0 f080 	clz	r0, r0
180047c4:	0940      	lsrs	r0, r0, #5
		return true;
	}

	return false;
}
180047c6:	bd10      	pop	{r4, pc}
		return true;
180047c8:	2001      	movs	r0, #1
180047ca:	e7fc      	b.n	180047c6 <z_shell_help_request+0x1a>
180047cc:	1800d299 	.word	0x1800d299
180047d0:	1800d29c 	.word	0x1800d29c

180047d4 <cmd_resize_default>:
	return 0;
}

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
180047d4:	b510      	push	{r4, lr}
	return sh->ctx->cfg.flags.use_vt100 == 1;
180047d6:	6883      	ldr	r3, [r0, #8]
180047d8:	4604      	mov	r4, r0
180047da:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
180047de:	069b      	lsls	r3, r3, #26
180047e0:	d503      	bpl.n	180047ea <cmd_resize_default+0x16>
180047e2:	4904      	ldr	r1, [pc, #16]	; (180047f4 <cmd_resize_default+0x20>)
180047e4:	6940      	ldr	r0, [r0, #20]
180047e6:	f005 f990 	bl	18009b0a <z_shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
180047ea:	68a3      	ldr	r3, [r4, #8]
180047ec:	4a02      	ldr	r2, [pc, #8]	; (180047f8 <cmd_resize_default+0x24>)

	return 0;
}
180047ee:	2000      	movs	r0, #0
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
180047f0:	629a      	str	r2, [r3, #40]	; 0x28
}
180047f2:	bd10      	pop	{r4, pc}
180047f4:	1800b4ca 	.word	0x1800b4ca
180047f8:	00500018 	.word	0x00500018

180047fc <cmd_shell_stats_show>:
{
180047fc:	b508      	push	{r3, lr}
	shell_print(shell, "Lost logs: %lu", shell->stats->log_lost_cnt);
180047fe:	6983      	ldr	r3, [r0, #24]
18004800:	2108      	movs	r1, #8
18004802:	681b      	ldr	r3, [r3, #0]
18004804:	4a02      	ldr	r2, [pc, #8]	; (18004810 <cmd_shell_stats_show+0x14>)
18004806:	f004 fbd7 	bl	18008fb8 <shell_fprintf>
}
1800480a:	2000      	movs	r0, #0
1800480c:	bd08      	pop	{r3, pc}
1800480e:	bf00      	nop
18004810:	1800d2aa 	.word	0x1800d2aa

18004814 <cmd_history>:
{
18004814:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
18004816:	4604      	mov	r4, r0
18004818:	2500      	movs	r5, #0
			shell_print(shell, "[%3d] %s",
1800481a:	4e0e      	ldr	r6, [pc, #56]	; (18004854 <cmd_history+0x40>)
				    shell->ctx->temp_buff, &len);
1800481c:	68a2      	ldr	r2, [r4, #8]
		z_shell_history_get(shell->history, true,
1800481e:	f10d 030e 	add.w	r3, sp, #14
18004822:	2101      	movs	r1, #1
18004824:	68e0      	ldr	r0, [r4, #12]
18004826:	f502 72a1 	add.w	r2, r2, #322	; 0x142
1800482a:	f005 f9de 	bl	18009bea <z_shell_history_get>
		if (len) {
1800482e:	f8bd 000e 	ldrh.w	r0, [sp, #14]
18004832:	68a3      	ldr	r3, [r4, #8]
18004834:	b150      	cbz	r0, 1800484c <cmd_history+0x38>
			shell_print(shell, "[%3d] %s",
18004836:	f503 73a1 	add.w	r3, r3, #322	; 0x142
1800483a:	9300      	str	r3, [sp, #0]
1800483c:	4632      	mov	r2, r6
1800483e:	462b      	mov	r3, r5
18004840:	2108      	movs	r1, #8
18004842:	4620      	mov	r0, r4
18004844:	f004 fbb8 	bl	18008fb8 <shell_fprintf>
	while (1) {
18004848:	3501      	adds	r5, #1
		z_shell_history_get(shell->history, true,
1800484a:	e7e7      	b.n	1800481c <cmd_history+0x8>
	shell->ctx->temp_buff[0] = '\0';
1800484c:	f883 0142 	strb.w	r0, [r3, #322]	; 0x142
}
18004850:	b004      	add	sp, #16
18004852:	bd70      	pop	{r4, r5, r6, pc}
18004854:	1800d2ba 	.word	0x1800d2ba

18004858 <cmd_echo>:
	if (argc == 2) {
18004858:	2902      	cmp	r1, #2
{
1800485a:	b507      	push	{r0, r1, r2, lr}
	if (argc == 2) {
1800485c:	d10d      	bne.n	1800487a <cmd_echo+0x22>
		shell_error(shell, "%s:%s%s", argv[0],
1800485e:	6853      	ldr	r3, [r2, #4]
18004860:	2101      	movs	r1, #1
18004862:	9301      	str	r3, [sp, #4]
18004864:	4b0c      	ldr	r3, [pc, #48]	; (18004898 <cmd_echo+0x40>)
18004866:	9300      	str	r3, [sp, #0]
18004868:	6813      	ldr	r3, [r2, #0]
1800486a:	4a0c      	ldr	r2, [pc, #48]	; (1800489c <cmd_echo+0x44>)
1800486c:	f004 fba4 	bl	18008fb8 <shell_fprintf>
18004870:	f06f 0015 	mvn.w	r0, #21
}
18004874:	b003      	add	sp, #12
18004876:	f85d fb04 	ldr.w	pc, [sp], #4
	return sh->ctx->cfg.flags.echo == 1;
1800487a:	6883      	ldr	r3, [r0, #8]
	shell_print(shell, "Echo status: %s",
1800487c:	4a08      	ldr	r2, [pc, #32]	; (180048a0 <cmd_echo+0x48>)
1800487e:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
18004882:	2108      	movs	r1, #8
18004884:	f013 0f02 	tst.w	r3, #2
18004888:	4b06      	ldr	r3, [pc, #24]	; (180048a4 <cmd_echo+0x4c>)
1800488a:	bf18      	it	ne
1800488c:	4613      	movne	r3, r2
1800488e:	4a06      	ldr	r2, [pc, #24]	; (180048a8 <cmd_echo+0x50>)
18004890:	f004 fb92 	bl	18008fb8 <shell_fprintf>
	return 0;
18004894:	2000      	movs	r0, #0
18004896:	e7ed      	b.n	18004874 <cmd_echo+0x1c>
18004898:	1800d2d1 	.word	0x1800d2d1
1800489c:	1800d2c8 	.word	0x1800d2c8
180048a0:	1800cda8 	.word	0x1800cda8
180048a4:	1800d2c4 	.word	0x1800d2c4
180048a8:	1800d2e6 	.word	0x1800d2e6

180048ac <cmd_clear>:
{
180048ac:	b510      	push	{r4, lr}
	return sh->ctx->cfg.flags.use_vt100 == 1;
180048ae:	6883      	ldr	r3, [r0, #8]
180048b0:	4604      	mov	r4, r0
180048b2:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
180048b6:	069a      	lsls	r2, r3, #26
180048b8:	d503      	bpl.n	180048c2 <cmd_clear+0x16>
180048ba:	4907      	ldr	r1, [pc, #28]	; (180048d8 <cmd_clear+0x2c>)
180048bc:	6940      	ldr	r0, [r0, #20]
180048be:	f005 f924 	bl	18009b0a <z_shell_raw_fprintf>
180048c2:	68a3      	ldr	r3, [r4, #8]
180048c4:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
180048c8:	069b      	lsls	r3, r3, #26
180048ca:	d503      	bpl.n	180048d4 <cmd_clear+0x28>
180048cc:	4903      	ldr	r1, [pc, #12]	; (180048dc <cmd_clear+0x30>)
180048ce:	6960      	ldr	r0, [r4, #20]
180048d0:	f005 f91b 	bl	18009b0a <z_shell_raw_fprintf>
}
180048d4:	2000      	movs	r0, #0
180048d6:	bd10      	pop	{r4, pc}
180048d8:	1800b4d1 	.word	0x1800b4d1
180048dc:	1800b4d6 	.word	0x1800b4d6

180048e0 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
180048e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	int err;

	if (argc != 1) {
180048e2:	2901      	cmp	r1, #1
{
180048e4:	4604      	mov	r4, r0
180048e6:	b085      	sub	sp, #20
	if (argc != 1) {
180048e8:	d00d      	beq.n	18004906 <cmd_resize+0x26>
		shell_error(shell, "%s:%s%s", argv[0],
180048ea:	6853      	ldr	r3, [r2, #4]
180048ec:	2101      	movs	r1, #1
180048ee:	9301      	str	r3, [sp, #4]
180048f0:	4b58      	ldr	r3, [pc, #352]	; (18004a54 <cmd_resize+0x174>)
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
180048f2:	f06f 0515 	mvn.w	r5, #21
		shell_error(shell, "%s:%s%s", argv[0],
180048f6:	9300      	str	r3, [sp, #0]
180048f8:	6813      	ldr	r3, [r2, #0]
180048fa:	4a57      	ldr	r2, [pc, #348]	; (18004a58 <cmd_resize+0x178>)
180048fc:	f004 fb5c 	bl	18008fb8 <shell_fprintf>
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
18004900:	4628      	mov	r0, r5
18004902:	b005      	add	sp, #20
18004904:	bdf0      	pop	{r4, r5, r6, r7, pc}
18004906:	6883      	ldr	r3, [r0, #8]
18004908:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
1800490c:	069a      	lsls	r2, r3, #26
1800490e:	d503      	bpl.n	18004918 <cmd_resize+0x38>
18004910:	4952      	ldr	r1, [pc, #328]	; (18004a5c <cmd_resize+0x17c>)
18004912:	6940      	ldr	r0, [r0, #20]
18004914:	f005 f8f9 	bl	18009b0a <z_shell_raw_fprintf>
	char c = 0;
18004918:	2500      	movs	r5, #0
	z_shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
1800491a:	f06f 01f9 	mvn.w	r1, #249	; 0xf9
1800491e:	4620      	mov	r0, r4
18004920:	f7ff fd6c 	bl	180043fc <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
18004924:	21fa      	movs	r1, #250	; 0xfa
18004926:	4620      	mov	r0, r4
18004928:	f7ff fd7e 	bl	18004428 <z_shell_op_cursor_horiz_move>
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
1800492c:	68a0      	ldr	r0, [r4, #8]
1800492e:	f44f 7280 	mov.w	r2, #256	; 0x100
18004932:	4629      	mov	r1, r5
18004934:	f500 70a1 	add.w	r0, r0, #322	; 0x142
	char c = 0;
18004938:	f88d 500b 	strb.w	r5, [sp, #11]
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
1800493c:	f005 fc14 	bl	1800a168 <memset>
	z_shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
18004940:	4947      	ldr	r1, [pc, #284]	; (18004a60 <cmd_resize+0x180>)
18004942:	6960      	ldr	r0, [r4, #20]
18004944:	f005 f8e1 	bl	18009b0a <z_shell_raw_fprintf>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
18004948:	6960      	ldr	r0, [r4, #20]
1800494a:	f004 fb45 	bl	18008fd8 <z_shell_fprintf_buffer_flush>
1800494e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
			(void)shell->iface->api->read(shell->iface, &c,
18004952:	6860      	ldr	r0, [r4, #4]
18004954:	2201      	movs	r2, #1
18004956:	6803      	ldr	r3, [r0, #0]
18004958:	f10d 010b 	add.w	r1, sp, #11
1800495c:	691f      	ldr	r7, [r3, #16]
1800495e:	ab03      	add	r3, sp, #12
18004960:	47b8      	blx	r7
			if (cnt == 0) {
18004962:	9b03      	ldr	r3, [sp, #12]
18004964:	b953      	cbnz	r3, 1800497c <cmd_resize+0x9c>
	for (uint16_t i = 0; i < 1000; i++) {
18004966:	3e01      	subs	r6, #1
	z_impl_k_busy_wait(usec_to_wait);
18004968:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
1800496c:	b2b6      	uxth	r6, r6
1800496e:	f003 f8e5 	bl	18007b3c <z_impl_k_busy_wait>
18004972:	2e00      	cmp	r6, #0
18004974:	d1ed      	bne.n	18004952 <cmd_resize+0x72>
		ret_val = -ENOTSUP;
18004976:	f06f 0585 	mvn.w	r5, #133	; 0x85
1800497a:	e034      	b.n	180049e6 <cmd_resize+0x106>
			if ((c != SHELL_VT100_ASCII_ESC) &&
1800497c:	f89d 300b 	ldrb.w	r3, [sp, #11]
			    (shell->ctx->temp_buff[0] !=
18004980:	68a1      	ldr	r1, [r4, #8]
			if ((c != SHELL_VT100_ASCII_ESC) &&
18004982:	2b1b      	cmp	r3, #27
18004984:	d05a      	beq.n	18004a3c <cmd_resize+0x15c>
18004986:	f891 2142 	ldrb.w	r2, [r1, #322]	; 0x142
1800498a:	2a1b      	cmp	r2, #27
1800498c:	d1e1      	bne.n	18004952 <cmd_resize+0x72>
			if (c == 'R') { /* End of response from the terminal. */
1800498e:	2b52      	cmp	r3, #82	; 0x52
18004990:	d154      	bne.n	18004a3c <cmd_resize+0x15c>
				shell->ctx->temp_buff[buff_idx] = '\0';
18004992:	2300      	movs	r3, #0
18004994:	440d      	add	r5, r1
18004996:	f885 3142 	strb.w	r3, [r5, #322]	; 0x142
				if (shell->ctx->temp_buff[1] != '[') {
1800499a:	f891 2143 	ldrb.w	r2, [r1, #323]	; 0x143
1800499e:	2a5b      	cmp	r2, #91	; 0x5b
180049a0:	d154      	bne.n	18004a4c <cmd_resize+0x16c>
	*y = 0U;
180049a2:	461f      	mov	r7, r3
				buff_idx = 2U;
180049a4:	2602      	movs	r6, #2
180049a6:	f501 75a2 	add.w	r5, r1, #324	; 0x144
				while (shell->ctx->temp_buff[buff_idx] != ';') {
180049aa:	f815 0b01 	ldrb.w	r0, [r5], #1
180049ae:	4632      	mov	r2, r6
180049b0:	283b      	cmp	r0, #59	; 0x3b
					(shell->ctx->temp_buff[buff_idx++] -
180049b2:	f106 0601 	add.w	r6, r6, #1
180049b6:	b2b6      	uxth	r6, r6
				while (shell->ctx->temp_buff[buff_idx] != ';') {
180049b8:	d12b      	bne.n	18004a12 <cmd_resize+0x132>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
180049ba:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
180049be:	d0da      	beq.n	18004976 <cmd_resize+0x96>
	*x = 0U;
180049c0:	2300      	movs	r3, #0
180049c2:	f202 1243 	addw	r2, r2, #323	; 0x143
180049c6:	fa11 f282 	uxtah	r2, r1, r2
				while (shell->ctx->temp_buff[buff_idx]
180049ca:	f812 5b01 	ldrb.w	r5, [r2], #1
180049ce:	bb55      	cbnz	r5, 18004a26 <cmd_resize+0x146>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
180049d0:	2bfa      	cmp	r3, #250	; 0xfa
180049d2:	bf28      	it	cs
180049d4:	23fa      	movcs	r3, #250	; 0xfa
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
180049d6:	2ffa      	cmp	r7, #250	; 0xfa
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
180049d8:	854b      	strh	r3, [r1, #42]	; 0x2a
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
180049da:	463b      	mov	r3, r7
180049dc:	bf28      	it	cs
180049de:	23fa      	movcs	r3, #250	; 0xfa
				shell->ctx->temp_buff[0] = 0;
180049e0:	f881 5142 	strb.w	r5, [r1, #322]	; 0x142
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
180049e4:	850b      	strh	r3, [r1, #40]	; 0x28
	return sh->ctx->cfg.flags.use_vt100 == 1;
180049e6:	68a3      	ldr	r3, [r4, #8]
180049e8:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
180049ec:	069b      	lsls	r3, r3, #26
180049ee:	d503      	bpl.n	180049f8 <cmd_resize+0x118>
180049f0:	491c      	ldr	r1, [pc, #112]	; (18004a64 <cmd_resize+0x184>)
180049f2:	6960      	ldr	r0, [r4, #20]
180049f4:	f005 f889 	bl	18009b0a <z_shell_raw_fprintf>
	if (err != 0) {
180049f8:	2d00      	cmp	r5, #0
180049fa:	d081      	beq.n	18004900 <cmd_resize+0x20>
		shell->ctx->vt100_ctx.cons.terminal_hei =
180049fc:	68a3      	ldr	r3, [r4, #8]
180049fe:	4a1a      	ldr	r2, [pc, #104]	; (18004a68 <cmd_resize+0x188>)
		shell_warn(shell, "No response from the terminal, assumed 80x24"
18004a00:	2103      	movs	r1, #3
		shell->ctx->vt100_ctx.cons.terminal_hei =
18004a02:	629a      	str	r2, [r3, #40]	; 0x28
		shell_warn(shell, "No response from the terminal, assumed 80x24"
18004a04:	4620      	mov	r0, r4
18004a06:	4a19      	ldr	r2, [pc, #100]	; (18004a6c <cmd_resize+0x18c>)
18004a08:	f004 fad6 	bl	18008fb8 <shell_fprintf>
18004a0c:	f06f 0507 	mvn.w	r5, #7
18004a10:	e776      	b.n	18004900 <cmd_resize+0x20>
					*y = *y * 10U +
18004a12:	eb07 0387 	add.w	r3, r7, r7, lsl #2
18004a16:	eb00 0343 	add.w	r3, r0, r3, lsl #1
18004a1a:	3b30      	subs	r3, #48	; 0x30
					if (buff_idx >=
18004a1c:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
					*y = *y * 10U +
18004a20:	b29f      	uxth	r7, r3
					if (buff_idx >=
18004a22:	d1c2      	bne.n	180049aa <cmd_resize+0xca>
18004a24:	e7a7      	b.n	18004976 <cmd_resize+0x96>
					*x = *x * 10U +
18004a26:	eb03 0383 	add.w	r3, r3, r3, lsl #2
					(shell->ctx->temp_buff[buff_idx++] -
18004a2a:	3601      	adds	r6, #1
					*x = *x * 10U +
18004a2c:	eb05 0543 	add.w	r5, r5, r3, lsl #1
					(shell->ctx->temp_buff[buff_idx++] -
18004a30:	b2b6      	uxth	r6, r6
					*x = *x * 10U +
18004a32:	3d30      	subs	r5, #48	; 0x30
					if (buff_idx >=
18004a34:	2eff      	cmp	r6, #255	; 0xff
					*x = *x * 10U +
18004a36:	b2ab      	uxth	r3, r5
					if (buff_idx >=
18004a38:	d9c7      	bls.n	180049ca <cmd_resize+0xea>
18004a3a:	e79c      	b.n	18004976 <cmd_resize+0x96>
			shell->ctx->temp_buff[buff_idx] = c;
18004a3c:	194a      	adds	r2, r1, r5
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
18004a3e:	3501      	adds	r5, #1
18004a40:	b2ad      	uxth	r5, r5
18004a42:	2d09      	cmp	r5, #9
			shell->ctx->temp_buff[buff_idx] = c;
18004a44:	f882 3142 	strb.w	r3, [r2, #322]	; 0x142
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
18004a48:	d983      	bls.n	18004952 <cmd_resize+0x72>
				shell->ctx->temp_buff[0] = 0;
18004a4a:	2300      	movs	r3, #0
18004a4c:	f881 3142 	strb.w	r3, [r1, #322]	; 0x142
				return -ENOMEM;
18004a50:	e791      	b.n	18004976 <cmd_resize+0x96>
18004a52:	bf00      	nop
18004a54:	1800d2d1 	.word	0x1800d2d1
18004a58:	1800d2c8 	.word	0x1800d2c8
18004a5c:	1800b4dc 	.word	0x1800b4dc
18004a60:	1800d6f5 	.word	0x1800d6f5
18004a64:	1800b4e0 	.word	0x1800b4e0
18004a68:	00500018 	.word	0x00500018
18004a6c:	1800d2f7 	.word	0x1800d2f7

18004a70 <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *shell,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
18004a70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18004a74:	4607      	mov	r7, r0
18004a76:	4615      	mov	r5, r2
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
18004a78:	4689      	mov	r9, r1
{
18004a7a:	b089      	sub	sp, #36	; 0x24
	if (cmd == NULL) {
18004a7c:	b921      	cbnz	r1, 18004a88 <z_shell_wildcard_process+0x18>
		return ret_val;
18004a7e:	2403      	movs	r4, #3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
18004a80:	4620      	mov	r0, r4
18004a82:	b009      	add	sp, #36	; 0x24
18004a84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!z_shell_has_wildcard(pattern)) {
18004a88:	4610      	mov	r0, r2
18004a8a:	f005 f957 	bl	18009d3c <z_shell_has_wildcard>
18004a8e:	2800      	cmp	r0, #0
18004a90:	d0f5      	beq.n	18004a7e <z_shell_wildcard_process+0xe>
	size_t cnt = 0;
18004a92:	f04f 0800 	mov.w	r8, #0
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
18004a96:	2402      	movs	r4, #2
	size_t cmd_idx = 0;
18004a98:	4641      	mov	r1, r8
18004a9a:	e024      	b.n	18004ae6 <z_shell_wildcard_process+0x76>
	return str == NULL ? 0U : (uint16_t)strlen(str);
18004a9c:	465c      	mov	r4, fp
18004a9e:	e03c      	b.n	18004b1a <z_shell_wildcard_process+0xaa>
	completion_addr = strstr(buff, pattern);
18004aa0:	4629      	mov	r1, r5
18004aa2:	f50a 70a1 	add.w	r0, sl, #322	; 0x142
18004aa6:	f005 fab4 	bl	1800a012 <strstr>
	if (!completion_addr) {
18004aaa:	4606      	mov	r6, r0
18004aac:	2800      	cmp	r0, #0
18004aae:	d04e      	beq.n	18004b4e <z_shell_wildcard_process+0xde>
18004ab0:	f005 faf9 	bl	1800a0a6 <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
18004ab4:	b282      	uxth	r2, r0
18004ab6:	1c60      	adds	r0, r4, #1
18004ab8:	4631      	mov	r1, r6
18004aba:	3201      	adds	r2, #1
18004abc:	4430      	add	r0, r6
18004abe:	f005 fb30 	bl	1800a122 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
18004ac2:	4622      	mov	r2, r4
18004ac4:	4659      	mov	r1, fp
18004ac6:	4630      	mov	r0, r6
18004ac8:	f005 fb43 	bl	1800a152 <memcpy>
	completion_addr[cmd_len] = ' ';
18004acc:	f04f 0320 	mov.w	r3, #32
18004ad0:	5533      	strb	r3, [r6, r4]
	*buff_len += cmd_len + 1; /* + 1 for space */
18004ad2:	f8ba 0040 	ldrh.w	r0, [sl, #64]	; 0x40
			cnt++;
18004ad6:	f108 0801 	add.w	r8, r8, #1
	*buff_len += cmd_len + 1; /* + 1 for space */
18004ada:	4404      	add	r4, r0
18004adc:	3401      	adds	r4, #1
18004ade:	f8aa 4040 	strh.w	r4, [sl, #64]	; 0x40
			ret_val = command_add(shell->ctx->temp_buff,
18004ae2:	2400      	movs	r4, #0
18004ae4:	9901      	ldr	r1, [sp, #4]
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
18004ae6:	1c4b      	adds	r3, r1, #1
18004ae8:	4648      	mov	r0, r9
18004aea:	aa03      	add	r2, sp, #12
18004aec:	9301      	str	r3, [sp, #4]
18004aee:	f7ff fc4d 	bl	1800438c <z_shell_cmd_get>
18004af2:	4606      	mov	r6, r0
18004af4:	b1f8      	cbz	r0, 18004b36 <z_shell_wildcard_process+0xc6>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
18004af6:	2200      	movs	r2, #0
18004af8:	4628      	mov	r0, r5
18004afa:	6831      	ldr	r1, [r6, #0]
18004afc:	f003 fe10 	bl	18008720 <fnmatch>
18004b00:	2800      	cmp	r0, #0
18004b02:	d1ef      	bne.n	18004ae4 <z_shell_wildcard_process+0x74>
			ret_val = command_add(shell->ctx->temp_buff,
18004b04:	f8d6 b000 	ldr.w	fp, [r6]
18004b08:	f8d7 a008 	ldr.w	sl, [r7, #8]
18004b0c:	f1bb 0f00 	cmp.w	fp, #0
18004b10:	d0c4      	beq.n	18004a9c <z_shell_wildcard_process+0x2c>
18004b12:	4658      	mov	r0, fp
18004b14:	f005 fac7 	bl	1800a0a6 <strlen>
18004b18:	b284      	uxth	r4, r0
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
18004b1a:	f8ba 2040 	ldrh.w	r2, [sl, #64]	; 0x40
18004b1e:	3201      	adds	r2, #1
18004b20:	4422      	add	r2, r4
18004b22:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
18004b26:	ddbb      	ble.n	18004aa0 <z_shell_wildcard_process+0x30>
				z_shell_fprintf(shell, SHELL_WARNING,
18004b28:	462b      	mov	r3, r5
18004b2a:	2103      	movs	r1, #3
18004b2c:	4638      	mov	r0, r7
18004b2e:	4a09      	ldr	r2, [pc, #36]	; (18004b54 <z_shell_wildcard_process+0xe4>)
18004b30:	f004 fdd0 	bl	180096d4 <z_shell_fprintf>
			ret_val = command_add(shell->ctx->temp_buff,
18004b34:	2401      	movs	r4, #1
	if (cnt > 0) {
18004b36:	f1b8 0f00 	cmp.w	r8, #0
18004b3a:	d0a1      	beq.n	18004a80 <z_shell_wildcard_process+0x10>
		z_shell_pattern_remove(shell->ctx->temp_buff,
18004b3c:	68b8      	ldr	r0, [r7, #8]
18004b3e:	462a      	mov	r2, r5
18004b40:	f100 0140 	add.w	r1, r0, #64	; 0x40
18004b44:	f500 70a1 	add.w	r0, r0, #322	; 0x142
18004b48:	f004 fb72 	bl	18009230 <z_shell_pattern_remove>
	return ret_val;
18004b4c:	e798      	b.n	18004a80 <z_shell_wildcard_process+0x10>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
18004b4e:	2402      	movs	r4, #2
18004b50:	e7f1      	b.n	18004b36 <z_shell_wildcard_process+0xc6>
18004b52:	bf00      	nop
18004b54:	1800d6fa 	.word	0x1800d6fa

18004b58 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
18004b58:	4901      	ldr	r1, [pc, #4]	; (18004b60 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
18004b5a:	2210      	movs	r2, #16
	str	r2, [r1]
18004b5c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
18004b5e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
18004b60:	e000ed10 	.word	0xe000ed10

18004b64 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
18004b64:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
18004b66:	4040      	eors	r0, r0
	msr	BASEPRI, r0
18004b68:	f380 8811 	msr	BASEPRI, r0
	isb
18004b6c:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
18004b70:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
18004b74:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
18004b76:	b662      	cpsie	i
	isb
18004b78:	f3bf 8f6f 	isb	sy

	bx	lr
18004b7c:	4770      	bx	lr
18004b7e:	bf00      	nop

18004b80 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
18004b80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
18004b82:	4607      	mov	r7, r0

	if (esf != NULL) {
18004b84:	460c      	mov	r4, r1
18004b86:	b361      	cbz	r1, 18004be2 <z_arm_fatal_error+0x62>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
18004b88:	4e19      	ldr	r6, [pc, #100]	; (18004bf0 <z_arm_fatal_error+0x70>)
18004b8a:	6833      	ldr	r3, [r6, #0]
18004b8c:	0758      	lsls	r0, r3, #29
18004b8e:	d028      	beq.n	18004be2 <z_arm_fatal_error+0x62>
18004b90:	4d18      	ldr	r5, [pc, #96]	; (18004bf4 <z_arm_fatal_error+0x74>)
18004b92:	4819      	ldr	r0, [pc, #100]	; (18004bf8 <z_arm_fatal_error+0x78>)
18004b94:	1b75      	subs	r5, r6, r5
18004b96:	08ad      	lsrs	r5, r5, #2
18004b98:	01ad      	lsls	r5, r5, #6
18004b9a:	f045 0501 	orr.w	r5, r5, #1
18004b9e:	f8ad 5000 	strh.w	r5, [sp]
18004ba2:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
18004ba6:	6809      	ldr	r1, [r1, #0]
18004ba8:	f003 fe3b 	bl	18008822 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
18004bac:	6833      	ldr	r3, [r6, #0]
18004bae:	0759      	lsls	r1, r3, #29
18004bb0:	d017      	beq.n	18004be2 <z_arm_fatal_error+0x62>
18004bb2:	f8ad 5000 	strh.w	r5, [sp]
18004bb6:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
18004bba:	68e1      	ldr	r1, [r4, #12]
18004bbc:	480f      	ldr	r0, [pc, #60]	; (18004bfc <z_arm_fatal_error+0x7c>)
18004bbe:	f003 fe30 	bl	18008822 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
18004bc2:	6833      	ldr	r3, [r6, #0]
18004bc4:	075a      	lsls	r2, r3, #29
18004bc6:	d00c      	beq.n	18004be2 <z_arm_fatal_error+0x62>
18004bc8:	462a      	mov	r2, r5
18004bca:	69e1      	ldr	r1, [r4, #28]
18004bcc:	480c      	ldr	r0, [pc, #48]	; (18004c00 <z_arm_fatal_error+0x80>)
18004bce:	f003 fdfb 	bl	180087c8 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
18004bd2:	6833      	ldr	r3, [r6, #0]
18004bd4:	075b      	lsls	r3, r3, #29
18004bd6:	d004      	beq.n	18004be2 <z_arm_fatal_error+0x62>
18004bd8:	462a      	mov	r2, r5
18004bda:	69a1      	ldr	r1, [r4, #24]
18004bdc:	4809      	ldr	r0, [pc, #36]	; (18004c04 <z_arm_fatal_error+0x84>)
18004bde:	f003 fdf3 	bl	180087c8 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
18004be2:	4621      	mov	r1, r4
18004be4:	4638      	mov	r0, r7
}
18004be6:	b003      	add	sp, #12
18004be8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	z_fatal_error(reason, esf);
18004bec:	f001 be34 	b.w	18006858 <z_fatal_error>
18004bf0:	3018009c 	.word	0x3018009c
18004bf4:	3018008c 	.word	0x3018008c
18004bf8:	1800d74c 	.word	0x1800d74c
18004bfc:	1800d77b 	.word	0x1800d77b
18004c00:	1800d7aa 	.word	0x1800d7aa
18004c04:	1800d7b9 	.word	0x1800d7b9

18004c08 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
18004c08:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
18004c0a:	2b00      	cmp	r3, #0
18004c0c:	db08      	blt.n	18004c20 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
18004c0e:	2201      	movs	r2, #1
18004c10:	f000 001f 	and.w	r0, r0, #31
18004c14:	fa02 f000 	lsl.w	r0, r2, r0
18004c18:	4a02      	ldr	r2, [pc, #8]	; (18004c24 <arch_irq_enable+0x1c>)
18004c1a:	095b      	lsrs	r3, r3, #5
18004c1c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
18004c20:	4770      	bx	lr
18004c22:	bf00      	nop
18004c24:	e000e100 	.word	0xe000e100

18004c28 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
18004c28:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
18004c2a:	2b00      	cmp	r3, #0
		prio += _IRQ_PRIO_OFFSET;
18004c2c:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
18004c30:	bfac      	ite	ge
18004c32:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
18004c36:	4b06      	ldrlt	r3, [pc, #24]	; (18004c50 <z_arm_irq_priority_set+0x28>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
18004c38:	ea4f 1141 	mov.w	r1, r1, lsl #5
18004c3c:	b2c9      	uxtb	r1, r1
18004c3e:	bfab      	itete	ge
18004c40:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
18004c44:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
18004c48:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
18004c4c:	5419      	strblt	r1, [r3, r0]
}
18004c4e:	4770      	bx	lr
18004c50:	e000ed14 	.word	0xe000ed14

18004c54 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
18004c54:	bf30      	wfi
    b z_SysNmiOnReset
18004c56:	f7ff bffd 	b.w	18004c54 <z_SysNmiOnReset>
18004c5a:	bf00      	nop

18004c5c <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
18004c5c:	4a0f      	ldr	r2, [pc, #60]	; (18004c9c <z_arm_prep_c+0x40>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
18004c5e:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
18004c60:	4b0f      	ldr	r3, [pc, #60]	; (18004ca0 <z_arm_prep_c+0x44>)
18004c62:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
18004c66:	609a      	str	r2, [r3, #8]
18004c68:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
18004c6c:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
18004c70:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
18004c74:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
18004c78:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
18004c7c:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
18004c80:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
18004c84:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
18004c88:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
18004c8c:	f001 feaa 	bl	180069e4 <z_bss_zero>
	z_data_copy();
18004c90:	f002 fe00 	bl	18007894 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
18004c94:	f000 fc8c 	bl	180055b0 <z_arm_interrupt_init>
	z_cstart();
18004c98:	f001 feae 	bl	180069f8 <z_cstart>
18004c9c:	18001200 	.word	0x18001200
18004ca0:	e000ed00 	.word	0xe000ed00

18004ca4 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
18004ca4:	4a0a      	ldr	r2, [pc, #40]	; (18004cd0 <arch_swap+0x2c>)
	_current->arch.swap_return_value = _k_neg_eagain;
18004ca6:	490b      	ldr	r1, [pc, #44]	; (18004cd4 <arch_swap+0x30>)
	_current->arch.basepri = key;
18004ca8:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
18004caa:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
18004cac:	f8c3 00ac 	str.w	r0, [r3, #172]	; 0xac
	_current->arch.swap_return_value = _k_neg_eagain;
18004cb0:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
18004cb4:	4908      	ldr	r1, [pc, #32]	; (18004cd8 <arch_swap+0x34>)
18004cb6:	684b      	ldr	r3, [r1, #4]
18004cb8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
18004cbc:	604b      	str	r3, [r1, #4]
18004cbe:	2300      	movs	r3, #0
18004cc0:	f383 8811 	msr	BASEPRI, r3
18004cc4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
18004cc8:	6893      	ldr	r3, [r2, #8]
}
18004cca:	f8d3 00b0 	ldr.w	r0, [r3, #176]	; 0xb0
18004cce:	4770      	bx	lr
18004cd0:	30180a20 	.word	0x30180a20
18004cd4:	1800bbf4 	.word	0x1800bbf4
18004cd8:	e000ed00 	.word	0xe000ed00

18004cdc <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
18004cdc:	4914      	ldr	r1, [pc, #80]	; (18004d30 <z_arm_pendsv+0x54>)
    ldr r2, [r1, #_kernel_offset_to_current]
18004cde:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
18004ce0:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
18004ce4:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
18004ce6:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
18004cea:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
18004cee:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
18004cf0:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
18004cf4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
18004cf8:	4f0e      	ldr	r7, [pc, #56]	; (18004d34 <z_arm_pendsv+0x58>)
    ldr v3, =_SCS_ICSR_UNPENDSV
18004cfa:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
18004cfe:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
18004d00:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
18004d02:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
18004d04:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    movs r3, #0
18004d08:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
18004d0a:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
18004d0e:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
18004d12:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
18004d16:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
18004d1a:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
18004d1e:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
18004d22:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
18004d24:	f005 f861 	bl	18009dea <configure_builtin_stack_guard>
    pop {r2, lr}
18004d28:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
18004d2c:	4770      	bx	lr
18004d2e:	0000      	.short	0x0000
    ldr r1, =_kernel
18004d30:	30180a20 	.word	0x30180a20
    ldr v4, =_SCS_ICSR
18004d34:	e000ed04 	.word	0xe000ed04

18004d38 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
18004d38:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
18004d3c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
18004d3e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
18004d42:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
18004d46:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
18004d48:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
18004d4c:	2902      	cmp	r1, #2
    beq _oops
18004d4e:	d0ff      	beq.n	18004d50 <_oops>

18004d50 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
18004d50:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
18004d52:	f005 f83b 	bl	18009dcc <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
18004d56:	bd01      	pop	{r0, pc}

18004d58 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
18004d58:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
18004d5c:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
18004d5e:	490b      	ldr	r1, [pc, #44]	; (18004d8c <arch_new_thread+0x34>)
	iframe->a2 = (uint32_t)p1;
18004d60:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
18004d64:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
18004d66:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
18004d6a:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
18004d6e:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
18004d70:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
18004d74:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
18004d78:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
18004d7c:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
18004d80:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
18004d82:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
18004d84:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
18004d86:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
18004d8a:	4770      	bx	lr
18004d8c:	180080ad 	.word	0x180080ad

18004d90 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
18004d90:	4b09      	ldr	r3, [pc, #36]	; (18004db8 <arch_switch_to_main_thread+0x28>)
18004d92:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
18004d94:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
18004d98:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
18004d9c:	4610      	mov	r0, r2
18004d9e:	f381 8809 	msr	PSP, r1
18004da2:	2100      	movs	r1, #0
18004da4:	b663      	cpsie	if
18004da6:	f381 8811 	msr	BASEPRI, r1
18004daa:	f3bf 8f6f 	isb	sy
18004dae:	2200      	movs	r2, #0
18004db0:	2300      	movs	r3, #0
18004db2:	f003 f97b 	bl	180080ac <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
18004db6:	bf00      	nop
18004db8:	30180a20 	.word	0x30180a20

18004dbc <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
18004dbc:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
18004dbe:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
18004dc2:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
18004dc6:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
18004dca:	4904      	ldr	r1, [pc, #16]	; (18004ddc <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
18004dcc:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
18004dce:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
18004dd0:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
18004dd2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
18004dd6:	4902      	ldr	r1, [pc, #8]	; (18004de0 <_isr_wrapper+0x24>)
	bx r1
18004dd8:	4708      	bx	r1
18004dda:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
18004ddc:	1800b1e0 	.word	0x1800b1e0
	ldr r1, =z_arm_int_exit
18004de0:	18004de5 	.word	0x18004de5

18004de4 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
18004de4:	4b04      	ldr	r3, [pc, #16]	; (18004df8 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
18004de6:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
18004de8:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
18004dea:	4288      	cmp	r0, r1
	beq _EXIT_EXC
18004dec:	d003      	beq.n	18004df6 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
18004dee:	4903      	ldr	r1, [pc, #12]	; (18004dfc <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
18004df0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
18004df4:	600a      	str	r2, [r1, #0]

18004df6 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
18004df6:	4770      	bx	lr
	ldr r3, =_kernel
18004df8:	30180a20 	.word	0x30180a20
	ldr r1, =_SCS_ICSR
18004dfc:	e000ed04 	.word	0xe000ed04

18004e00 <secure_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void secure_fault(const z_arch_esf_t *esf)
18004e00:	b510      	push	{r4, lr}
{
	PR_FAULT_INFO("***** SECURE FAULT *****");
18004e02:	4c49      	ldr	r4, [pc, #292]	; (18004f28 <secure_fault.constprop.0+0x128>)
18004e04:	6823      	ldr	r3, [r4, #0]
18004e06:	075a      	lsls	r2, r3, #29
18004e08:	d008      	beq.n	18004e1c <secure_fault.constprop.0+0x1c>
18004e0a:	4948      	ldr	r1, [pc, #288]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004e0c:	4848      	ldr	r0, [pc, #288]	; (18004f30 <secure_fault.constprop.0+0x130>)
18004e0e:	1a61      	subs	r1, r4, r1
18004e10:	0889      	lsrs	r1, r1, #2
18004e12:	0189      	lsls	r1, r1, #6
18004e14:	f041 0101 	orr.w	r1, r1, #1
18004e18:	f003 fcc9 	bl	180087ae <log_0>

	STORE_xFAR(sfar, SAU->SFAR);
18004e1c:	4b45      	ldr	r3, [pc, #276]	; (18004f34 <secure_fault.constprop.0+0x134>)
18004e1e:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
	if ((SAU->SFSR & SAU_SFSR_SFARVALID_Msk) != 0) {
18004e22:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
18004e26:	065b      	lsls	r3, r3, #25
18004e28:	d50b      	bpl.n	18004e42 <secure_fault.constprop.0+0x42>
		PR_EXC("  Address: 0x%x", sfar);
18004e2a:	6823      	ldr	r3, [r4, #0]
18004e2c:	0758      	lsls	r0, r3, #29
18004e2e:	d008      	beq.n	18004e42 <secure_fault.constprop.0+0x42>
18004e30:	4a3e      	ldr	r2, [pc, #248]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004e32:	4841      	ldr	r0, [pc, #260]	; (18004f38 <secure_fault.constprop.0+0x138>)
18004e34:	1aa2      	subs	r2, r4, r2
18004e36:	0892      	lsrs	r2, r2, #2
18004e38:	0192      	lsls	r2, r2, #6
18004e3a:	f042 0201 	orr.w	r2, r2, #1
18004e3e:	f003 fcc3 	bl	180087c8 <log_1>
	}

	/* bits are sticky: they stack and must be reset */
	if ((SAU->SFSR & SAU_SFSR_INVEP_Msk) != 0) {
18004e42:	4b3c      	ldr	r3, [pc, #240]	; (18004f34 <secure_fault.constprop.0+0x134>)
18004e44:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
18004e48:	07d2      	lsls	r2, r2, #31
18004e4a:	d513      	bpl.n	18004e74 <secure_fault.constprop.0+0x74>
		PR_FAULT_INFO("  Invalid entry point");
18004e4c:	6823      	ldr	r3, [r4, #0]
18004e4e:	075b      	lsls	r3, r3, #29
18004e50:	d008      	beq.n	18004e64 <secure_fault.constprop.0+0x64>
18004e52:	4936      	ldr	r1, [pc, #216]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004e54:	4839      	ldr	r0, [pc, #228]	; (18004f3c <secure_fault.constprop.0+0x13c>)
18004e56:	1a61      	subs	r1, r4, r1
18004e58:	0889      	lsrs	r1, r1, #2
18004e5a:	0189      	lsls	r1, r1, #6
18004e5c:	f041 0101 	orr.w	r1, r1, #1
	} else if ((SAU->SFSR & SAU_SFSR_INVTRAN_Msk) != 0) {
		PR_FAULT_INFO("  Invalid transition");
	} else if ((SAU->SFSR & SAU_SFSR_LSPERR_Msk) != 0) {
		PR_FAULT_INFO("  Lazy state preservation");
	} else if ((SAU->SFSR & SAU_SFSR_LSERR_Msk) != 0) {
		PR_FAULT_INFO("  Lazy state error");
18004e60:	f003 fca5 	bl	180087ae <log_0>
	}

	/* clear SFSR sticky bits */
	SAU->SFSR |= 0xFF;
18004e64:	4a33      	ldr	r2, [pc, #204]	; (18004f34 <secure_fault.constprop.0+0x134>)
18004e66:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
18004e6a:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
18004e6e:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
}
18004e72:	bd10      	pop	{r4, pc}
	} else if ((SAU->SFSR & SAU_SFSR_INVIS_Msk) != 0) {
18004e74:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
18004e78:	0790      	lsls	r0, r2, #30
18004e7a:	d50a      	bpl.n	18004e92 <secure_fault.constprop.0+0x92>
		PR_FAULT_INFO("  Invalid integrity signature");
18004e7c:	6823      	ldr	r3, [r4, #0]
18004e7e:	0759      	lsls	r1, r3, #29
18004e80:	d0f0      	beq.n	18004e64 <secure_fault.constprop.0+0x64>
18004e82:	492a      	ldr	r1, [pc, #168]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004e84:	482e      	ldr	r0, [pc, #184]	; (18004f40 <secure_fault.constprop.0+0x140>)
18004e86:	1a61      	subs	r1, r4, r1
18004e88:	0889      	lsrs	r1, r1, #2
18004e8a:	0189      	lsls	r1, r1, #6
18004e8c:	f041 0101 	orr.w	r1, r1, #1
18004e90:	e7e6      	b.n	18004e60 <secure_fault.constprop.0+0x60>
	} else if ((SAU->SFSR & SAU_SFSR_INVER_Msk) != 0) {
18004e92:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
18004e96:	0752      	lsls	r2, r2, #29
18004e98:	d50a      	bpl.n	18004eb0 <secure_fault.constprop.0+0xb0>
		PR_FAULT_INFO("  Invalid exception return");
18004e9a:	6823      	ldr	r3, [r4, #0]
18004e9c:	075b      	lsls	r3, r3, #29
18004e9e:	d0e1      	beq.n	18004e64 <secure_fault.constprop.0+0x64>
18004ea0:	4922      	ldr	r1, [pc, #136]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004ea2:	4828      	ldr	r0, [pc, #160]	; (18004f44 <secure_fault.constprop.0+0x144>)
18004ea4:	1a61      	subs	r1, r4, r1
18004ea6:	0889      	lsrs	r1, r1, #2
18004ea8:	0189      	lsls	r1, r1, #6
18004eaa:	f041 0101 	orr.w	r1, r1, #1
18004eae:	e7d7      	b.n	18004e60 <secure_fault.constprop.0+0x60>
	} else if ((SAU->SFSR & SAU_SFSR_AUVIOL_Msk) != 0) {
18004eb0:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
18004eb4:	0710      	lsls	r0, r2, #28
18004eb6:	d50a      	bpl.n	18004ece <secure_fault.constprop.0+0xce>
		PR_FAULT_INFO("  Attribution unit violation");
18004eb8:	6823      	ldr	r3, [r4, #0]
18004eba:	0759      	lsls	r1, r3, #29
18004ebc:	d0d2      	beq.n	18004e64 <secure_fault.constprop.0+0x64>
18004ebe:	491b      	ldr	r1, [pc, #108]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004ec0:	4821      	ldr	r0, [pc, #132]	; (18004f48 <secure_fault.constprop.0+0x148>)
18004ec2:	1a61      	subs	r1, r4, r1
18004ec4:	0889      	lsrs	r1, r1, #2
18004ec6:	0189      	lsls	r1, r1, #6
18004ec8:	f041 0101 	orr.w	r1, r1, #1
18004ecc:	e7c8      	b.n	18004e60 <secure_fault.constprop.0+0x60>
	} else if ((SAU->SFSR & SAU_SFSR_INVTRAN_Msk) != 0) {
18004ece:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
18004ed2:	06d2      	lsls	r2, r2, #27
18004ed4:	d50a      	bpl.n	18004eec <secure_fault.constprop.0+0xec>
		PR_FAULT_INFO("  Invalid transition");
18004ed6:	6823      	ldr	r3, [r4, #0]
18004ed8:	075b      	lsls	r3, r3, #29
18004eda:	d0c3      	beq.n	18004e64 <secure_fault.constprop.0+0x64>
18004edc:	4913      	ldr	r1, [pc, #76]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004ede:	481b      	ldr	r0, [pc, #108]	; (18004f4c <secure_fault.constprop.0+0x14c>)
18004ee0:	1a61      	subs	r1, r4, r1
18004ee2:	0889      	lsrs	r1, r1, #2
18004ee4:	0189      	lsls	r1, r1, #6
18004ee6:	f041 0101 	orr.w	r1, r1, #1
18004eea:	e7b9      	b.n	18004e60 <secure_fault.constprop.0+0x60>
	} else if ((SAU->SFSR & SAU_SFSR_LSPERR_Msk) != 0) {
18004eec:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
18004ef0:	0690      	lsls	r0, r2, #26
18004ef2:	d50a      	bpl.n	18004f0a <secure_fault.constprop.0+0x10a>
		PR_FAULT_INFO("  Lazy state preservation");
18004ef4:	6823      	ldr	r3, [r4, #0]
18004ef6:	0759      	lsls	r1, r3, #29
18004ef8:	d0b4      	beq.n	18004e64 <secure_fault.constprop.0+0x64>
18004efa:	490c      	ldr	r1, [pc, #48]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004efc:	4814      	ldr	r0, [pc, #80]	; (18004f50 <secure_fault.constprop.0+0x150>)
18004efe:	1a61      	subs	r1, r4, r1
18004f00:	0889      	lsrs	r1, r1, #2
18004f02:	0189      	lsls	r1, r1, #6
18004f04:	f041 0101 	orr.w	r1, r1, #1
18004f08:	e7aa      	b.n	18004e60 <secure_fault.constprop.0+0x60>
	} else if ((SAU->SFSR & SAU_SFSR_LSERR_Msk) != 0) {
18004f0a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
18004f0e:	061a      	lsls	r2, r3, #24
18004f10:	d5a8      	bpl.n	18004e64 <secure_fault.constprop.0+0x64>
		PR_FAULT_INFO("  Lazy state error");
18004f12:	6823      	ldr	r3, [r4, #0]
18004f14:	075b      	lsls	r3, r3, #29
18004f16:	d0a5      	beq.n	18004e64 <secure_fault.constprop.0+0x64>
18004f18:	4904      	ldr	r1, [pc, #16]	; (18004f2c <secure_fault.constprop.0+0x12c>)
18004f1a:	480e      	ldr	r0, [pc, #56]	; (18004f54 <secure_fault.constprop.0+0x154>)
18004f1c:	1a61      	subs	r1, r4, r1
18004f1e:	0889      	lsrs	r1, r1, #2
18004f20:	0189      	lsls	r1, r1, #6
18004f22:	f041 0101 	orr.w	r1, r1, #1
18004f26:	e79b      	b.n	18004e60 <secure_fault.constprop.0+0x60>
18004f28:	3018009c 	.word	0x3018009c
18004f2c:	3018008c 	.word	0x3018008c
18004f30:	1800d7e7 	.word	0x1800d7e7
18004f34:	e000ed00 	.word	0xe000ed00
18004f38:	1800d800 	.word	0x1800d800
18004f3c:	1800d810 	.word	0x1800d810
18004f40:	1800d826 	.word	0x1800d826
18004f44:	1800d844 	.word	0x1800d844
18004f48:	1800d85f 	.word	0x1800d85f
18004f4c:	1800d87c 	.word	0x1800d87c
18004f50:	1800d891 	.word	0x1800d891
18004f54:	1800d8ab 	.word	0x1800d8ab

18004f58 <usage_fault.constprop.0>:
static uint32_t usage_fault(const z_arch_esf_t *esf)
18004f58:	b538      	push	{r3, r4, r5, lr}
	PR_FAULT_INFO("***** USAGE FAULT *****");
18004f5a:	4c44      	ldr	r4, [pc, #272]	; (1800506c <usage_fault.constprop.0+0x114>)
18004f5c:	6823      	ldr	r3, [r4, #0]
18004f5e:	075d      	lsls	r5, r3, #29
18004f60:	d008      	beq.n	18004f74 <usage_fault.constprop.0+0x1c>
18004f62:	4943      	ldr	r1, [pc, #268]	; (18005070 <usage_fault.constprop.0+0x118>)
18004f64:	4843      	ldr	r0, [pc, #268]	; (18005074 <usage_fault.constprop.0+0x11c>)
18004f66:	1a61      	subs	r1, r4, r1
18004f68:	0889      	lsrs	r1, r1, #2
18004f6a:	0189      	lsls	r1, r1, #6
18004f6c:	f041 0101 	orr.w	r1, r1, #1
18004f70:	f003 fc1d 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
18004f74:	4b40      	ldr	r3, [pc, #256]	; (18005078 <usage_fault.constprop.0+0x120>)
18004f76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18004f78:	0198      	lsls	r0, r3, #6
18004f7a:	d50b      	bpl.n	18004f94 <usage_fault.constprop.0+0x3c>
		PR_FAULT_INFO("  Division by zero");
18004f7c:	6823      	ldr	r3, [r4, #0]
18004f7e:	0759      	lsls	r1, r3, #29
18004f80:	d008      	beq.n	18004f94 <usage_fault.constprop.0+0x3c>
18004f82:	493b      	ldr	r1, [pc, #236]	; (18005070 <usage_fault.constprop.0+0x118>)
18004f84:	483d      	ldr	r0, [pc, #244]	; (1800507c <usage_fault.constprop.0+0x124>)
18004f86:	1a61      	subs	r1, r4, r1
18004f88:	0889      	lsrs	r1, r1, #2
18004f8a:	0189      	lsls	r1, r1, #6
18004f8c:	f041 0101 	orr.w	r1, r1, #1
18004f90:	f003 fc0d 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
18004f94:	4b38      	ldr	r3, [pc, #224]	; (18005078 <usage_fault.constprop.0+0x120>)
18004f96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18004f98:	01da      	lsls	r2, r3, #7
18004f9a:	d50b      	bpl.n	18004fb4 <usage_fault.constprop.0+0x5c>
		PR_FAULT_INFO("  Unaligned memory access");
18004f9c:	6823      	ldr	r3, [r4, #0]
18004f9e:	075b      	lsls	r3, r3, #29
18004fa0:	d008      	beq.n	18004fb4 <usage_fault.constprop.0+0x5c>
18004fa2:	4933      	ldr	r1, [pc, #204]	; (18005070 <usage_fault.constprop.0+0x118>)
18004fa4:	4836      	ldr	r0, [pc, #216]	; (18005080 <usage_fault.constprop.0+0x128>)
18004fa6:	1a61      	subs	r1, r4, r1
18004fa8:	0889      	lsrs	r1, r1, #2
18004faa:	0189      	lsls	r1, r1, #6
18004fac:	f041 0101 	orr.w	r1, r1, #1
18004fb0:	f003 fbfd 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
18004fb4:	4b30      	ldr	r3, [pc, #192]	; (18005078 <usage_fault.constprop.0+0x120>)
18004fb6:	6a9d      	ldr	r5, [r3, #40]	; 0x28
18004fb8:	f415 1580 	ands.w	r5, r5, #1048576	; 0x100000
18004fbc:	d00c      	beq.n	18004fd8 <usage_fault.constprop.0+0x80>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
18004fbe:	6823      	ldr	r3, [r4, #0]
18004fc0:	075d      	lsls	r5, r3, #29
18004fc2:	d008      	beq.n	18004fd6 <usage_fault.constprop.0+0x7e>
18004fc4:	492a      	ldr	r1, [pc, #168]	; (18005070 <usage_fault.constprop.0+0x118>)
18004fc6:	482f      	ldr	r0, [pc, #188]	; (18005084 <usage_fault.constprop.0+0x12c>)
18004fc8:	1a61      	subs	r1, r4, r1
18004fca:	0889      	lsrs	r1, r1, #2
18004fcc:	0189      	lsls	r1, r1, #6
18004fce:	f041 0101 	orr.w	r1, r1, #1
18004fd2:	f003 fbec 	bl	180087ae <log_0>
		reason = K_ERR_STACK_CHK_FAIL;
18004fd6:	2502      	movs	r5, #2
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
18004fd8:	4b27      	ldr	r3, [pc, #156]	; (18005078 <usage_fault.constprop.0+0x120>)
18004fda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18004fdc:	0318      	lsls	r0, r3, #12
18004fde:	d50b      	bpl.n	18004ff8 <usage_fault.constprop.0+0xa0>
		PR_FAULT_INFO("  No coprocessor instructions");
18004fe0:	6823      	ldr	r3, [r4, #0]
18004fe2:	0759      	lsls	r1, r3, #29
18004fe4:	d008      	beq.n	18004ff8 <usage_fault.constprop.0+0xa0>
18004fe6:	4922      	ldr	r1, [pc, #136]	; (18005070 <usage_fault.constprop.0+0x118>)
18004fe8:	4827      	ldr	r0, [pc, #156]	; (18005088 <usage_fault.constprop.0+0x130>)
18004fea:	1a61      	subs	r1, r4, r1
18004fec:	0889      	lsrs	r1, r1, #2
18004fee:	0189      	lsls	r1, r1, #6
18004ff0:	f041 0101 	orr.w	r1, r1, #1
18004ff4:	f003 fbdb 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
18004ff8:	4b1f      	ldr	r3, [pc, #124]	; (18005078 <usage_fault.constprop.0+0x120>)
18004ffa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18004ffc:	035a      	lsls	r2, r3, #13
18004ffe:	d50b      	bpl.n	18005018 <usage_fault.constprop.0+0xc0>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
18005000:	6823      	ldr	r3, [r4, #0]
18005002:	075b      	lsls	r3, r3, #29
18005004:	d008      	beq.n	18005018 <usage_fault.constprop.0+0xc0>
18005006:	491a      	ldr	r1, [pc, #104]	; (18005070 <usage_fault.constprop.0+0x118>)
18005008:	4820      	ldr	r0, [pc, #128]	; (1800508c <usage_fault.constprop.0+0x134>)
1800500a:	1a61      	subs	r1, r4, r1
1800500c:	0889      	lsrs	r1, r1, #2
1800500e:	0189      	lsls	r1, r1, #6
18005010:	f041 0101 	orr.w	r1, r1, #1
18005014:	f003 fbcb 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
18005018:	4b17      	ldr	r3, [pc, #92]	; (18005078 <usage_fault.constprop.0+0x120>)
1800501a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
1800501c:	0398      	lsls	r0, r3, #14
1800501e:	d50b      	bpl.n	18005038 <usage_fault.constprop.0+0xe0>
		PR_FAULT_INFO("  Illegal use of the EPSR");
18005020:	6823      	ldr	r3, [r4, #0]
18005022:	0759      	lsls	r1, r3, #29
18005024:	d008      	beq.n	18005038 <usage_fault.constprop.0+0xe0>
18005026:	4912      	ldr	r1, [pc, #72]	; (18005070 <usage_fault.constprop.0+0x118>)
18005028:	4819      	ldr	r0, [pc, #100]	; (18005090 <usage_fault.constprop.0+0x138>)
1800502a:	1a61      	subs	r1, r4, r1
1800502c:	0889      	lsrs	r1, r1, #2
1800502e:	0189      	lsls	r1, r1, #6
18005030:	f041 0101 	orr.w	r1, r1, #1
18005034:	f003 fbbb 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
18005038:	4b0f      	ldr	r3, [pc, #60]	; (18005078 <usage_fault.constprop.0+0x120>)
1800503a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
1800503c:	03da      	lsls	r2, r3, #15
1800503e:	d50b      	bpl.n	18005058 <usage_fault.constprop.0+0x100>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
18005040:	6823      	ldr	r3, [r4, #0]
18005042:	075b      	lsls	r3, r3, #29
18005044:	d008      	beq.n	18005058 <usage_fault.constprop.0+0x100>
18005046:	490a      	ldr	r1, [pc, #40]	; (18005070 <usage_fault.constprop.0+0x118>)
18005048:	4812      	ldr	r0, [pc, #72]	; (18005094 <usage_fault.constprop.0+0x13c>)
1800504a:	1a61      	subs	r1, r4, r1
1800504c:	0889      	lsrs	r1, r1, #2
1800504e:	0189      	lsls	r1, r1, #6
18005050:	f041 0101 	orr.w	r1, r1, #1
18005054:	f003 fbab 	bl	180087ae <log_0>
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
18005058:	4a07      	ldr	r2, [pc, #28]	; (18005078 <usage_fault.constprop.0+0x120>)
}
1800505a:	4628      	mov	r0, r5
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
1800505c:	6a93      	ldr	r3, [r2, #40]	; 0x28
1800505e:	ea6f 4303 	mvn.w	r3, r3, lsl #16
18005062:	ea6f 4313 	mvn.w	r3, r3, lsr #16
18005066:	6293      	str	r3, [r2, #40]	; 0x28
}
18005068:	bd38      	pop	{r3, r4, r5, pc}
1800506a:	bf00      	nop
1800506c:	3018009c 	.word	0x3018009c
18005070:	3018008c 	.word	0x3018008c
18005074:	1800d8be 	.word	0x1800d8be
18005078:	e000ed00 	.word	0xe000ed00
1800507c:	1800d8d6 	.word	0x1800d8d6
18005080:	1800d8e9 	.word	0x1800d8e9
18005084:	1800d903 	.word	0x1800d903
18005088:	1800d92d 	.word	0x1800d92d
1800508c:	1800d94b 	.word	0x1800d94b
18005090:	1800d970 	.word	0x1800d970
18005094:	1800d98a 	.word	0x1800d98a

18005098 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
18005098:	b570      	push	{r4, r5, r6, lr}
	PR_FAULT_INFO("***** BUS FAULT *****");
1800509a:	4c46      	ldr	r4, [pc, #280]	; (180051b4 <bus_fault.constprop.0+0x11c>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
1800509c:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
1800509e:	6823      	ldr	r3, [r4, #0]
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
180050a0:	4606      	mov	r6, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
180050a2:	0759      	lsls	r1, r3, #29
180050a4:	d008      	beq.n	180050b8 <bus_fault.constprop.0+0x20>
180050a6:	4944      	ldr	r1, [pc, #272]	; (180051b8 <bus_fault.constprop.0+0x120>)
180050a8:	4844      	ldr	r0, [pc, #272]	; (180051bc <bus_fault.constprop.0+0x124>)
180050aa:	1a61      	subs	r1, r4, r1
180050ac:	0889      	lsrs	r1, r1, #2
180050ae:	0189      	lsls	r1, r1, #6
180050b0:	f041 0101 	orr.w	r1, r1, #1
180050b4:	f003 fb7b 	bl	180087ae <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
180050b8:	4b41      	ldr	r3, [pc, #260]	; (180051c0 <bus_fault.constprop.0+0x128>)
180050ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
180050bc:	04da      	lsls	r2, r3, #19
180050be:	d50b      	bpl.n	180050d8 <bus_fault.constprop.0+0x40>
		PR_FAULT_INFO("  Stacking error");
180050c0:	6823      	ldr	r3, [r4, #0]
180050c2:	075b      	lsls	r3, r3, #29
180050c4:	d008      	beq.n	180050d8 <bus_fault.constprop.0+0x40>
180050c6:	493c      	ldr	r1, [pc, #240]	; (180051b8 <bus_fault.constprop.0+0x120>)
180050c8:	483e      	ldr	r0, [pc, #248]	; (180051c4 <bus_fault.constprop.0+0x12c>)
180050ca:	1a61      	subs	r1, r4, r1
180050cc:	0889      	lsrs	r1, r1, #2
180050ce:	0189      	lsls	r1, r1, #6
180050d0:	f041 0101 	orr.w	r1, r1, #1
180050d4:	f003 fb6b 	bl	180087ae <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
180050d8:	4b39      	ldr	r3, [pc, #228]	; (180051c0 <bus_fault.constprop.0+0x128>)
180050da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
180050dc:	0518      	lsls	r0, r3, #20
180050de:	d50b      	bpl.n	180050f8 <bus_fault.constprop.0+0x60>
		PR_FAULT_INFO("  Unstacking error");
180050e0:	6823      	ldr	r3, [r4, #0]
180050e2:	0759      	lsls	r1, r3, #29
180050e4:	d008      	beq.n	180050f8 <bus_fault.constprop.0+0x60>
180050e6:	4934      	ldr	r1, [pc, #208]	; (180051b8 <bus_fault.constprop.0+0x120>)
180050e8:	4837      	ldr	r0, [pc, #220]	; (180051c8 <bus_fault.constprop.0+0x130>)
180050ea:	1a61      	subs	r1, r4, r1
180050ec:	0889      	lsrs	r1, r1, #2
180050ee:	0189      	lsls	r1, r1, #6
180050f0:	f041 0101 	orr.w	r1, r1, #1
180050f4:	f003 fb5b 	bl	180087ae <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
180050f8:	4b31      	ldr	r3, [pc, #196]	; (180051c0 <bus_fault.constprop.0+0x128>)
180050fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
180050fc:	059a      	lsls	r2, r3, #22
180050fe:	d522      	bpl.n	18005146 <bus_fault.constprop.0+0xae>
		PR_FAULT_INFO("  Precise data bus error");
18005100:	6823      	ldr	r3, [r4, #0]
18005102:	075b      	lsls	r3, r3, #29
18005104:	d008      	beq.n	18005118 <bus_fault.constprop.0+0x80>
18005106:	492c      	ldr	r1, [pc, #176]	; (180051b8 <bus_fault.constprop.0+0x120>)
18005108:	4830      	ldr	r0, [pc, #192]	; (180051cc <bus_fault.constprop.0+0x134>)
1800510a:	1a61      	subs	r1, r4, r1
1800510c:	0889      	lsrs	r1, r1, #2
1800510e:	0189      	lsls	r1, r1, #6
18005110:	f041 0101 	orr.w	r1, r1, #1
18005114:	f003 fb4b 	bl	180087ae <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
18005118:	4b29      	ldr	r3, [pc, #164]	; (180051c0 <bus_fault.constprop.0+0x128>)
1800511a:	6b99      	ldr	r1, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
1800511c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
1800511e:	0418      	lsls	r0, r3, #16
18005120:	d511      	bpl.n	18005146 <bus_fault.constprop.0+0xae>
			PR_EXC("  BFAR Address: 0x%x", bfar);
18005122:	6823      	ldr	r3, [r4, #0]
18005124:	075a      	lsls	r2, r3, #29
18005126:	d008      	beq.n	1800513a <bus_fault.constprop.0+0xa2>
18005128:	4a23      	ldr	r2, [pc, #140]	; (180051b8 <bus_fault.constprop.0+0x120>)
1800512a:	4829      	ldr	r0, [pc, #164]	; (180051d0 <bus_fault.constprop.0+0x138>)
1800512c:	1aa2      	subs	r2, r4, r2
1800512e:	0892      	lsrs	r2, r2, #2
18005130:	0192      	lsls	r2, r2, #6
18005132:	f042 0201 	orr.w	r2, r2, #1
18005136:	f003 fb47 	bl	180087c8 <log_1>
			if (from_hard_fault != 0) {
1800513a:	b126      	cbz	r6, 18005146 <bus_fault.constprop.0+0xae>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
1800513c:	4a20      	ldr	r2, [pc, #128]	; (180051c0 <bus_fault.constprop.0+0x128>)
1800513e:	6a93      	ldr	r3, [r2, #40]	; 0x28
18005140:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
18005144:	6293      	str	r3, [r2, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
18005146:	4b1e      	ldr	r3, [pc, #120]	; (180051c0 <bus_fault.constprop.0+0x128>)
18005148:	6a9b      	ldr	r3, [r3, #40]	; 0x28
1800514a:	055b      	lsls	r3, r3, #21
1800514c:	d50b      	bpl.n	18005166 <bus_fault.constprop.0+0xce>
		PR_FAULT_INFO("  Imprecise data bus error");
1800514e:	6823      	ldr	r3, [r4, #0]
18005150:	075e      	lsls	r6, r3, #29
18005152:	d008      	beq.n	18005166 <bus_fault.constprop.0+0xce>
18005154:	4918      	ldr	r1, [pc, #96]	; (180051b8 <bus_fault.constprop.0+0x120>)
18005156:	481f      	ldr	r0, [pc, #124]	; (180051d4 <bus_fault.constprop.0+0x13c>)
18005158:	1a61      	subs	r1, r4, r1
1800515a:	0889      	lsrs	r1, r1, #2
1800515c:	0189      	lsls	r1, r1, #6
1800515e:	f041 0101 	orr.w	r1, r1, #1
18005162:	f003 fb24 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
18005166:	4b16      	ldr	r3, [pc, #88]	; (180051c0 <bus_fault.constprop.0+0x128>)
18005168:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1800516a:	05d0      	lsls	r0, r2, #23
1800516c:	d513      	bpl.n	18005196 <bus_fault.constprop.0+0xfe>
		PR_FAULT_INFO("  Instruction bus error");
1800516e:	6823      	ldr	r3, [r4, #0]
18005170:	0759      	lsls	r1, r3, #29
18005172:	d008      	beq.n	18005186 <bus_fault.constprop.0+0xee>
18005174:	4910      	ldr	r1, [pc, #64]	; (180051b8 <bus_fault.constprop.0+0x120>)
18005176:	4818      	ldr	r0, [pc, #96]	; (180051d8 <bus_fault.constprop.0+0x140>)
18005178:	1a64      	subs	r4, r4, r1
1800517a:	08a4      	lsrs	r4, r4, #2
1800517c:	01a4      	lsls	r4, r4, #6
1800517e:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
18005182:	f003 fb14 	bl	180087ae <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
18005186:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
18005188:	4a0d      	ldr	r2, [pc, #52]	; (180051c0 <bus_fault.constprop.0+0x128>)
1800518a:	6a93      	ldr	r3, [r2, #40]	; 0x28
1800518c:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
18005190:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
18005192:	7028      	strb	r0, [r5, #0]
}
18005194:	bd70      	pop	{r4, r5, r6, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
18005196:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18005198:	049a      	lsls	r2, r3, #18
1800519a:	d5f4      	bpl.n	18005186 <bus_fault.constprop.0+0xee>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
1800519c:	6823      	ldr	r3, [r4, #0]
1800519e:	075b      	lsls	r3, r3, #29
180051a0:	d0f1      	beq.n	18005186 <bus_fault.constprop.0+0xee>
180051a2:	4905      	ldr	r1, [pc, #20]	; (180051b8 <bus_fault.constprop.0+0x120>)
180051a4:	480d      	ldr	r0, [pc, #52]	; (180051dc <bus_fault.constprop.0+0x144>)
180051a6:	1a64      	subs	r4, r4, r1
180051a8:	08a4      	lsrs	r4, r4, #2
180051aa:	01a4      	lsls	r4, r4, #6
180051ac:	f044 0101 	orr.w	r1, r4, #1
180051b0:	e7e7      	b.n	18005182 <bus_fault.constprop.0+0xea>
180051b2:	bf00      	nop
180051b4:	3018009c 	.word	0x3018009c
180051b8:	3018008c 	.word	0x3018008c
180051bc:	1800d9b5 	.word	0x1800d9b5
180051c0:	e000ed00 	.word	0xe000ed00
180051c4:	1800d9cb 	.word	0x1800d9cb
180051c8:	1800d9dc 	.word	0x1800d9dc
180051cc:	1800d9ef 	.word	0x1800d9ef
180051d0:	1800da08 	.word	0x1800da08
180051d4:	1800da1d 	.word	0x1800da1d
180051d8:	1800da38 	.word	0x1800da38
180051dc:	1800da50 	.word	0x1800da50

180051e0 <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
180051e0:	b570      	push	{r4, r5, r6, lr}
	PR_FAULT_INFO("***** MPU FAULT *****");
180051e2:	4c41      	ldr	r4, [pc, #260]	; (180052e8 <mem_manage_fault.constprop.0+0x108>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
180051e4:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
180051e6:	6823      	ldr	r3, [r4, #0]
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
180051e8:	4606      	mov	r6, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
180051ea:	0759      	lsls	r1, r3, #29
180051ec:	d008      	beq.n	18005200 <mem_manage_fault.constprop.0+0x20>
180051ee:	493f      	ldr	r1, [pc, #252]	; (180052ec <mem_manage_fault.constprop.0+0x10c>)
180051f0:	483f      	ldr	r0, [pc, #252]	; (180052f0 <mem_manage_fault.constprop.0+0x110>)
180051f2:	1a61      	subs	r1, r4, r1
180051f4:	0889      	lsrs	r1, r1, #2
180051f6:	0189      	lsls	r1, r1, #6
180051f8:	f041 0101 	orr.w	r1, r1, #1
180051fc:	f003 fad7 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
18005200:	4b3c      	ldr	r3, [pc, #240]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
18005202:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18005204:	06da      	lsls	r2, r3, #27
18005206:	d50b      	bpl.n	18005220 <mem_manage_fault.constprop.0+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
18005208:	6823      	ldr	r3, [r4, #0]
1800520a:	075b      	lsls	r3, r3, #29
1800520c:	d008      	beq.n	18005220 <mem_manage_fault.constprop.0+0x40>
1800520e:	4937      	ldr	r1, [pc, #220]	; (180052ec <mem_manage_fault.constprop.0+0x10c>)
18005210:	4839      	ldr	r0, [pc, #228]	; (180052f8 <mem_manage_fault.constprop.0+0x118>)
18005212:	1a61      	subs	r1, r4, r1
18005214:	0889      	lsrs	r1, r1, #2
18005216:	0189      	lsls	r1, r1, #6
18005218:	f041 0101 	orr.w	r1, r1, #1
1800521c:	f003 fac7 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
18005220:	4b34      	ldr	r3, [pc, #208]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
18005222:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18005224:	0718      	lsls	r0, r3, #28
18005226:	d50b      	bpl.n	18005240 <mem_manage_fault.constprop.0+0x60>
		PR_FAULT_INFO("  Unstacking error");
18005228:	6823      	ldr	r3, [r4, #0]
1800522a:	0759      	lsls	r1, r3, #29
1800522c:	d008      	beq.n	18005240 <mem_manage_fault.constprop.0+0x60>
1800522e:	492f      	ldr	r1, [pc, #188]	; (180052ec <mem_manage_fault.constprop.0+0x10c>)
18005230:	4832      	ldr	r0, [pc, #200]	; (180052fc <mem_manage_fault.constprop.0+0x11c>)
18005232:	1a61      	subs	r1, r4, r1
18005234:	0889      	lsrs	r1, r1, #2
18005236:	0189      	lsls	r1, r1, #6
18005238:	f041 0101 	orr.w	r1, r1, #1
1800523c:	f003 fab7 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
18005240:	4b2c      	ldr	r3, [pc, #176]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
18005242:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18005244:	079a      	lsls	r2, r3, #30
18005246:	d522      	bpl.n	1800528e <mem_manage_fault.constprop.0+0xae>
		PR_FAULT_INFO("  Data Access Violation");
18005248:	6823      	ldr	r3, [r4, #0]
1800524a:	075b      	lsls	r3, r3, #29
1800524c:	d008      	beq.n	18005260 <mem_manage_fault.constprop.0+0x80>
1800524e:	4927      	ldr	r1, [pc, #156]	; (180052ec <mem_manage_fault.constprop.0+0x10c>)
18005250:	482b      	ldr	r0, [pc, #172]	; (18005300 <mem_manage_fault.constprop.0+0x120>)
18005252:	1a61      	subs	r1, r4, r1
18005254:	0889      	lsrs	r1, r1, #2
18005256:	0189      	lsls	r1, r1, #6
18005258:	f041 0101 	orr.w	r1, r1, #1
1800525c:	f003 faa7 	bl	180087ae <log_0>
		uint32_t temp = SCB->MMFAR;
18005260:	4b24      	ldr	r3, [pc, #144]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
18005262:	6b59      	ldr	r1, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
18005264:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18005266:	0618      	lsls	r0, r3, #24
18005268:	d511      	bpl.n	1800528e <mem_manage_fault.constprop.0+0xae>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
1800526a:	6823      	ldr	r3, [r4, #0]
1800526c:	075a      	lsls	r2, r3, #29
1800526e:	d008      	beq.n	18005282 <mem_manage_fault.constprop.0+0xa2>
18005270:	4a1e      	ldr	r2, [pc, #120]	; (180052ec <mem_manage_fault.constprop.0+0x10c>)
18005272:	4824      	ldr	r0, [pc, #144]	; (18005304 <mem_manage_fault.constprop.0+0x124>)
18005274:	1aa2      	subs	r2, r4, r2
18005276:	0892      	lsrs	r2, r2, #2
18005278:	0192      	lsls	r2, r2, #6
1800527a:	f042 0201 	orr.w	r2, r2, #1
1800527e:	f003 faa3 	bl	180087c8 <log_1>
			if (from_hard_fault != 0) {
18005282:	b126      	cbz	r6, 1800528e <mem_manage_fault.constprop.0+0xae>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
18005284:	4a1b      	ldr	r2, [pc, #108]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
18005286:	6a93      	ldr	r3, [r2, #40]	; 0x28
18005288:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1800528c:	6293      	str	r3, [r2, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
1800528e:	4b19      	ldr	r3, [pc, #100]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
18005290:	6a9b      	ldr	r3, [r3, #40]	; 0x28
18005292:	07db      	lsls	r3, r3, #31
18005294:	d50b      	bpl.n	180052ae <mem_manage_fault.constprop.0+0xce>
		PR_FAULT_INFO("  Instruction Access Violation");
18005296:	6823      	ldr	r3, [r4, #0]
18005298:	075e      	lsls	r6, r3, #29
1800529a:	d008      	beq.n	180052ae <mem_manage_fault.constprop.0+0xce>
1800529c:	4b13      	ldr	r3, [pc, #76]	; (180052ec <mem_manage_fault.constprop.0+0x10c>)
1800529e:	481a      	ldr	r0, [pc, #104]	; (18005308 <mem_manage_fault.constprop.0+0x128>)
180052a0:	1ae3      	subs	r3, r4, r3
180052a2:	089b      	lsrs	r3, r3, #2
180052a4:	019b      	lsls	r3, r3, #6
180052a6:	f043 0101 	orr.w	r1, r3, #1
180052aa:	f003 fa80 	bl	180087ae <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
180052ae:	4b11      	ldr	r3, [pc, #68]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
180052b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
180052b2:	0698      	lsls	r0, r3, #26
180052b4:	d50b      	bpl.n	180052ce <mem_manage_fault.constprop.0+0xee>
		PR_FAULT_INFO(
180052b6:	6823      	ldr	r3, [r4, #0]
180052b8:	0759      	lsls	r1, r3, #29
180052ba:	d008      	beq.n	180052ce <mem_manage_fault.constprop.0+0xee>
180052bc:	490b      	ldr	r1, [pc, #44]	; (180052ec <mem_manage_fault.constprop.0+0x10c>)
180052be:	4813      	ldr	r0, [pc, #76]	; (1800530c <mem_manage_fault.constprop.0+0x12c>)
180052c0:	1a64      	subs	r4, r4, r1
180052c2:	08a4      	lsrs	r4, r4, #2
180052c4:	01a4      	lsls	r4, r4, #6
180052c6:	f044 0101 	orr.w	r1, r4, #1
180052ca:	f003 fa70 	bl	180087ae <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
180052ce:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
180052d0:	4b08      	ldr	r3, [pc, #32]	; (180052f4 <mem_manage_fault.constprop.0+0x114>)
180052d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
180052d4:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
180052d6:	bf58      	it	pl
180052d8:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
180052da:	6a9a      	ldr	r2, [r3, #40]	; 0x28
180052dc:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
180052e0:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
180052e2:	7028      	strb	r0, [r5, #0]
}
180052e4:	bd70      	pop	{r4, r5, r6, pc}
180052e6:	bf00      	nop
180052e8:	3018009c 	.word	0x3018009c
180052ec:	3018008c 	.word	0x3018008c
180052f0:	1800da7f 	.word	0x1800da7f
180052f4:	e000ed00 	.word	0xe000ed00
180052f8:	1800da95 	.word	0x1800da95
180052fc:	1800d9dc 	.word	0x1800d9dc
18005300:	1800dac8 	.word	0x1800dac8
18005304:	1800dae0 	.word	0x1800dae0
18005308:	1800daf6 	.word	0x1800daf6
1800530c:	1800da50 	.word	0x1800da50

18005310 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
18005310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
18005314:	4b8d      	ldr	r3, [pc, #564]	; (1800554c <z_arm_fault+0x23c>)
{
18005316:	460d      	mov	r5, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
18005318:	685e      	ldr	r6, [r3, #4]
1800531a:	2700      	movs	r7, #0
{
1800531c:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
1800531e:	f3c6 0408 	ubfx	r4, r6, #0, #9
18005322:	f387 8811 	msr	BASEPRI, r7
18005326:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
1800532a:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
1800532e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
18005332:	d138      	bne.n	180053a6 <z_arm_fault+0x96>
	if ((exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) == 0U) {
18005334:	f012 0301 	ands.w	r3, r2, #1
18005338:	d034      	beq.n	180053a4 <z_arm_fault+0x94>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
1800533a:	f012 0340 	ands.w	r3, r2, #64	; 0x40
		if (exc_return & EXC_RETURN_MODE_THREAD) {
1800533e:	f002 0808 	and.w	r8, r2, #8
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
18005342:	f040 80fc 	bne.w	1800553e <z_arm_fault+0x22e>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
18005346:	0757      	lsls	r7, r2, #29
			secure_esf = (z_arch_esf_t *)msp;
18005348:	bf54      	ite	pl
1800534a:	4605      	movpl	r5, r0
	*nested_exc = false;
1800534c:	461f      	movmi	r7, r3
	if ((*top_of_sec_stack == INTEGRITY_SIGNATURE_STD) ||
1800534e:	6829      	ldr	r1, [r5, #0]
18005350:	4b7f      	ldr	r3, [pc, #508]	; (18005550 <z_arm_fault+0x240>)
	PR_FAULT_INFO("  S instruction address:  0x%x", sec_ret_addr);
18005352:	4a80      	ldr	r2, [pc, #512]	; (18005554 <z_arm_fault+0x244>)
	if ((*top_of_sec_stack == INTEGRITY_SIGNATURE_STD) ||
18005354:	440b      	add	r3, r1
			*nested_exc = true;
18005356:	bf58      	it	pl
18005358:	2701      	movpl	r7, #1
	if ((*top_of_sec_stack == INTEGRITY_SIGNATURE_STD) ||
1800535a:	2b01      	cmp	r3, #1
	PR_FAULT_INFO("  S instruction address:  0x%x", sec_ret_addr);
1800535c:	6813      	ldr	r3, [r2, #0]
		sec_ret_addr = secure_esf->basic.pc;
1800535e:	bf98      	it	ls
18005360:	6c29      	ldrls	r1, [r5, #64]	; 0x40
	PR_FAULT_INFO("  S instruction address:  0x%x", sec_ret_addr);
18005362:	075d      	lsls	r5, r3, #29
18005364:	d008      	beq.n	18005378 <z_arm_fault+0x68>
18005366:	4b7c      	ldr	r3, [pc, #496]	; (18005558 <z_arm_fault+0x248>)
18005368:	487c      	ldr	r0, [pc, #496]	; (1800555c <z_arm_fault+0x24c>)
1800536a:	1ad2      	subs	r2, r2, r3
1800536c:	0892      	lsrs	r2, r2, #2
1800536e:	0192      	lsls	r2, r2, #6
18005370:	f042 0201 	orr.w	r2, r2, #1
18005374:	f003 fa28 	bl	180087c8 <log_1>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
18005378:	f1b8 0f00 	cmp.w	r8, #0
1800537c:	d00f      	beq.n	1800539e <z_arm_fault+0x8e>
  __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
1800537e:	f3ef 8589 	mrs	r5, PSP_NS
	*recoverable = false;
18005382:	2300      	movs	r3, #0
18005384:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
18005388:	1ee3      	subs	r3, r4, #3
1800538a:	2b09      	cmp	r3, #9
1800538c:	f200 80ba 	bhi.w	18005504 <z_arm_fault+0x1f4>
18005390:	e8df f003 	tbb	[pc, r3]
18005394:	96a4a00b 	.word	0x96a4a00b
18005398:	b8b8b8a8 	.word	0xb8b8b8a8
1800539c:	abb8      	.short	0xabb8
  __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
1800539e:	f3ef 8588 	mrs	r5, MSP_NS
  return(result);
180053a2:	e7ee      	b.n	18005382 <z_arm_fault+0x72>
	*nested_exc = false;
180053a4:	461f      	mov	r7, r3
		return NULL;
180053a6:	463d      	mov	r5, r7
180053a8:	e7eb      	b.n	18005382 <z_arm_fault+0x72>
	PR_FAULT_INFO("***** HARD FAULT *****");
180053aa:	4e6a      	ldr	r6, [pc, #424]	; (18005554 <z_arm_fault+0x244>)
180053ac:	6833      	ldr	r3, [r6, #0]
180053ae:	075c      	lsls	r4, r3, #29
180053b0:	d008      	beq.n	180053c4 <z_arm_fault+0xb4>
180053b2:	4969      	ldr	r1, [pc, #420]	; (18005558 <z_arm_fault+0x248>)
180053b4:	486a      	ldr	r0, [pc, #424]	; (18005560 <z_arm_fault+0x250>)
180053b6:	1a71      	subs	r1, r6, r1
180053b8:	0889      	lsrs	r1, r1, #2
180053ba:	0189      	lsls	r1, r1, #6
180053bc:	f041 0101 	orr.w	r1, r1, #1
180053c0:	f003 f9f5 	bl	180087ae <log_0>
	*recoverable = false;
180053c4:	f04f 0800 	mov.w	r8, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
180053c8:	4b60      	ldr	r3, [pc, #384]	; (1800554c <z_arm_fault+0x23c>)
	*recoverable = false;
180053ca:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
180053ce:	6adc      	ldr	r4, [r3, #44]	; 0x2c
180053d0:	f014 0402 	ands.w	r4, r4, #2
180053d4:	d00e      	beq.n	180053f4 <z_arm_fault+0xe4>
		PR_EXC("  Bus fault on vector table read");
180053d6:	6833      	ldr	r3, [r6, #0]
180053d8:	0758      	lsls	r0, r3, #29
180053da:	d101      	bne.n	180053e0 <z_arm_fault+0xd0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
180053dc:	2400      	movs	r4, #0
180053de:	e018      	b.n	18005412 <z_arm_fault+0x102>
180053e0:	495d      	ldr	r1, [pc, #372]	; (18005558 <z_arm_fault+0x248>)
		PR_EXC("  Bus fault on vector table read");
180053e2:	4860      	ldr	r0, [pc, #384]	; (18005564 <z_arm_fault+0x254>)
180053e4:	1a71      	subs	r1, r6, r1
180053e6:	0889      	lsrs	r1, r1, #2
180053e8:	0189      	lsls	r1, r1, #6
180053ea:	f041 0101 	orr.w	r1, r1, #1
	PR_FAULT_INFO(
180053ee:	f003 f9de 	bl	180087ae <log_0>
180053f2:	e7f3      	b.n	180053dc <z_arm_fault+0xcc>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
180053f4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
180053f6:	2a00      	cmp	r2, #0
180053f8:	da26      	bge.n	18005448 <z_arm_fault+0x138>
		PR_EXC("  Debug event");
180053fa:	6833      	ldr	r3, [r6, #0]
180053fc:	0759      	lsls	r1, r3, #29
180053fe:	d0ed      	beq.n	180053dc <z_arm_fault+0xcc>
18005400:	4955      	ldr	r1, [pc, #340]	; (18005558 <z_arm_fault+0x248>)
18005402:	4859      	ldr	r0, [pc, #356]	; (18005568 <z_arm_fault+0x258>)
18005404:	1a71      	subs	r1, r6, r1
18005406:	0889      	lsrs	r1, r1, #2
18005408:	0189      	lsls	r1, r1, #6
1800540a:	f041 0101 	orr.w	r1, r1, #1
1800540e:	f003 f9ce 	bl	180087ae <log_0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
18005412:	f89d 3007 	ldrb.w	r3, [sp, #7]
18005416:	b9a3      	cbnz	r3, 18005442 <z_arm_fault+0x132>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
18005418:	2220      	movs	r2, #32
1800541a:	4629      	mov	r1, r5
1800541c:	a802      	add	r0, sp, #8
1800541e:	f004 fe98 	bl	1800a152 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
18005422:	9b09      	ldr	r3, [sp, #36]	; 0x24
18005424:	2f00      	cmp	r7, #0
18005426:	f000 8085 	beq.w	18005534 <z_arm_fault+0x224>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
1800542a:	f3c3 0208 	ubfx	r2, r3, #0, #9
1800542e:	b922      	cbnz	r2, 1800543a <z_arm_fault+0x12a>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
18005430:	ea6f 2353 	mvn.w	r3, r3, lsr #9
18005434:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
18005438:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
1800543a:	4620      	mov	r0, r4
1800543c:	a902      	add	r1, sp, #8
1800543e:	f7ff fb9f 	bl	18004b80 <z_arm_fatal_error>
}
18005442:	b00a      	add	sp, #40	; 0x28
18005444:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
18005448:	6adb      	ldr	r3, [r3, #44]	; 0x2c
1800544a:	005a      	lsls	r2, r3, #1
1800544c:	d5c6      	bpl.n	180053dc <z_arm_fault+0xcc>
		PR_EXC("  Fault escalation (see below)");
1800544e:	6833      	ldr	r3, [r6, #0]
18005450:	075b      	lsls	r3, r3, #29
18005452:	d008      	beq.n	18005466 <z_arm_fault+0x156>
18005454:	4940      	ldr	r1, [pc, #256]	; (18005558 <z_arm_fault+0x248>)
18005456:	4845      	ldr	r0, [pc, #276]	; (1800556c <z_arm_fault+0x25c>)
18005458:	1a71      	subs	r1, r6, r1
1800545a:	0889      	lsrs	r1, r1, #2
1800545c:	0189      	lsls	r1, r1, #6
1800545e:	f041 0101 	orr.w	r1, r1, #1
18005462:	f003 f9a4 	bl	180087ae <log_0>
	uint16_t fault_insn = *(ret_addr - 1);
18005466:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
18005468:	f833 2c02 	ldrh.w	r2, [r3, #-2]
1800546c:	f64d 7302 	movw	r3, #57090	; 0xdf02
18005470:	429a      	cmp	r2, r3
18005472:	d00a      	beq.n	1800548a <z_arm_fault+0x17a>
		} else if (SCB_MMFSR != 0) {
18005474:	4b35      	ldr	r3, [pc, #212]	; (1800554c <z_arm_fault+0x23c>)
18005476:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
1800547a:	b1aa      	cbz	r2, 180054a8 <z_arm_fault+0x198>
			reason = mem_manage_fault(esf, 1, recoverable);
1800547c:	2001      	movs	r0, #1
1800547e:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
18005482:	f7ff fead 	bl	180051e0 <mem_manage_fault.constprop.0>
18005486:	4604      	mov	r4, r0
		break;
18005488:	e7c3      	b.n	18005412 <z_arm_fault+0x102>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
1800548a:	6833      	ldr	r3, [r6, #0]
1800548c:	075c      	lsls	r4, r3, #29
1800548e:	d009      	beq.n	180054a4 <z_arm_fault+0x194>
18005490:	4a31      	ldr	r2, [pc, #196]	; (18005558 <z_arm_fault+0x248>)
18005492:	6829      	ldr	r1, [r5, #0]
18005494:	1ab2      	subs	r2, r6, r2
18005496:	0892      	lsrs	r2, r2, #2
18005498:	0192      	lsls	r2, r2, #6
1800549a:	4835      	ldr	r0, [pc, #212]	; (18005570 <z_arm_fault+0x260>)
1800549c:	f042 0201 	orr.w	r2, r2, #1
180054a0:	f003 f992 	bl	180087c8 <log_1>
			reason = esf->basic.r0;
180054a4:	682c      	ldr	r4, [r5, #0]
180054a6:	e7b4      	b.n	18005412 <z_arm_fault+0x102>
		} else if (SCB_BFSR != 0) {
180054a8:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
180054ac:	b12a      	cbz	r2, 180054ba <z_arm_fault+0x1aa>
			reason = bus_fault(esf, 1, recoverable);
180054ae:	2001      	movs	r0, #1
180054b0:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
180054b4:	f7ff fdf0 	bl	18005098 <bus_fault.constprop.0>
180054b8:	e7e5      	b.n	18005486 <z_arm_fault+0x176>
		} else if (SCB_UFSR != 0) {
180054ba:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
180054bc:	b292      	uxth	r2, r2
180054be:	b112      	cbz	r2, 180054c6 <z_arm_fault+0x1b6>
		reason = usage_fault(esf);
180054c0:	f7ff fd4a 	bl	18004f58 <usage_fault.constprop.0>
180054c4:	e7df      	b.n	18005486 <z_arm_fault+0x176>
		} else if (SAU->SFSR != 0) {
180054c6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
180054ca:	2b00      	cmp	r3, #0
180054cc:	d086      	beq.n	180053dc <z_arm_fault+0xcc>
			secure_fault(esf);
180054ce:	f7ff fc97 	bl	18004e00 <secure_fault.constprop.0>
180054d2:	e79e      	b.n	18005412 <z_arm_fault+0x102>
		reason = mem_manage_fault(esf, 0, recoverable);
180054d4:	2000      	movs	r0, #0
180054d6:	f10d 0107 	add.w	r1, sp, #7
180054da:	e7d2      	b.n	18005482 <z_arm_fault+0x172>
		reason = bus_fault(esf, 0, recoverable);
180054dc:	2000      	movs	r0, #0
180054de:	f10d 0107 	add.w	r1, sp, #7
180054e2:	e7e7      	b.n	180054b4 <z_arm_fault+0x1a4>
		secure_fault(esf);
180054e4:	f7ff fc8c 	bl	18004e00 <secure_fault.constprop.0>
		break;
180054e8:	e778      	b.n	180053dc <z_arm_fault+0xcc>
	PR_FAULT_INFO(
180054ea:	491a      	ldr	r1, [pc, #104]	; (18005554 <z_arm_fault+0x244>)
180054ec:	680b      	ldr	r3, [r1, #0]
180054ee:	0758      	lsls	r0, r3, #29
180054f0:	f43f af74 	beq.w	180053dc <z_arm_fault+0xcc>
180054f4:	4b18      	ldr	r3, [pc, #96]	; (18005558 <z_arm_fault+0x248>)
180054f6:	481f      	ldr	r0, [pc, #124]	; (18005574 <z_arm_fault+0x264>)
180054f8:	1ac9      	subs	r1, r1, r3
180054fa:	0889      	lsrs	r1, r1, #2
180054fc:	0189      	lsls	r1, r1, #6
180054fe:	f041 0101 	orr.w	r1, r1, #1
18005502:	e774      	b.n	180053ee <z_arm_fault+0xde>
	PR_FAULT_INFO("***** %s %d) *****",
18005504:	4b13      	ldr	r3, [pc, #76]	; (18005554 <z_arm_fault+0x244>)
18005506:	681a      	ldr	r2, [r3, #0]
18005508:	0752      	lsls	r2, r2, #29
1800550a:	f43f af67 	beq.w	180053dc <z_arm_fault+0xcc>
1800550e:	4a12      	ldr	r2, [pc, #72]	; (18005558 <z_arm_fault+0x248>)
18005510:	4819      	ldr	r0, [pc, #100]	; (18005578 <z_arm_fault+0x268>)
18005512:	1a9b      	subs	r3, r3, r2
18005514:	089b      	lsrs	r3, r3, #2
18005516:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
1800551a:	ea4f 1383 	mov.w	r3, r3, lsl #6
1800551e:	4917      	ldr	r1, [pc, #92]	; (1800557c <z_arm_fault+0x26c>)
18005520:	f043 0301 	orr.w	r3, r3, #1
18005524:	bf18      	it	ne
18005526:	4601      	movne	r1, r0
18005528:	f1a4 0210 	sub.w	r2, r4, #16
1800552c:	4814      	ldr	r0, [pc, #80]	; (18005580 <z_arm_fault+0x270>)
1800552e:	f003 f95f 	bl	180087f0 <log_2>
18005532:	e753      	b.n	180053dc <z_arm_fault+0xcc>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
18005534:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
18005538:	f023 0301 	bic.w	r3, r3, #1
1800553c:	e77c      	b.n	18005438 <z_arm_fault+0x128>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
1800553e:	f1b8 0f00 	cmp.w	r8, #0
18005542:	f47f af1e 	bne.w	18005382 <z_arm_fault+0x72>
			ptr_esf = (z_arch_esf_t *)msp;
18005546:	4605      	mov	r5, r0
			*nested_exc = true;
18005548:	2701      	movs	r7, #1
1800554a:	e71a      	b.n	18005382 <z_arm_fault+0x72>
1800554c:	e000ed00 	.word	0xe000ed00
18005550:	0105eda6 	.word	0x0105eda6
18005554:	3018009c 	.word	0x3018009c
18005558:	3018008c 	.word	0x3018008c
1800555c:	1800db15 	.word	0x1800db15
18005560:	1800db34 	.word	0x1800db34
18005564:	1800db4b 	.word	0x1800db4b
18005568:	1800db6c 	.word	0x1800db6c
1800556c:	1800db7a 	.word	0x1800db7a
18005570:	1800db99 	.word	0x1800db99
18005574:	1800dbb5 	.word	0x1800dbb5
18005578:	1800dbee 	.word	0x1800dbee
1800557c:	1800dbd9 	.word	0x1800dbd9
18005580:	1800dc07 	.word	0x1800dc07

18005584 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
18005584:	4b04      	ldr	r3, [pc, #16]	; (18005598 <z_arm_fault_init+0x14>)
18005586:	695a      	ldr	r2, [r3, #20]
18005588:	f042 0210 	orr.w	r2, r2, #16
1800558c:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
1800558e:	695a      	ldr	r2, [r3, #20]
18005590:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
18005594:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
18005596:	4770      	bx	lr
18005598:	e000ed00 	.word	0xe000ed00

1800559c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
1800559c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
180055a0:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
180055a4:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
180055a6:	4672      	mov	r2, lr
	bl z_arm_fault
180055a8:	f7ff feb2 	bl	18005310 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
180055ac:	bd01      	pop	{r0, pc}
180055ae:	bf00      	nop

180055b0 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
180055b0:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
180055b2:	2120      	movs	r1, #32
180055b4:	4803      	ldr	r0, [pc, #12]	; (180055c4 <z_arm_interrupt_init+0x14>)
180055b6:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
180055b8:	3301      	adds	r3, #1
180055ba:	2b3c      	cmp	r3, #60	; 0x3c
180055bc:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
180055c0:	d1f9      	bne.n	180055b6 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
180055c2:	4770      	bx	lr
180055c4:	e000e100 	.word	0xe000e100

180055c8 <__start>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
180055c8:	2020      	movs	r0, #32
    msr BASEPRI, r0
180055ca:	f380 8811 	msr	BASEPRI, r0
 * (may be larger due to rounding up for stack pointer aligning
 * purposes but this is sufficient during initialization).
 */

#ifdef CONFIG_INIT_STACKS
    ldr r0, =z_interrupt_stacks
180055ce:	480b      	ldr	r0, [pc, #44]	; (180055fc <__start+0x34>)
    ldr r1, =0xaa
180055d0:	f04f 01aa 	mov.w	r1, #170	; 0xaa
    ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
180055d4:	f44f 6200 	mov.w	r2, #2048	; 0x800
    bl memset
180055d8:	f004 fdc6 	bl	1800a168 <memset>

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
180055dc:	4807      	ldr	r0, [pc, #28]	; (180055fc <__start+0x34>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
180055de:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
180055e2:	1840      	adds	r0, r0, r1
    msr PSP, r0
180055e4:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
180055e8:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
180055ec:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
180055ee:	4308      	orrs	r0, r1
    msr CONTROL, r0
180055f0:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
180055f4:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
180055f8:	f7ff fb30 	bl	18004c5c <z_arm_prep_c>
    ldr r0, =z_interrupt_stacks
180055fc:	30182298 	.word	0x30182298

18005600 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
18005600:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
18005604:	4905      	ldr	r1, [pc, #20]	; (1800561c <sys_arch_reboot+0x1c>)
18005606:	4b06      	ldr	r3, [pc, #24]	; (18005620 <sys_arch_reboot+0x20>)
18005608:	68ca      	ldr	r2, [r1, #12]
1800560a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
1800560e:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
18005610:	60cb      	str	r3, [r1, #12]
18005612:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
18005616:	bf00      	nop
  for(;;)                                                           /* wait until reset */
18005618:	e7fd      	b.n	18005616 <sys_arch_reboot+0x16>
1800561a:	bf00      	nop
1800561c:	e000ed00 	.word	0xe000ed00
18005620:	05fa0004 	.word	0x05fa0004

18005624 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
18005624:	4b06      	ldr	r3, [pc, #24]	; (18005640 <z_impl_k_thread_abort+0x1c>)
18005626:	689b      	ldr	r3, [r3, #8]
18005628:	4283      	cmp	r3, r0
1800562a:	d107      	bne.n	1800563c <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1800562c:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
18005630:	b123      	cbz	r3, 1800563c <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
18005632:	4a04      	ldr	r2, [pc, #16]	; (18005644 <z_impl_k_thread_abort+0x20>)
18005634:	6853      	ldr	r3, [r2, #4]
18005636:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
1800563a:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
1800563c:	f002 b8c2 	b.w	180077c4 <z_thread_abort>
18005640:	30180a20 	.word	0x30180a20
18005644:	e000ed00 	.word	0xe000ed00

18005648 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
18005648:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
1800564a:	4c09      	ldr	r4, [pc, #36]	; (18005670 <z_arm_configure_static_mpu_regions+0x28>)
1800564c:	4a09      	ldr	r2, [pc, #36]	; (18005674 <z_arm_configure_static_mpu_regions+0x2c>)
1800564e:	4623      	mov	r3, r4
18005650:	2101      	movs	r1, #1
18005652:	4809      	ldr	r0, [pc, #36]	; (18005678 <z_arm_configure_static_mpu_regions+0x30>)
18005654:	f000 f932 	bl	180058bc <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
18005658:	2300      	movs	r3, #0
1800565a:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
1800565c:	4b07      	ldr	r3, [pc, #28]	; (1800567c <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
1800565e:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
18005660:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
18005662:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
18005664:	9301      	str	r3, [sp, #4]
18005666:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
18005668:	f000 f932 	bl	180058d0 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
1800566c:	b004      	add	sp, #16
1800566e:	bd10      	pop	{r4, pc}
18005670:	30480000 	.word	0x30480000
18005674:	30180000 	.word	0x30180000
18005678:	1800ba9c 	.word	0x1800ba9c
1800567c:	301800f0 	.word	0x301800f0

18005680 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
18005680:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
18005682:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
18005684:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
18005686:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
1800568a:	f004 031f 	and.w	r3, r4, #31
1800568e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
18005690:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
18005692:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
18005694:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
18005698:	4905      	ldr	r1, [pc, #20]	; (180056b0 <region_init+0x30>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
1800569a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
1800569e:	f043 0301 	orr.w	r3, r3, #1
180056a2:	f8c1 0098 	str.w	r0, [r1, #152]	; 0x98
  mpu->RBAR = rbar;
180056a6:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  mpu->RLAR = rlar;
180056aa:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
180056ae:	bd10      	pop	{r4, pc}
180056b0:	e000ed00 	.word	0xe000ed00

180056b4 <region_allocate_and_init>:

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
180056b4:	2807      	cmp	r0, #7
{
180056b6:	b510      	push	{r4, lr}
	if (index > (get_num_regions() - 1U)) {
180056b8:	d910      	bls.n	180056dc <region_allocate_and_init+0x28>

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
180056ba:	4a0a      	ldr	r2, [pc, #40]	; (180056e4 <region_allocate_and_init+0x30>)
180056bc:	6813      	ldr	r3, [r2, #0]
180056be:	075b      	lsls	r3, r3, #29
180056c0:	d009      	beq.n	180056d6 <region_allocate_and_init+0x22>
180056c2:	4b09      	ldr	r3, [pc, #36]	; (180056e8 <region_allocate_and_init+0x34>)
180056c4:	4601      	mov	r1, r0
180056c6:	1ad2      	subs	r2, r2, r3
180056c8:	0892      	lsrs	r2, r2, #2
180056ca:	0192      	lsls	r2, r2, #6
180056cc:	4807      	ldr	r0, [pc, #28]	; (180056ec <region_allocate_and_init+0x38>)
180056ce:	f042 0201 	orr.w	r2, r2, #1
180056d2:	f003 f879 	bl	180087c8 <log_1>
		return -EINVAL;
180056d6:	f06f 0015 	mvn.w	r0, #21
180056da:	e001      	b.n	180056e0 <region_allocate_and_init+0x2c>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
180056dc:	f7ff ffd0 	bl	18005680 <region_init>

	return index;
}
180056e0:	bd10      	pop	{r4, pc}
180056e2:	bf00      	nop
180056e4:	30180098 	.word	0x30180098
180056e8:	3018008c 	.word	0x3018008c
180056ec:	1800dc1e 	.word	0x1800dc1e

180056f0 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
180056f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
180056f4:	4689      	mov	r9, r1
180056f6:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
180056f8:	4606      	mov	r6, r0
180056fa:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = index;
180056fe:	4d5f      	ldr	r5, [pc, #380]	; (1800587c <mpu_configure_regions_and_partition.constprop.0+0x18c>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
18005700:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
18005702:	45c8      	cmp	r8, r9
18005704:	da2f      	bge.n	18005766 <mpu_configure_regions_and_partition.constprop.0+0x76>
		if (regions[i].size == 0U) {
18005706:	f8d6 a004 	ldr.w	sl, [r6, #4]
1800570a:	f1ba 0f00 	cmp.w	sl, #0
1800570e:	d058      	beq.n	180057c2 <mpu_configure_regions_and_partition.constprop.0+0xd2>
		&&
18005710:	f1ba 0f1f 	cmp.w	sl, #31
18005714:	d921      	bls.n	1800575a <mpu_configure_regions_and_partition.constprop.0+0x6a>
		&&
18005716:	f01a 0f1f 	tst.w	sl, #31
1800571a:	d11e      	bne.n	1800575a <mpu_configure_regions_and_partition.constprop.0+0x6a>
		((part->start &
1800571c:	f8d6 b000 	ldr.w	fp, [r6]
		&&
18005720:	f01b 0f1f 	tst.w	fp, #31
18005724:	d119      	bne.n	1800575a <mpu_configure_regions_and_partition.constprop.0+0x6a>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
18005726:	4658      	mov	r0, fp
18005728:	f004 fb64 	bl	18009df4 <arm_cmse_mpu_region_get>
1800572c:	4607      	mov	r7, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
1800572e:	eb0a 000b 	add.w	r0, sl, fp
18005732:	3801      	subs	r0, #1
18005734:	f004 fb5e 	bl	18009df4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
18005738:	4287      	cmp	r7, r0
1800573a:	d023      	beq.n	18005784 <mpu_configure_regions_and_partition.constprop.0+0x94>
	return -EINVAL;
1800573c:	f06f 0715 	mvn.w	r7, #21
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
18005740:	4a4f      	ldr	r2, [pc, #316]	; (18005880 <mpu_configure_regions_and_partition.constprop.0+0x190>)
18005742:	6813      	ldr	r3, [r2, #0]
18005744:	075b      	lsls	r3, r3, #29
18005746:	d00c      	beq.n	18005762 <mpu_configure_regions_and_partition.constprop.0+0x72>
18005748:	4b4e      	ldr	r3, [pc, #312]	; (18005884 <mpu_configure_regions_and_partition.constprop.0+0x194>)
1800574a:	4639      	mov	r1, r7
1800574c:	1ad2      	subs	r2, r2, r3
1800574e:	0892      	lsrs	r2, r2, #2
18005750:	0192      	lsls	r2, r2, #6
18005752:	484d      	ldr	r0, [pc, #308]	; (18005888 <mpu_configure_regions_and_partition.constprop.0+0x198>)
18005754:	f042 0201 	orr.w	r2, r2, #1
18005758:	e011      	b.n	1800577e <mpu_configure_regions_and_partition.constprop.0+0x8e>
			LOG_ERR("Partition %u: sanity check failed.", i);
1800575a:	4a49      	ldr	r2, [pc, #292]	; (18005880 <mpu_configure_regions_and_partition.constprop.0+0x190>)
1800575c:	6813      	ldr	r3, [r2, #0]
1800575e:	0759      	lsls	r1, r3, #29
18005760:	d105      	bne.n	1800576e <mpu_configure_regions_and_partition.constprop.0+0x7e>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
18005762:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
18005766:	4620      	mov	r0, r4
18005768:	b005      	add	sp, #20
1800576a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			LOG_ERR("Partition %u: sanity check failed.", i);
1800576e:	4641      	mov	r1, r8
18005770:	4b44      	ldr	r3, [pc, #272]	; (18005884 <mpu_configure_regions_and_partition.constprop.0+0x194>)
18005772:	4846      	ldr	r0, [pc, #280]	; (1800588c <mpu_configure_regions_and_partition.constprop.0+0x19c>)
18005774:	1ad2      	subs	r2, r2, r3
18005776:	0892      	lsrs	r2, r2, #2
18005778:	0192      	lsls	r2, r2, #6
1800577a:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
1800577e:	f003 f823 	bl	180087c8 <log_1>
18005782:	e7ee      	b.n	18005762 <mpu_configure_regions_and_partition.constprop.0+0x72>
		if ((u_reg_index == -EINVAL) ||
18005784:	f117 0f16 	cmn.w	r7, #22
18005788:	d0da      	beq.n	18005740 <mpu_configure_regions_and_partition.constprop.0+0x50>
			(u_reg_index > (reg_index - 1))) {
1800578a:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
1800578c:	42bb      	cmp	r3, r7
1800578e:	dbd7      	blt.n	18005740 <mpu_configure_regions_and_partition.constprop.0+0x50>
	MPU->RNR = index;
18005790:	f8c5 7098 	str.w	r7, [r5, #152]	; 0x98
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
18005794:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
	MPU->RNR = index;
18005798:	f8c5 7098 	str.w	r7, [r5, #152]	; 0x98
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
1800579c:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
180057a0:	f021 011f 	bic.w	r1, r1, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
180057a4:	f043 0b1f 	orr.w	fp, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
180057a8:	e9d6 3200 	ldrd	r3, r2, [r6]
180057ac:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
180057ae:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
180057b0:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i].start == u_reg_base) &&
180057b4:	d11d      	bne.n	180057f2 <mpu_configure_regions_and_partition.constprop.0+0x102>
180057b6:	45d3      	cmp	fp, sl
180057b8:	d107      	bne.n	180057ca <mpu_configure_regions_and_partition.constprop.0+0xda>
			mpu_configure_region(u_reg_index, &regions[i]);
180057ba:	4631      	mov	r1, r6
180057bc:	b2f8      	uxtb	r0, r7
180057be:	f004 fb22 	bl	18009e06 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
180057c2:	f108 0801 	add.w	r8, r8, #1
180057c6:	360c      	adds	r6, #12
180057c8:	e79b      	b.n	18005702 <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
180057ca:	4631      	mov	r1, r6
	MPU->RNR = index;
180057cc:	f8c5 7098 	str.w	r7, [r5, #152]	; 0x98
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
180057d0:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
		| (base & MPU_RBAR_BASE_Msk);
180057d4:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
180057d8:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
180057dc:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
180057de:	f8c5 209c 	str.w	r2, [r5, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
180057e2:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
180057e4:	f004 fb0f 	bl	18009e06 <mpu_configure_region>
			if (reg_index == -EINVAL) {
180057e8:	f110 0f16 	cmn.w	r0, #22
180057ec:	d0b9      	beq.n	18005762 <mpu_configure_regions_and_partition.constprop.0+0x72>
			reg_index++;
180057ee:	1c44      	adds	r4, r0, #1
180057f0:	e7e7      	b.n	180057c2 <mpu_configure_regions_and_partition.constprop.0+0xd2>
				regions[i].start - 1);
180057f2:	3b01      	subs	r3, #1
		} else if (reg_last == u_reg_last) {
180057f4:	45d3      	cmp	fp, sl
				mpu_configure_region(reg_index, &regions[i]);
180057f6:	b2e0      	uxtb	r0, r4
		| (limit & MPU_RLAR_LIMIT_Msk);
180057f8:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
180057fc:	f8c5 7098 	str.w	r7, [r5, #152]	; 0x98
		} else if (reg_last == u_reg_last) {
18005800:	d108      	bne.n	18005814 <mpu_configure_regions_and_partition.constprop.0+0x124>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
18005802:	f8d5 20a0 	ldr.w	r2, [r5, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
18005806:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
18005808:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
1800580c:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
1800580e:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
			reg_index =
18005812:	e7e7      	b.n	180057e4 <mpu_configure_regions_and_partition.constprop.0+0xf4>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
18005814:	f8d5 10a0 	ldr.w	r1, [r5, #160]	; 0xa0
18005818:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
1800581c:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
1800581e:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
18005822:	4631      	mov	r1, r6
18005824:	f004 faef 	bl	18009e06 <mpu_configure_region>
			if (reg_index == -EINVAL) {
18005828:	f110 0f16 	cmn.w	r0, #22
1800582c:	d099      	beq.n	18005762 <mpu_configure_regions_and_partition.constprop.0+0x72>
	MPU->RNR = index;
1800582e:	f8c5 7098 	str.w	r7, [r5, #152]	; 0x98
	attr->rbar = MPU->RBAR &
18005832:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
18005836:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
1800583a:	f10b 3bff 	add.w	fp, fp, #4294967295
	attr->rbar = MPU->RBAR &
1800583e:	f362 0304 	bfi	r3, r2, #0, #5
18005842:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
18005846:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
1800584a:	f89d 2008 	ldrb.w	r2, [sp, #8]
1800584e:	085b      	lsrs	r3, r3, #1
18005850:	f363 1247 	bfi	r2, r3, #5, #3
18005854:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
18005858:	e9d6 3200 	ldrd	r3, r2, [r6]
1800585c:	4413      	add	r3, r2
1800585e:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
18005860:	f023 031f 	bic.w	r3, r3, #31
18005864:	445b      	add	r3, fp
18005866:	eba3 030a 	sub.w	r3, r3, sl
			reg_index++;
1800586a:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
1800586c:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
18005870:	4669      	mov	r1, sp
18005872:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
18005874:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
18005876:	f7ff ff1d 	bl	180056b4 <region_allocate_and_init>
1800587a:	e7b5      	b.n	180057e8 <mpu_configure_regions_and_partition.constprop.0+0xf8>
1800587c:	e000ed00 	.word	0xe000ed00
18005880:	30180098 	.word	0x30180098
18005884:	3018008c 	.word	0x3018008c
18005888:	1800dc67 	.word	0x1800dc67
1800588c:	1800dc44 	.word	0x1800dc44

18005890 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
18005890:	2205      	movs	r2, #5
18005892:	4b04      	ldr	r3, [pc, #16]	; (180058a4 <arm_core_mpu_enable+0x14>)
18005894:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
18005898:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1800589c:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
180058a0:	4770      	bx	lr
180058a2:	bf00      	nop
180058a4:	e000ed00 	.word	0xe000ed00

180058a8 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
180058a8:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
180058ac:	2200      	movs	r2, #0
180058ae:	4b02      	ldr	r3, [pc, #8]	; (180058b8 <arm_core_mpu_disable+0x10>)
180058b0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
180058b4:	4770      	bx	lr
180058b6:	bf00      	nop
180058b8:	e000ed00 	.word	0xe000ed00

180058bc <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
180058bc:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
180058be:	4c03      	ldr	r4, [pc, #12]	; (180058cc <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
180058c0:	7822      	ldrb	r2, [r4, #0]
180058c2:	f7ff ff15 	bl	180056f0 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
180058c6:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
180058c8:	bd10      	pop	{r4, pc}
180058ca:	bf00      	nop
180058cc:	30180a85 	.word	0x30180a85

180058d0 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
180058d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
180058d4:	4d29      	ldr	r5, [pc, #164]	; (1800597c <arm_core_mpu_mark_areas_for_dynamic_regions+0xac>)
180058d6:	468a      	mov	sl, r1

/* This internal function marks and stores the configuration of memory areas
 * where dynamic region programming is allowed. Return zero on success, or
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
180058d8:	4606      	mov	r6, r0
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
180058da:	f04f 0800 	mov.w	r8, #0
180058de:	46ab      	mov	fp, r5
	MPU->RNR = index;
180058e0:	4f27      	ldr	r7, [pc, #156]	; (18005980 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
180058e2:	45d0      	cmp	r8, sl
180058e4:	da1b      	bge.n	1800591e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
180058e6:	f8d6 9004 	ldr.w	r9, [r6, #4]
180058ea:	f1b9 0f00 	cmp.w	r9, #0
180058ee:	d03f      	beq.n	18005970 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
180058f0:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
180058f2:	4608      	mov	r0, r1
180058f4:	9101      	str	r1, [sp, #4]
180058f6:	f004 fa7d 	bl	18009df4 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
180058fa:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
180058fc:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
180058fe:	eb09 0001 	add.w	r0, r9, r1
18005902:	3801      	subs	r0, #1
18005904:	f004 fa76 	bl	18009df4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
18005908:	4284      	cmp	r4, r0
1800590a:	f04f 0214 	mov.w	r2, #20
1800590e:	4b1d      	ldr	r3, [pc, #116]	; (18005984 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb4>)
18005910:	d008      	beq.n	18005924 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
18005912:	f06f 0315 	mvn.w	r3, #21
18005916:	fb02 f808 	mul.w	r8, r2, r8
1800591a:	f84b 3008 	str.w	r3, [fp, r8]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
1800591e:	b003      	add	sp, #12
18005920:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
18005924:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
18005928:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
1800592a:	d0f8      	beq.n	1800591e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
1800592c:	7819      	ldrb	r1, [r3, #0]
1800592e:	42a1      	cmp	r1, r4
18005930:	ddf5      	ble.n	1800591e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
18005932:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
18005936:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
	MPU->RNR = index;
1800593a:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
	attr->rbar = MPU->RBAR &
1800593e:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
18005942:	f100 0108 	add.w	r1, r0, #8
18005946:	7b00      	ldrb	r0, [r0, #12]
18005948:	f364 0004 	bfi	r0, r4, #0, #5
1800594c:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
1800594e:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
18005952:	790c      	ldrb	r4, [r1, #4]
18005954:	0840      	lsrs	r0, r0, #1
18005956:	f360 1447 	bfi	r4, r0, #5, #3
1800595a:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
1800595c:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
18005960:	f021 011f 	bic.w	r1, r1, #31
18005964:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
18005966:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
1800596a:	f021 011f 	bic.w	r1, r1, #31
1800596e:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
18005970:	f108 0801 	add.w	r8, r8, #1
18005974:	3514      	adds	r5, #20
18005976:	360c      	adds	r6, #12
18005978:	e7b3      	b.n	180058e2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
1800597a:	bf00      	nop
1800597c:	301808d4 	.word	0x301808d4
18005980:	e000ed00 	.word	0xe000ed00
18005984:	30180a85 	.word	0x30180a85

18005988 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
18005988:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
1800598a:	4d0e      	ldr	r5, [pc, #56]	; (180059c4 <z_arm_mpu_init+0x3c>)
1800598c:	682c      	ldr	r4, [r5, #0]
1800598e:	2c08      	cmp	r4, #8
18005990:	d815      	bhi.n	180059be <z_arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
18005992:	2000      	movs	r0, #0
	arm_core_mpu_disable();
18005994:	f7ff ff88 	bl	180058a8 <arm_core_mpu_disable>
	MPU->MAIR0 =
18005998:	4b0b      	ldr	r3, [pc, #44]	; (180059c8 <z_arm_mpu_init+0x40>)
1800599a:	4a0c      	ldr	r2, [pc, #48]	; (180059cc <z_arm_mpu_init+0x44>)
1800599c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
180059a0:	4284      	cmp	r4, r0
180059a2:	d105      	bne.n	180059b0 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
180059a4:	4b0a      	ldr	r3, [pc, #40]	; (180059d0 <z_arm_mpu_init+0x48>)
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
180059a6:	2000      	movs	r0, #0
	static_regions_num = mpu_config.num_regions;
180059a8:	701c      	strb	r4, [r3, #0]
	arm_core_mpu_enable();
180059aa:	f7ff ff71 	bl	18005890 <arm_core_mpu_enable>
}
180059ae:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
180059b0:	6869      	ldr	r1, [r5, #4]
180059b2:	eb01 1100 	add.w	r1, r1, r0, lsl #4
180059b6:	f7ff fe63 	bl	18005680 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
180059ba:	3001      	adds	r0, #1
180059bc:	e7f0      	b.n	180059a0 <z_arm_mpu_init+0x18>
		return -1;
180059be:	f04f 30ff 	mov.w	r0, #4294967295
180059c2:	e7f4      	b.n	180059ae <z_arm_mpu_init+0x26>
180059c4:	1800baa8 	.word	0x1800baa8
180059c8:	e000ed00 	.word	0xe000ed00
180059cc:	0044ffaa 	.word	0x0044ffaa
180059d0:	30180a85 	.word	0x30180a85

180059d4 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
180059d4:	4b01      	ldr	r3, [pc, #4]	; (180059dc <__stdout_hook_install+0x8>)
180059d6:	6018      	str	r0, [r3, #0]
}
180059d8:	4770      	bx	lr
180059da:	bf00      	nop
180059dc:	30180060 	.word	0x30180060

180059e0 <rt_super_pinmux_init>:
 * @param   modefunc    : OR'ed values of type IOPCTL_*
 * @return  Nothing
 */
__STATIC_INLINE void IOPCTL_PinMuxSet(IOPCTL_Type *base, uint8_t port, uint8_t pin, uint32_t modefunc)
{
    base->PIO[port][pin] = modefunc;
180059e0:	2201      	movs	r2, #1
180059e2:	4b04      	ldr	r3, [pc, #16]	; (180059f4 <rt_super_pinmux_init+0x14>)
	/* PORT1 PIN1 (coords: G15) is configured as PIO1_1 */
	IOPCTL_PinMuxSet(IOPCTL, 1U, 1U, port1_pin1_config);
#endif

	return 0;
}
180059e4:	2000      	movs	r0, #0
180059e6:	605a      	str	r2, [r3, #4]
180059e8:	2241      	movs	r2, #65	; 0x41
180059ea:	609a      	str	r2, [r3, #8]
180059ec:	2240      	movs	r2, #64	; 0x40
180059ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
180059f2:	4770      	bx	lr
180059f4:	50004000 	.word	0x50004000

180059f8 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
180059f8:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
180059fa:	4808      	ldr	r0, [pc, #32]	; (18005a1c <uart_console_init+0x24>)
180059fc:	4b08      	ldr	r3, [pc, #32]	; (18005a20 <uart_console_init+0x28>)
180059fe:	6018      	str	r0, [r3, #0]
18005a00:	f004 ffcd 	bl	1800a99e <z_device_ready>
18005a04:	b138      	cbz	r0, 18005a16 <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
18005a06:	4807      	ldr	r0, [pc, #28]	; (18005a24 <uart_console_init+0x2c>)
18005a08:	f7ff ffe4 	bl	180059d4 <__stdout_hook_install>
	__printk_hook_install(console_out);
18005a0c:	4805      	ldr	r0, [pc, #20]	; (18005a24 <uart_console_init+0x2c>)
18005a0e:	f7fb feeb 	bl	180017e8 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
18005a12:	2000      	movs	r0, #0
}
18005a14:	bd08      	pop	{r3, pc}
		return -ENODEV;
18005a16:	f06f 0012 	mvn.w	r0, #18
18005a1a:	e7fb      	b.n	18005a14 <uart_console_init+0x1c>
18005a1c:	1800b180 	.word	0x1800b180
18005a20:	301808e8 	.word	0x301808e8
18005a24:	18005a29 	.word	0x18005a29

18005a28 <console_out>:
	if ('\n' == c) {
18005a28:	280a      	cmp	r0, #10
{
18005a2a:	b538      	push	{r3, r4, r5, lr}
18005a2c:	4604      	mov	r4, r0
18005a2e:	4d07      	ldr	r5, [pc, #28]	; (18005a4c <console_out+0x24>)
	if ('\n' == c) {
18005a30:	d104      	bne.n	18005a3c <console_out+0x14>
		uart_poll_out(uart_console_dev, '\r');
18005a32:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
18005a34:	6883      	ldr	r3, [r0, #8]
18005a36:	210d      	movs	r1, #13
18005a38:	685b      	ldr	r3, [r3, #4]
18005a3a:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
18005a3c:	6828      	ldr	r0, [r5, #0]
18005a3e:	6883      	ldr	r3, [r0, #8]
18005a40:	b2e1      	uxtb	r1, r4
18005a42:	685b      	ldr	r3, [r3, #4]
18005a44:	4798      	blx	r3
}
18005a46:	4620      	mov	r0, r4
18005a48:	bd38      	pop	{r3, r4, r5, pc}
18005a4a:	bf00      	nop
18005a4c:	301808e8 	.word	0x301808e8

18005a50 <gpio_mcux_lpc_pin_interrupt_configure>:

static int gpio_mcux_lpc_pin_interrupt_configure(const struct device *dev,
						 gpio_pin_t pin,
						 enum gpio_int_mode mode,
						 enum gpio_int_trig trig)
{
18005a50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct gpio_mcux_lpc_config *config = dev->config;
18005a54:	6846      	ldr	r6, [r0, #4]
	uint32_t isr;
	uint32_t pint_idx;
	static bool pint_inited;

	/* Ensure pin used as interrupt is set as input*/
	if ((mode & GPIO_INT_ENABLE) &&
18005a56:	0454      	lsls	r4, r2, #17
{
18005a58:	460d      	mov	r5, r1
	uint32_t port = config->port_no;
18005a5a:	f8d6 9010 	ldr.w	r9, [r6, #16]
	if ((mode & GPIO_INT_ENABLE) &&
18005a5e:	d507      	bpl.n	18005a70 <gpio_mcux_lpc_pin_interrupt_configure+0x20>
	GPIO_Type *gpio_base = config->gpio_base;
18005a60:	6871      	ldr	r1, [r6, #4]
		((gpio_base->DIR[port] & BIT(pin)) != 0)) {
18005a62:	f509 6400 	add.w	r4, r9, #2048	; 0x800
18005a66:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
18005a6a:	40e9      	lsrs	r1, r5
	if ((mode & GPIO_INT_ENABLE) &&
18005a6c:	07c9      	lsls	r1, r1, #31
18005a6e:	d408      	bmi.n	18005a82 <gpio_mcux_lpc_pin_interrupt_configure+0x32>
		return -ENOTSUP;
	}

	switch (mode) {
18005a70:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
18005a74:	d008      	beq.n	18005a88 <gpio_mcux_lpc_pin_interrupt_configure+0x38>
18005a76:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
18005a7a:	d00d      	beq.n	18005a98 <gpio_mcux_lpc_pin_interrupt_configure+0x48>
18005a7c:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
18005a80:	d030      	beq.n	18005ae4 <gpio_mcux_lpc_pin_interrupt_configure+0x94>
		return -ENOTSUP;
18005a82:	f06f 0085 	mvn.w	r0, #133	; 0x85
18005a86:	e02b      	b.n	18005ae0 <gpio_mcux_lpc_pin_interrupt_configure+0x90>
	case GPIO_INT_MODE_DISABLED:
		interruptMode = kPINT_PinIntEnableNone;
		break;
	case GPIO_INT_MODE_LEVEL:
		if (trig == GPIO_INT_TRIG_HIGH) {
18005a88:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
18005a8c:	d02c      	beq.n	18005ae8 <gpio_mcux_lpc_pin_interrupt_configure+0x98>
			interruptMode = kPINT_PinIntEnableHighLevel;
		} else if (trig == GPIO_INT_TRIG_LOW) {
18005a8e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
18005a92:	d1f6      	bne.n	18005a82 <gpio_mcux_lpc_pin_interrupt_configure+0x32>
			interruptMode = kPINT_PinIntEnableLowLevel;
18005a94:	2710      	movs	r7, #16
18005a96:	e007      	b.n	18005aa8 <gpio_mcux_lpc_pin_interrupt_configure+0x58>
		} else {
			return -ENOTSUP;
		}
		break;
	case GPIO_INT_MODE_EDGE:
		if (trig == GPIO_INT_TRIG_HIGH) {
18005a98:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
18005a9c:	d026      	beq.n	18005aec <gpio_mcux_lpc_pin_interrupt_configure+0x9c>
			interruptMode = kPINT_PinIntEnableRiseEdge;
		} else if (trig == GPIO_INT_TRIG_LOW) {
			interruptMode = kPINT_PinIntEnableFallEdge;
		} else {
			interruptMode = kPINT_PinIntEnableBothEdges;
18005a9e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
18005aa2:	bf0c      	ite	eq
18005aa4:	2702      	moveq	r7, #2
18005aa6:	2703      	movne	r7, #3
	struct gpio_mcux_lpc_data *data = dev->data;
18005aa8:	6903      	ldr	r3, [r0, #16]
	default:
		return -ENOTSUP;
	}

	/* First time calling this function routes PIN->PINT->INPUTMUX->NVIC */
	if (data->pint_id[pin] == NO_PINT_INT) {
18005aaa:	eb03 0805 	add.w	r8, r3, r5
18005aae:	f898 200c 	ldrb.w	r2, [r8, #12]
18005ab2:	2a01      	cmp	r2, #1
18005ab4:	d132      	bne.n	18005b1c <gpio_mcux_lpc_pin_interrupt_configure+0xcc>
	for (i = 0; i < data->isr_list_idx; i++) {
18005ab6:	2200      	movs	r2, #0
18005ab8:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
18005aba:	f103 012c 	add.w	r1, r3, #44	; 0x2c
18005abe:	4282      	cmp	r2, r0
18005ac0:	d00c      	beq.n	18005adc <gpio_mcux_lpc_pin_interrupt_configure+0x8c>
		if (data->isr_list[i] != -1) {
18005ac2:	f851 4b04 	ldr.w	r4, [r1], #4
18005ac6:	f1b4 3fff 	cmp.w	r4, #4294967295
18005aca:	d011      	beq.n	18005af0 <gpio_mcux_lpc_pin_interrupt_configure+0xa0>
			data->isr_list[i] = -1;
18005acc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
18005ad0:	f04f 32ff 	mov.w	r2, #4294967295
		isr = get_free_isr(data);
		if (isr == -EINVAL) {
18005ad4:	f114 0f16 	cmn.w	r4, #22
			data->isr_list[i] = -1;
18005ad8:	62da      	str	r2, [r3, #44]	; 0x2c
		if (isr == -EINVAL) {
18005ada:	d10b      	bne.n	18005af4 <gpio_mcux_lpc_pin_interrupt_configure+0xa4>
			/* Didn't find any free interrupt in this port */
			return -EBUSY;
18005adc:	f06f 000f 	mvn.w	r0, #15
	PINT_PinInterruptConfig(config->pint_base, data->pint_id[pin],
		interruptMode,
		(pint_cb_t)gpio_mcux_lpc_port_isr);

	return 0;
}
18005ae0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	switch (mode) {
18005ae4:	2700      	movs	r7, #0
18005ae6:	e7df      	b.n	18005aa8 <gpio_mcux_lpc_pin_interrupt_configure+0x58>
			interruptMode = kPINT_PinIntEnableHighLevel;
18005ae8:	2712      	movs	r7, #18
18005aea:	e7dd      	b.n	18005aa8 <gpio_mcux_lpc_pin_interrupt_configure+0x58>
			interruptMode = kPINT_PinIntEnableRiseEdge;
18005aec:	2701      	movs	r7, #1
18005aee:	e7db      	b.n	18005aa8 <gpio_mcux_lpc_pin_interrupt_configure+0x58>
	for (i = 0; i < data->isr_list_idx; i++) {
18005af0:	3201      	adds	r2, #1
18005af2:	e7e4      	b.n	18005abe <gpio_mcux_lpc_pin_interrupt_configure+0x6e>
	INPUTMUX_Init(INPUTMUX);
18005af4:	4812      	ldr	r0, [pc, #72]	; (18005b40 <gpio_mcux_lpc_pin_interrupt_configure+0xf0>)
18005af6:	f000 fd7f 	bl	180065f8 <INPUTMUX_Init>
	if (isr_no < PIN_INT4_IRQn) {
18005afa:	2c22      	cmp	r4, #34	; 0x22
		pint_idx = isr_no - PIN_INT0_IRQn;
18005afc:	bf94      	ite	ls
18005afe:	3c04      	subls	r4, #4
		pint_idx = isr_no - PIN_INT4_IRQn + 4;
18005b00:	3c1f      	subhi	r4, #31
			      PIN_TO_INPUT_MUX_CONNECTION(port, pin));
18005b02:	f509 0200 	add.w	r2, r9, #8388608	; 0x800000
	INPUTMUX_AttachSignal(INPUTMUX, pint_idx,
18005b06:	4621      	mov	r1, r4
18005b08:	480d      	ldr	r0, [pc, #52]	; (18005b40 <gpio_mcux_lpc_pin_interrupt_configure+0xf0>)
18005b0a:	eb05 1242 	add.w	r2, r5, r2, lsl #5
18005b0e:	f004 fe24 	bl	1800a75a <INPUTMUX_AttachSignal>
	INPUTMUX_Deinit(INPUTMUX);
18005b12:	480b      	ldr	r0, [pc, #44]	; (18005b40 <gpio_mcux_lpc_pin_interrupt_configure+0xf0>)
18005b14:	f000 fd78 	bl	18006608 <INPUTMUX_Deinit>
		data->pint_id[pin] = pint_idx;
18005b18:	f888 400c 	strb.w	r4, [r8, #12]
	if (!pint_inited) {
18005b1c:	4c09      	ldr	r4, [pc, #36]	; (18005b44 <gpio_mcux_lpc_pin_interrupt_configure+0xf4>)
18005b1e:	7823      	ldrb	r3, [r4, #0]
18005b20:	b923      	cbnz	r3, 18005b2c <gpio_mcux_lpc_pin_interrupt_configure+0xdc>
		PINT_Init(config->pint_base);
18005b22:	68b0      	ldr	r0, [r6, #8]
18005b24:	f000 fd1e 	bl	18006564 <PINT_Init>
		pint_inited = true;
18005b28:	2301      	movs	r3, #1
18005b2a:	7023      	strb	r3, [r4, #0]
	PINT_PinInterruptConfig(config->pint_base, data->pint_id[pin],
18005b2c:	68b0      	ldr	r0, [r6, #8]
18005b2e:	463a      	mov	r2, r7
18005b30:	4b05      	ldr	r3, [pc, #20]	; (18005b48 <gpio_mcux_lpc_pin_interrupt_configure+0xf8>)
18005b32:	f898 100c 	ldrb.w	r1, [r8, #12]
18005b36:	f000 fd39 	bl	180065ac <PINT_PinInterruptConfig>
	return 0;
18005b3a:	2000      	movs	r0, #0
18005b3c:	e7d0      	b.n	18005ae0 <gpio_mcux_lpc_pin_interrupt_configure+0x90>
18005b3e:	bf00      	nop
18005b40:	50026000 	.word	0x50026000
18005b44:	30180a86 	.word	0x30180a86
18005b48:	1800a47d 	.word	0x1800a47d

18005b4c <mcux_lpc_ostick_isr>:
static struct k_spinlock lock;
static uint64_t last_count;
static OSTIMER_Type *base;

void mcux_lpc_ostick_isr(void *arg)
{
18005b4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__asm__ volatile(
18005b50:	f04f 0320 	mov.w	r3, #32
18005b54:	f3ef 8611 	mrs	r6, BASEPRI
18005b58:	f383 8812 	msr	BASEPRI_MAX, r3
18005b5c:	f3bf 8f6f 	isb	sy
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = OSTIMER_GetCurrentTimerValue(base);
18005b60:	f8df 8048 	ldr.w	r8, [pc, #72]	; 18005bac <mcux_lpc_ostick_isr+0x60>
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
18005b64:	4c12      	ldr	r4, [pc, #72]	; (18005bb0 <mcux_lpc_ostick_isr+0x64>)
	uint64_t now = OSTIMER_GetCurrentTimerValue(base);
18005b66:	f8d8 0000 	ldr.w	r0, [r8]
18005b6a:	f004 fdfd 	bl	1800a768 <OSTIMER_GetCurrentTimerValue>
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
18005b6e:	e9d4 7500 	ldrd	r7, r5, [r4]
18005b72:	1bc0      	subs	r0, r0, r7
18005b74:	eb61 0105 	sbc.w	r1, r1, r5
18005b78:	2264      	movs	r2, #100	; 0x64
18005b7a:	2300      	movs	r3, #0
18005b7c:	f7fb fbd8 	bl	18001330 <__aeabi_uldivmod>

	/* Clear interrupt flag by writing 1. */
	base->OSEVENT_CTRL &= ~OSTIMER_OSEVENT_CTRL_OSTIMER_INTENA_MASK;
18005b80:	f8d8 2000 	ldr.w	r2, [r8]
18005b84:	69d3      	ldr	r3, [r2, #28]
18005b86:	f023 0302 	bic.w	r3, r3, #2
18005b8a:	61d3      	str	r3, [r2, #28]

	last_count += dticks * CYC_PER_TICK;
18005b8c:	2364      	movs	r3, #100	; 0x64
18005b8e:	4343      	muls	r3, r0
18005b90:	19db      	adds	r3, r3, r7
18005b92:	f145 0500 	adc.w	r5, r5, #0
18005b96:	e9c4 3500 	strd	r3, r5, [r4]
	__asm__ volatile(
18005b9a:	f386 8811 	msr	BASEPRI, r6
18005b9e:	f3bf 8f6f 	isb	sy
		OSTIMER_SetMatchValue(base, next, NULL);
	}

	k_spin_unlock(&lock, key);
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
18005ba2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
18005ba6:	f001 bf55 	b.w	18007a54 <sys_clock_announce>
18005baa:	bf00      	nop
18005bac:	301809e4 	.word	0x301809e4
18005bb0:	301802d0 	.word	0x301802d0

18005bb4 <sys_clock_driver_init>:
{
	return OSTIMER_GetCurrentTimerValue(base);
}

static int sys_clock_driver_init(const struct device *dev)
{
18005bb4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	ARG_UNUSED(dev);

	/* Configure event timer's ISR */
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
18005bb6:	2200      	movs	r2, #0
18005bb8:	2029      	movs	r0, #41	; 0x29
18005bba:	4611      	mov	r1, r2
18005bbc:	f7ff f834 	bl	18004c28 <z_arm_irq_priority_set>
					mcux_lpc_ostick_isr, NULL, 0);

	base = (OSTIMER_Type *)DT_INST_REG_ADDR(0);
18005bc0:	4c0e      	ldr	r4, [pc, #56]	; (18005bfc <sys_clock_driver_init+0x48>)
18005bc2:	4b0f      	ldr	r3, [pc, #60]	; (18005c00 <sys_clock_driver_init+0x4c>)

	EnableDeepSleepIRQ(DT_INST_IRQN(0));
18005bc4:	2029      	movs	r0, #41	; 0x29
	base = (OSTIMER_Type *)DT_INST_REG_ADDR(0);
18005bc6:	6023      	str	r3, [r4, #0]
	EnableDeepSleepIRQ(DT_INST_IRQN(0));
18005bc8:	f000 fbe8 	bl	1800639c <EnableDeepSleepIRQ>

	/* Initialize the OS timer, setting clock configuration. */
	OSTIMER_Init(base);
18005bcc:	6820      	ldr	r0, [r4, #0]
18005bce:	f000 fd3d 	bl	1800664c <OSTIMER_Init>

	last_count = OSTIMER_GetCurrentTimerValue(base);
18005bd2:	6820      	ldr	r0, [r4, #0]
18005bd4:	f004 fdc8 	bl	1800a768 <OSTIMER_GetCurrentTimerValue>
	OSTIMER_SetMatchValue(base, last_count + CYC_PER_TICK, NULL);
18005bd8:	2500      	movs	r5, #0
	last_count = OSTIMER_GetCurrentTimerValue(base);
18005bda:	4b0a      	ldr	r3, [pc, #40]	; (18005c04 <sys_clock_driver_init+0x50>)
	OSTIMER_SetMatchValue(base, last_count + CYC_PER_TICK, NULL);
18005bdc:	f110 0264 	adds.w	r2, r0, #100	; 0x64
	last_count = OSTIMER_GetCurrentTimerValue(base);
18005be0:	e9c3 0100 	strd	r0, r1, [r3]
	OSTIMER_SetMatchValue(base, last_count + CYC_PER_TICK, NULL);
18005be4:	f141 0300 	adc.w	r3, r1, #0
18005be8:	6820      	ldr	r0, [r4, #0]
18005bea:	9500      	str	r5, [sp, #0]
18005bec:	f004 fdcb 	bl	1800a786 <OSTIMER_SetMatchValue>

	/* Enable event timer interrupt */
	irq_enable(DT_INST_IRQN(0));
18005bf0:	2029      	movs	r0, #41	; 0x29
18005bf2:	f7ff f809 	bl	18004c08 <arch_irq_enable>

	return 0;
}
18005bf6:	4628      	mov	r0, r5
18005bf8:	b003      	add	sp, #12
18005bfa:	bd30      	pop	{r4, r5, pc}
18005bfc:	301809e4 	.word	0x301809e4
18005c00:	50113000 	.word	0x50113000
18005c04:	301802d0 	.word	0x301802d0

18005c08 <sys_clock_set_timeout>:
	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
18005c08:	4b21      	ldr	r3, [pc, #132]	; (18005c90 <sys_clock_set_timeout+0x88>)
{
18005c0a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
18005c0c:	f1b0 3fff 	cmp.w	r0, #4294967295
18005c10:	bf14      	ite	ne
18005c12:	4604      	movne	r4, r0
18005c14:	461c      	moveq	r4, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
18005c16:	3c01      	subs	r4, #1
18005c18:	2c00      	cmp	r4, #0
18005c1a:	dd37      	ble.n	18005c8c <sys_clock_set_timeout+0x84>
18005c1c:	429c      	cmp	r4, r3
18005c1e:	bfa8      	it	ge
18005c20:	461c      	movge	r4, r3
	__asm__ volatile(
18005c22:	f04f 0320 	mov.w	r3, #32
18005c26:	f3ef 8611 	mrs	r6, BASEPRI
18005c2a:	f383 8812 	msr	BASEPRI_MAX, r3
18005c2e:	f3bf 8f6f 	isb	sy
	uint64_t now = OSTIMER_GetCurrentTimerValue(base);
18005c32:	4d18      	ldr	r5, [pc, #96]	; (18005c94 <sys_clock_set_timeout+0x8c>)
18005c34:	6828      	ldr	r0, [r5, #0]
18005c36:	f004 fd97 	bl	1800a768 <OSTIMER_GetCurrentTimerValue>
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
18005c3a:	f04f 0c64 	mov.w	ip, #100	; 0x64
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
18005c3e:	4b16      	ldr	r3, [pc, #88]	; (18005c98 <sys_clock_set_timeout+0x90>)
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
18005c40:	fb0c f404 	mul.w	r4, ip, r4
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
18005c44:	e9d3 7300 	ldrd	r7, r3, [r3]
18005c48:	f1c7 0163 	rsb	r1, r7, #99	; 0x63
18005c4c:	180a      	adds	r2, r1, r0
	if (cyc <= MAX_CYC - adj) {
18005c4e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
18005c52:	eba1 0e02 	sub.w	lr, r1, r2
18005c56:	45a6      	cmp	lr, r4
		cyc += adj;
18005c58:	bf28      	it	cs
18005c5a:	18a1      	addcs	r1, r4, r2
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
18005c5c:	fbb1 f1fc 	udiv	r1, r1, ip
18005c60:	fb0c f201 	mul.w	r2, ip, r1
	OSTIMER_SetMatchValue(base, cyc + last_count, NULL);
18005c64:	2100      	movs	r1, #0
	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
18005c66:	1a38      	subs	r0, r7, r0
18005c68:	4410      	add	r0, r2
18005c6a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
		cyc += CYC_PER_TICK;
18005c6e:	bfb8      	it	lt
18005c70:	3264      	addlt	r2, #100	; 0x64
	OSTIMER_SetMatchValue(base, cyc + last_count, NULL);
18005c72:	19d2      	adds	r2, r2, r7
18005c74:	6828      	ldr	r0, [r5, #0]
18005c76:	9100      	str	r1, [sp, #0]
18005c78:	f143 0300 	adc.w	r3, r3, #0
18005c7c:	f004 fd83 	bl	1800a786 <OSTIMER_SetMatchValue>
	__asm__ volatile(
18005c80:	f386 8811 	msr	BASEPRI, r6
18005c84:	f3bf 8f6f 	isb	sy
}
18005c88:	b003      	add	sp, #12
18005c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
18005c8c:	2400      	movs	r4, #0
18005c8e:	e7c8      	b.n	18005c22 <sys_clock_set_timeout+0x1a>
18005c90:	0147ae13 	.word	0x0147ae13
18005c94:	301809e4 	.word	0x301809e4
18005c98:	301802d0 	.word	0x301802d0

18005c9c <sys_clock_elapsed>:
{
18005c9c:	b510      	push	{r4, lr}
	__asm__ volatile(
18005c9e:	f04f 0320 	mov.w	r3, #32
18005ca2:	f3ef 8411 	mrs	r4, BASEPRI
18005ca6:	f383 8812 	msr	BASEPRI_MAX, r3
18005caa:	f3bf 8f6f 	isb	sy
	uint32_t ret = ((uint32_t)OSTIMER_GetCurrentTimerValue(base) -
18005cae:	4b07      	ldr	r3, [pc, #28]	; (18005ccc <sys_clock_elapsed+0x30>)
18005cb0:	6818      	ldr	r0, [r3, #0]
18005cb2:	f004 fd59 	bl	1800a768 <OSTIMER_GetCurrentTimerValue>
					(uint32_t)last_count) / CYC_PER_TICK;
18005cb6:	4b06      	ldr	r3, [pc, #24]	; (18005cd0 <sys_clock_elapsed+0x34>)
	uint32_t ret = ((uint32_t)OSTIMER_GetCurrentTimerValue(base) -
18005cb8:	681b      	ldr	r3, [r3, #0]
18005cba:	1ac0      	subs	r0, r0, r3
18005cbc:	2364      	movs	r3, #100	; 0x64
18005cbe:	fbb0 f0f3 	udiv	r0, r0, r3
	__asm__ volatile(
18005cc2:	f384 8811 	msr	BASEPRI, r4
18005cc6:	f3bf 8f6f 	isb	sy
}
18005cca:	bd10      	pop	{r4, pc}
18005ccc:	301809e4 	.word	0x301809e4
18005cd0:	301802d0 	.word	0x301802d0

18005cd4 <sys_clock_cycle_get_32>:
{
18005cd4:	b508      	push	{r3, lr}
	return (uint32_t)OSTIMER_GetCurrentTimerValue(base);
18005cd6:	4b02      	ldr	r3, [pc, #8]	; (18005ce0 <sys_clock_cycle_get_32+0xc>)
18005cd8:	6818      	ldr	r0, [r3, #0]
18005cda:	f004 fd45 	bl	1800a768 <OSTIMER_GetCurrentTimerValue>
}
18005cde:	bd08      	pop	{r3, pc}
18005ce0:	301809e4 	.word	0x301809e4

18005ce4 <CLOCK_GetOsc32KFreq>:
    return ((CLKCTL0->OSC32KHZCTL0 & CLKCTL0_OSC32KHZCTL0_ENA32KHZ_MASK) != 0UL) ? CLK_RTC_32K_CLK : 0U;
18005ce4:	4b04      	ldr	r3, [pc, #16]	; (18005cf8 <CLOCK_GetOsc32KFreq+0x14>)
18005ce6:	f8d3 01c0 	ldr.w	r0, [r3, #448]	; 0x1c0
18005cea:	f010 0001 	ands.w	r0, r0, #1
}
18005cee:	bf18      	it	ne
18005cf0:	f44f 4000 	movne.w	r0, #32768	; 0x8000
18005cf4:	4770      	bx	lr
18005cf6:	bf00      	nop
18005cf8:	50001000 	.word	0x50001000

18005cfc <CLOCK_GetXtalInClkFreq>:
    return (CLKCTL0->SYSOSCBYPASS == 0U) ? g_xtalFreq : ((CLKCTL0->SYSOSCBYPASS == 1U) ? g_clkinFreq : 0U);
18005cfc:	4b07      	ldr	r3, [pc, #28]	; (18005d1c <CLOCK_GetXtalInClkFreq+0x20>)
18005cfe:	f8d3 2168 	ldr.w	r2, [r3, #360]	; 0x168
18005d02:	b132      	cbz	r2, 18005d12 <CLOCK_GetXtalInClkFreq+0x16>
18005d04:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
18005d08:	2b01      	cmp	r3, #1
18005d0a:	d104      	bne.n	18005d16 <CLOCK_GetXtalInClkFreq+0x1a>
18005d0c:	4b04      	ldr	r3, [pc, #16]	; (18005d20 <CLOCK_GetXtalInClkFreq+0x24>)
18005d0e:	6818      	ldr	r0, [r3, #0]
18005d10:	4770      	bx	lr
18005d12:	4b04      	ldr	r3, [pc, #16]	; (18005d24 <CLOCK_GetXtalInClkFreq+0x28>)
18005d14:	e7fb      	b.n	18005d0e <CLOCK_GetXtalInClkFreq+0x12>
18005d16:	2000      	movs	r0, #0
}
18005d18:	4770      	bx	lr
18005d1a:	bf00      	nop
18005d1c:	50001000 	.word	0x50001000
18005d20:	301809e8 	.word	0x301809e8
18005d24:	301809f0 	.word	0x301809f0

18005d28 <CLOCK_GetFFroFreq>:
 */
uint32_t CLOCK_GetFFroFreq(void)
{
    uint32_t freq = 0U;
    /* FFROCTL0 should not be touched by application */
    switch ((CLKCTL0->FFROCTL0) & CLKCTL0_FFROCTL0_TRIM_RANGE_MASK)
18005d28:	4b06      	ldr	r3, [pc, #24]	; (18005d44 <CLOCK_GetFFroFreq+0x1c>)
18005d2a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
18005d2e:	f413 2340 	ands.w	r3, r3, #786432	; 0xc0000
18005d32:	d005      	beq.n	18005d40 <CLOCK_GetFFroFreq+0x18>
18005d34:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
18005d38:	4803      	ldr	r0, [pc, #12]	; (18005d48 <CLOCK_GetFFroFreq+0x20>)
18005d3a:	bf18      	it	ne
18005d3c:	2000      	movne	r0, #0
18005d3e:	4770      	bx	lr
    {
        case CLKCTL0_FFROCTL0_TRIM_RANGE(0):
            freq = CLK_FRO_48MHZ;
18005d40:	4802      	ldr	r0, [pc, #8]	; (18005d4c <CLOCK_GetFFroFreq+0x24>)
        default:
            freq = 0U;
            break;
    }
    return freq;
}
18005d42:	4770      	bx	lr
18005d44:	50001000 	.word	0x50001000
18005d48:	03938700 	.word	0x03938700
18005d4c:	02dc6c00 	.word	0x02dc6c00

18005d50 <CLOCK_GetSysPllFreq>:
/* Get SYSTEM PLL Clk */
/*! brief  Return Frequency of SYSPLL
 *  return Frequency of SYSPLL
 */
uint32_t CLOCK_GetSysPllFreq(void)
{
18005d50:	b510      	push	{r4, lr}
    uint32_t freq = 0U;
    uint64_t freqTmp;

    switch ((CLKCTL0->SYSPLL0CLKSEL) & CLKCTL0_SYSPLL0CLKSEL_SEL_MASK)
18005d52:	4c14      	ldr	r4, [pc, #80]	; (18005da4 <CLOCK_GetSysPllFreq+0x54>)
18005d54:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
18005d58:	f003 0307 	and.w	r3, r3, #7
18005d5c:	2b01      	cmp	r3, #1
18005d5e:	d019      	beq.n	18005d94 <CLOCK_GetSysPllFreq+0x44>
18005d60:	2b02      	cmp	r3, #2
18005d62:	d01a      	beq.n	18005d9a <CLOCK_GetSysPllFreq+0x4a>
18005d64:	2b00      	cmp	r3, #0
18005d66:	4810      	ldr	r0, [pc, #64]	; (18005da8 <CLOCK_GetSysPllFreq+0x58>)
18005d68:	bf18      	it	ne
18005d6a:	2000      	movne	r0, #0
        default:
            /* Added comments to prevent the violation of MISRA C-2012 rule. */
            break;
    }

    if (((CLKCTL0->SYSPLL0CTL0) & CLKCTL0_SYSPLL0CTL0_BYPASS_MASK) == 0U)
18005d6c:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
18005d70:	f013 0301 	ands.w	r3, r3, #1
18005d74:	d10d      	bne.n	18005d92 <CLOCK_GetSysPllFreq+0x42>
    {
        /* PLL output frequency = Fref * (DIV_SELECT + NUM/DENOM). */
        freqTmp = ((uint64_t)freq * ((uint64_t)(CLKCTL0->SYSPLL0NUM))) / ((uint64_t)(CLKCTL0->SYSPLL0DENOM));
18005d76:	f8d4 1210 	ldr.w	r1, [r4, #528]	; 0x210
18005d7a:	f8d4 2214 	ldr.w	r2, [r4, #532]	; 0x214
        freq *= ((CLKCTL0->SYSPLL0CTL0) & CLKCTL0_SYSPLL0CTL0_MULT_MASK) >> CLKCTL0_SYSPLL0CTL0_MULT_SHIFT;
18005d7e:	f8d4 4204 	ldr.w	r4, [r4, #516]	; 0x204
18005d82:	f3c4 4407 	ubfx	r4, r4, #16, #8
18005d86:	4344      	muls	r4, r0
        freqTmp = ((uint64_t)freq * ((uint64_t)(CLKCTL0->SYSPLL0NUM))) / ((uint64_t)(CLKCTL0->SYSPLL0DENOM));
18005d88:	fba0 0101 	umull	r0, r1, r0, r1
18005d8c:	f7fb fad0 	bl	18001330 <__aeabi_uldivmod>
        freq += (uint32_t)freqTmp;
18005d90:	4420      	add	r0, r4
    }
    return freq;
}
18005d92:	bd10      	pop	{r4, pc}
            freq = CLOCK_GetXtalInClkFreq();
18005d94:	f7ff ffb2 	bl	18005cfc <CLOCK_GetXtalInClkFreq>
            break;
18005d98:	e7e8      	b.n	18005d6c <CLOCK_GetSysPllFreq+0x1c>
            freq = CLOCK_GetFFroFreq() / 2U;
18005d9a:	f7ff ffc5 	bl	18005d28 <CLOCK_GetFFroFreq>
18005d9e:	0840      	lsrs	r0, r0, #1
            break;
18005da0:	e7e4      	b.n	18005d6c <CLOCK_GetSysPllFreq+0x1c>
18005da2:	bf00      	nop
18005da4:	50001000 	.word	0x50001000
18005da8:	00f42400 	.word	0x00f42400

18005dac <CLOCK_GetSysPfdFreq>:
/*! brief  Get current output frequency of specific System PLL PFD.
 *  param   pfd    : pfd name to get frequency.
 *  return  Frequency of SYSPLL PFD.
 */
uint32_t CLOCK_GetSysPfdFreq(clock_pfd_t pfd)
{
18005dac:	b510      	push	{r4, lr}
18005dae:	4604      	mov	r4, r0
    uint32_t freq = CLOCK_GetSysPllFreq();
18005db0:	f7ff ffce 	bl	18005d50 <CLOCK_GetSysPllFreq>

    if (((CLKCTL0->SYSPLL0CTL0) & CLKCTL0_SYSPLL0CTL0_BYPASS_MASK) == 0U)
18005db4:	4b14      	ldr	r3, [pc, #80]	; (18005e08 <CLOCK_GetSysPfdFreq+0x5c>)
18005db6:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
18005dba:	07d2      	lsls	r2, r2, #31
18005dbc:	d40f      	bmi.n	18005dde <CLOCK_GetSysPfdFreq+0x32>
    {
        switch (pfd)
18005dbe:	2c03      	cmp	r4, #3
18005dc0:	d820      	bhi.n	18005e04 <CLOCK_GetSysPfdFreq+0x58>
18005dc2:	e8df f004 	tbb	[pc, r4]
18005dc6:	0d02      	.short	0x0d02
18005dc8:	1913      	.short	0x1913
        {
            case kCLOCK_Pfd0:
                freq =
                    (uint32_t)((uint64_t)freq * 18ULL /
18005dca:	2112      	movs	r1, #18
                               ((CLKCTL0->SYSPLL0PFD & CLKCTL0_SYSPLL0PFD_PFD0_MASK) >> CLKCTL0_SYSPLL0PFD_PFD0_SHIFT));
18005dcc:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint32_t)((uint64_t)freq * 18ULL /
18005dd0:	f002 023f 	and.w	r2, r2, #63	; 0x3f
                               ((CLKCTL0->SYSPLL0PFD & CLKCTL0_SYSPLL0PFD_PFD2_MASK) >> CLKCTL0_SYSPLL0PFD_PFD2_SHIFT));
                break;

            case kCLOCK_Pfd3:
                freq =
                    (uint32_t)((uint64_t)freq * 18ULL /
18005dd4:	2300      	movs	r3, #0
18005dd6:	fba0 0101 	umull	r0, r1, r0, r1
18005dda:	f7fb faa9 	bl	18001330 <__aeabi_uldivmod>
                break;
        }
    }

    return freq;
}
18005dde:	bd10      	pop	{r4, pc}
                               ((CLKCTL0->SYSPLL0PFD & CLKCTL0_SYSPLL0PFD_PFD1_MASK) >> CLKCTL0_SYSPLL0PFD_PFD1_SHIFT));
18005de0:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint32_t)((uint64_t)freq * 18ULL /
18005de4:	2112      	movs	r1, #18
18005de6:	f3c2 2205 	ubfx	r2, r2, #8, #6
18005dea:	e7f3      	b.n	18005dd4 <CLOCK_GetSysPfdFreq+0x28>
                               ((CLKCTL0->SYSPLL0PFD & CLKCTL0_SYSPLL0PFD_PFD2_MASK) >> CLKCTL0_SYSPLL0PFD_PFD2_SHIFT));
18005dec:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint32_t)((uint64_t)freq * 18ULL /
18005df0:	2112      	movs	r1, #18
18005df2:	f3c2 4205 	ubfx	r2, r2, #16, #6
18005df6:	e7ed      	b.n	18005dd4 <CLOCK_GetSysPfdFreq+0x28>
                               ((CLKCTL0->SYSPLL0PFD & CLKCTL0_SYSPLL0PFD_PFD3_MASK) >> CLKCTL0_SYSPLL0PFD_PFD3_SHIFT));
18005df8:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint32_t)((uint64_t)freq * 18ULL /
18005dfc:	2112      	movs	r1, #18
18005dfe:	f3c2 6205 	ubfx	r2, r2, #24, #6
18005e02:	e7e7      	b.n	18005dd4 <CLOCK_GetSysPfdFreq+0x28>
        switch (pfd)
18005e04:	2000      	movs	r0, #0
    return freq;
18005e06:	e7ea      	b.n	18005dde <CLOCK_GetSysPfdFreq+0x32>
18005e08:	50001000 	.word	0x50001000

18005e0c <CLOCK_GetMainPllClkFreq>:
static uint32_t CLOCK_GetMainPllClkFreq(void)
{
18005e0c:	b508      	push	{r3, lr}
    return CLOCK_GetSysPfdFreq(kCLOCK_Pfd0) / ((CLKCTL0->MAINPLLCLKDIV & CLKCTL0_MAINPLLCLKDIV_DIV_MASK) + 1U);
18005e0e:	2000      	movs	r0, #0
18005e10:	f7ff ffcc 	bl	18005dac <CLOCK_GetSysPfdFreq>
18005e14:	4b03      	ldr	r3, [pc, #12]	; (18005e24 <CLOCK_GetMainPllClkFreq+0x18>)
18005e16:	f8d3 3240 	ldr.w	r3, [r3, #576]	; 0x240
18005e1a:	b2db      	uxtb	r3, r3
18005e1c:	3301      	adds	r3, #1
}
18005e1e:	fbb0 f0f3 	udiv	r0, r0, r3
18005e22:	bd08      	pop	{r3, pc}
18005e24:	50001000 	.word	0x50001000

18005e28 <CLOCK_GetAux0PllClkFreq>:
static uint32_t CLOCK_GetDspPllClkFreq(void)
{
    return CLOCK_GetSysPfdFreq(kCLOCK_Pfd1) / ((CLKCTL0->DSPPLLCLKDIV & CLKCTL0_DSPPLLCLKDIV_DIV_MASK) + 1U);
}
static uint32_t CLOCK_GetAux0PllClkFreq(void)
{
18005e28:	b508      	push	{r3, lr}
    return CLOCK_GetSysPfdFreq(kCLOCK_Pfd2) / ((CLKCTL0->AUX0PLLCLKDIV & CLKCTL0_AUX0PLLCLKDIV_DIV_MASK) + 1U);
18005e2a:	2002      	movs	r0, #2
18005e2c:	f7ff ffbe 	bl	18005dac <CLOCK_GetSysPfdFreq>
18005e30:	4b03      	ldr	r3, [pc, #12]	; (18005e40 <CLOCK_GetAux0PllClkFreq+0x18>)
18005e32:	f8d3 3248 	ldr.w	r3, [r3, #584]	; 0x248
18005e36:	b2db      	uxtb	r3, r3
18005e38:	3301      	adds	r3, #1
}
18005e3a:	fbb0 f0f3 	udiv	r0, r0, r3
18005e3e:	bd08      	pop	{r3, pc}
18005e40:	50001000 	.word	0x50001000

18005e44 <CLOCK_GetAux1PllClkFreq>:
static uint32_t CLOCK_GetAux1PllClkFreq(void)
{
18005e44:	b508      	push	{r3, lr}
    return CLOCK_GetSysPfdFreq(kCLOCK_Pfd3) / ((CLKCTL0->AUX1PLLCLKDIV & CLKCTL0_AUX1PLLCLKDIV_DIV_MASK) + 1U);
18005e46:	2003      	movs	r0, #3
18005e48:	f7ff ffb0 	bl	18005dac <CLOCK_GetSysPfdFreq>
18005e4c:	4b03      	ldr	r3, [pc, #12]	; (18005e5c <CLOCK_GetAux1PllClkFreq+0x18>)
18005e4e:	f8d3 324c 	ldr.w	r3, [r3, #588]	; 0x24c
18005e52:	b2db      	uxtb	r3, r3
18005e54:	3301      	adds	r3, #1
}
18005e56:	fbb0 f0f3 	udiv	r0, r0, r3
18005e5a:	bd08      	pop	{r3, pc}
18005e5c:	50001000 	.word	0x50001000

18005e60 <CLOCK_GetAudioPllFreq>:
/* Get AUDIO PLL Clk */
/*! brief  Return Frequency of AUDIO PLL
 *  return Frequency of AUDIO PLL
 */
uint32_t CLOCK_GetAudioPllFreq(void)
{
18005e60:	b510      	push	{r4, lr}
    uint32_t freq = 0U;
    uint64_t freqTmp;

    switch ((CLKCTL1->AUDIOPLL0CLKSEL) & CLKCTL1_AUDIOPLL0CLKSEL_SEL_MASK)
18005e62:	4c14      	ldr	r4, [pc, #80]	; (18005eb4 <CLOCK_GetAudioPllFreq+0x54>)
18005e64:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
18005e68:	f003 0307 	and.w	r3, r3, #7
18005e6c:	2b01      	cmp	r3, #1
18005e6e:	d019      	beq.n	18005ea4 <CLOCK_GetAudioPllFreq+0x44>
18005e70:	2b02      	cmp	r3, #2
18005e72:	d01a      	beq.n	18005eaa <CLOCK_GetAudioPllFreq+0x4a>
    {
        case CLKCTL1_AUDIOPLL0CLKSEL_SEL(0):
            freq = CLOCK_GetSFroFreq();
18005e74:	2b00      	cmp	r3, #0
18005e76:	4810      	ldr	r0, [pc, #64]	; (18005eb8 <CLOCK_GetAudioPllFreq+0x58>)
18005e78:	bf18      	it	ne
18005e7a:	2000      	movne	r0, #0
        default:
            freq = 0U;
            break;
    }

    if (((CLKCTL1->AUDIOPLL0CTL0) & CLKCTL1_AUDIOPLL0CTL0_BYPASS_MASK) == 0UL)
18005e7c:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
18005e80:	f013 0301 	ands.w	r3, r3, #1
18005e84:	d10d      	bne.n	18005ea2 <CLOCK_GetAudioPllFreq+0x42>
    {
        /* PLL output frequency = Fref * (DIV_SELECT + NUM/DENOM). */
        freqTmp = ((uint64_t)freq * ((uint64_t)(CLKCTL1->AUDIOPLL0NUM))) / ((uint64_t)(CLKCTL1->AUDIOPLL0DENOM));
18005e86:	f8d4 1210 	ldr.w	r1, [r4, #528]	; 0x210
18005e8a:	f8d4 2214 	ldr.w	r2, [r4, #532]	; 0x214
        freq *= ((CLKCTL1->AUDIOPLL0CTL0) & CLKCTL1_AUDIOPLL0CTL0_MULT_MASK) >> CLKCTL1_AUDIOPLL0CTL0_MULT_SHIFT;
18005e8e:	f8d4 4204 	ldr.w	r4, [r4, #516]	; 0x204
18005e92:	f3c4 4407 	ubfx	r4, r4, #16, #8
18005e96:	4344      	muls	r4, r0
        freqTmp = ((uint64_t)freq * ((uint64_t)(CLKCTL1->AUDIOPLL0NUM))) / ((uint64_t)(CLKCTL1->AUDIOPLL0DENOM));
18005e98:	fba0 0101 	umull	r0, r1, r0, r1
18005e9c:	f7fb fa48 	bl	18001330 <__aeabi_uldivmod>
        freq += (uint32_t)freqTmp;
18005ea0:	4420      	add	r0, r4
    }
    return freq;
}
18005ea2:	bd10      	pop	{r4, pc}
            freq = CLOCK_GetXtalInClkFreq();
18005ea4:	f7ff ff2a 	bl	18005cfc <CLOCK_GetXtalInClkFreq>
            break;
18005ea8:	e7e8      	b.n	18005e7c <CLOCK_GetAudioPllFreq+0x1c>
            freq = CLOCK_GetFFroFreq() / 2U;
18005eaa:	f7ff ff3d 	bl	18005d28 <CLOCK_GetFFroFreq>
18005eae:	0840      	lsrs	r0, r0, #1
            break;
18005eb0:	e7e4      	b.n	18005e7c <CLOCK_GetAudioPllFreq+0x1c>
18005eb2:	bf00      	nop
18005eb4:	50021000 	.word	0x50021000
18005eb8:	00f42400 	.word	0x00f42400

18005ebc <CLOCK_GetAudioPfdFreq>:
/*! brief  Get current output frequency of specific Audio PLL PFD.
 *  param   pfd    : pfd name to get frequency.
 *  return  Frequency of AUDIO PLL PFD.
 */
uint32_t CLOCK_GetAudioPfdFreq(clock_pfd_t pfd)
{
18005ebc:	b510      	push	{r4, lr}
18005ebe:	4604      	mov	r4, r0
    uint32_t freq = CLOCK_GetAudioPllFreq();
18005ec0:	f7ff ffce 	bl	18005e60 <CLOCK_GetAudioPllFreq>

    if (((CLKCTL1->AUDIOPLL0CTL0) & CLKCTL1_AUDIOPLL0CTL0_BYPASS_MASK) == 0UL)
18005ec4:	4b14      	ldr	r3, [pc, #80]	; (18005f18 <CLOCK_GetAudioPfdFreq+0x5c>)
18005ec6:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
18005eca:	07d2      	lsls	r2, r2, #31
18005ecc:	d40f      	bmi.n	18005eee <CLOCK_GetAudioPfdFreq+0x32>
    {
        switch (pfd)
18005ece:	2c03      	cmp	r4, #3
18005ed0:	d820      	bhi.n	18005f14 <CLOCK_GetAudioPfdFreq+0x58>
18005ed2:	e8df f004 	tbb	[pc, r4]
18005ed6:	0d02      	.short	0x0d02
18005ed8:	1913      	.short	0x1913
        {
            case kCLOCK_Pfd0:
                freq = (uint32_t)(
                    (uint64_t)freq * 18ULL /
18005eda:	2112      	movs	r1, #18
                    ((CLKCTL1->AUDIOPLL0PFD & CLKCTL1_AUDIOPLL0PFD_PFD0_MASK) >> CLKCTL1_AUDIOPLL0PFD_PFD0_SHIFT));
18005edc:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint64_t)freq * 18ULL /
18005ee0:	f002 023f 	and.w	r2, r2, #63	; 0x3f
                    ((CLKCTL1->AUDIOPLL0PFD & CLKCTL1_AUDIOPLL0PFD_PFD2_MASK) >> CLKCTL1_AUDIOPLL0PFD_PFD2_SHIFT));
                break;

            case kCLOCK_Pfd3:
                freq = (uint32_t)(
                    (uint64_t)freq * 18ULL /
18005ee4:	2300      	movs	r3, #0
18005ee6:	fba0 0101 	umull	r0, r1, r0, r1
18005eea:	f7fb fa21 	bl	18001330 <__aeabi_uldivmod>
                break;
        }
    }

    return freq;
}
18005eee:	bd10      	pop	{r4, pc}
                    ((CLKCTL1->AUDIOPLL0PFD & CLKCTL1_AUDIOPLL0PFD_PFD1_MASK) >> CLKCTL1_AUDIOPLL0PFD_PFD1_SHIFT));
18005ef0:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint64_t)freq * 18ULL /
18005ef4:	2112      	movs	r1, #18
18005ef6:	f3c2 2205 	ubfx	r2, r2, #8, #6
18005efa:	e7f3      	b.n	18005ee4 <CLOCK_GetAudioPfdFreq+0x28>
                    ((CLKCTL1->AUDIOPLL0PFD & CLKCTL1_AUDIOPLL0PFD_PFD2_MASK) >> CLKCTL1_AUDIOPLL0PFD_PFD2_SHIFT));
18005efc:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint64_t)freq * 18ULL /
18005f00:	2112      	movs	r1, #18
18005f02:	f3c2 4205 	ubfx	r2, r2, #16, #6
18005f06:	e7ed      	b.n	18005ee4 <CLOCK_GetAudioPfdFreq+0x28>
                    ((CLKCTL1->AUDIOPLL0PFD & CLKCTL1_AUDIOPLL0PFD_PFD3_MASK) >> CLKCTL1_AUDIOPLL0PFD_PFD3_SHIFT));
18005f08:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
                    (uint64_t)freq * 18ULL /
18005f0c:	2112      	movs	r1, #18
18005f0e:	f3c2 6205 	ubfx	r2, r2, #24, #6
18005f12:	e7e7      	b.n	18005ee4 <CLOCK_GetAudioPfdFreq+0x28>
        switch (pfd)
18005f14:	2000      	movs	r0, #0
    return freq;
18005f16:	e7ea      	b.n	18005eee <CLOCK_GetAudioPfdFreq+0x32>
18005f18:	50021000 	.word	0x50021000

18005f1c <CLOCK_GetAudioPllClkFreq>:
static uint32_t CLOCK_GetAudioPllClkFreq(void)
{
18005f1c:	b508      	push	{r3, lr}
    return CLOCK_GetAudioPfdFreq(kCLOCK_Pfd0) / ((CLKCTL1->AUDIOPLLCLKDIV & CLKCTL1_AUDIOPLLCLKDIV_DIV_MASK) + 1U);
18005f1e:	2000      	movs	r0, #0
18005f20:	f7ff ffcc 	bl	18005ebc <CLOCK_GetAudioPfdFreq>
18005f24:	4b03      	ldr	r3, [pc, #12]	; (18005f34 <CLOCK_GetAudioPllClkFreq+0x18>)
18005f26:	f8d3 3240 	ldr.w	r3, [r3, #576]	; 0x240
18005f2a:	b2db      	uxtb	r3, r3
18005f2c:	3301      	adds	r3, #1
}
18005f2e:	fbb0 f0f3 	udiv	r0, r0, r3
18005f32:	bd08      	pop	{r3, pc}
18005f34:	50021000 	.word	0x50021000

18005f38 <CLOCK_GetMainClkFreq>:
 */
uint32_t CLOCK_GetMainClkFreq(void)
{
    uint32_t freq = 0U;

    switch ((CLKCTL0->MAINCLKSELB) & CLKCTL0_MAINCLKSELB_SEL_MASK)
18005f38:	4a16      	ldr	r2, [pc, #88]	; (18005f94 <CLOCK_GetMainClkFreq+0x5c>)
{
18005f3a:	b508      	push	{r3, lr}
    switch ((CLKCTL0->MAINCLKSELB) & CLKCTL0_MAINCLKSELB_SEL_MASK)
18005f3c:	f8d2 3434 	ldr.w	r3, [r2, #1076]	; 0x434
18005f40:	f003 0303 	and.w	r3, r3, #3
18005f44:	2b02      	cmp	r3, #2
18005f46:	d019      	beq.n	18005f7c <CLOCK_GetMainClkFreq+0x44>
18005f48:	2b03      	cmp	r3, #3
18005f4a:	d01b      	beq.n	18005f84 <CLOCK_GetMainClkFreq+0x4c>
18005f4c:	2b01      	cmp	r3, #1
18005f4e:	d01d      	beq.n	18005f8c <CLOCK_GetMainClkFreq+0x54>
    {
        case CLKCTL0_MAINCLKSELB_SEL(0):
            switch ((CLKCTL0->MAINCLKSELA) & CLKCTL0_MAINCLKSELA_SEL_MASK)
18005f50:	f8d2 3430 	ldr.w	r3, [r2, #1072]	; 0x430
18005f54:	f003 0303 	and.w	r3, r3, #3
18005f58:	2b02      	cmp	r3, #2
18005f5a:	d019      	beq.n	18005f90 <CLOCK_GetMainClkFreq+0x58>
18005f5c:	2b03      	cmp	r3, #3
18005f5e:	d009      	beq.n	18005f74 <CLOCK_GetMainClkFreq+0x3c>
18005f60:	2b01      	cmp	r3, #1
18005f62:	d003      	beq.n	18005f6c <CLOCK_GetMainClkFreq+0x34>
            {
                case CLKCTL0_MAINCLKSELA_SEL(0):
                    freq = CLOCK_GetFFroFreq() / 4U;
18005f64:	f7ff fee0 	bl	18005d28 <CLOCK_GetFFroFreq>
18005f68:	0880      	lsrs	r0, r0, #2
            freq = 0U;
            break;
    }

    return freq;
}
18005f6a:	bd08      	pop	{r3, pc}
18005f6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                    freq = CLOCK_GetXtalInClkFreq();
18005f70:	f7ff bec4 	b.w	18005cfc <CLOCK_GetXtalInClkFreq>
}
18005f74:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                    freq = CLOCK_GetFFroFreq();
18005f78:	f7ff bed6 	b.w	18005d28 <CLOCK_GetFFroFreq>
}
18005f7c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetMainPllClkFreq();
18005f80:	f7ff bf44 	b.w	18005e0c <CLOCK_GetMainPllClkFreq>
}
18005f84:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = CLOCK_GetOsc32KFreq();
18005f88:	f7ff beac 	b.w	18005ce4 <CLOCK_GetOsc32KFreq>
    switch ((CLKCTL0->MAINCLKSELB) & CLKCTL0_MAINCLKSELB_SEL_MASK)
18005f8c:	4802      	ldr	r0, [pc, #8]	; (18005f98 <CLOCK_GetMainClkFreq+0x60>)
18005f8e:	e7ec      	b.n	18005f6a <CLOCK_GetMainClkFreq+0x32>
18005f90:	4802      	ldr	r0, [pc, #8]	; (18005f9c <CLOCK_GetMainClkFreq+0x64>)
    return freq;
18005f92:	e7ea      	b.n	18005f6a <CLOCK_GetMainClkFreq+0x32>
18005f94:	50001000 	.word	0x50001000
18005f98:	00f42400 	.word	0x00f42400
18005f9c:	000f4240 	.word	0x000f4240

18005fa0 <CLOCK_GetFRGClock>:
    uint32_t frgPllDiv = 1U;
    uint32_t clkSel    = 0U;
    uint32_t frgDiv    = 0U;
    uint32_t frgMul    = 0U;

    if (id <= 7UL)
18005fa0:	2807      	cmp	r0, #7
{
18005fa2:	b570      	push	{r4, r5, r6, lr}
    if (id <= 7UL)
18005fa4:	d815      	bhi.n	18005fd2 <CLOCK_GetFRGClock+0x32>
    {
        clkSel = CLKCTL1->FLEXCOMM[id].FRGCLKSEL & CLKCTL1_FRGCLKSEL_SEL_MASK;
18005fa6:	0140      	lsls	r0, r0, #5
18005fa8:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
18005fac:	f500 3004 	add.w	r0, r0, #135168	; 0x21000
18005fb0:	f8d0 3500 	ldr.w	r3, [r0, #1280]	; 0x500
        frgMul = ((CLKCTL1->FLEXCOMM[id].FRGCTL) & CLKCTL1_FRGCTL_MULT_MASK) >> CLKCTL1_FRGCTL_MULT_SHIFT;
18005fb4:	f8d0 5504 	ldr.w	r5, [r0, #1284]	; 0x504
        frgDiv = ((CLKCTL1->FLEXCOMM[id].FRGCTL) & CLKCTL1_FRGCTL_DIV_MASK) >> CLKCTL1_FRGCTL_DIV_SHIFT;
18005fb8:	f8d0 4504 	ldr.w	r4, [r0, #1284]	; 0x504
        clkSel = CLKCTL1->FLEXCOMM[id].FRGCLKSEL & CLKCTL1_FRGCLKSEL_SEL_MASK;
18005fbc:	f003 0307 	and.w	r3, r3, #7
        frgMul = ((CLKCTL1->FLEXCOMM[id].FRGCTL) & CLKCTL1_FRGCTL_MULT_MASK) >> CLKCTL1_FRGCTL_MULT_SHIFT;
18005fc0:	f3c5 2507 	ubfx	r5, r5, #8, #8
    }
    else if (id == 15UL)
    {
        clkSel = CLKCTL1->FRG15CLKSEL & CLKCTL1_FRG14CLKSEL_SEL_MASK;
        frgMul = ((CLKCTL1->FRG15CTL) & CLKCTL1_FRGCTL_MULT_MASK) >> CLKCTL1_FRGCTL_MULT_SHIFT;
        frgDiv = ((CLKCTL1->FRG15CTL) & CLKCTL1_FRGCTL_DIV_MASK) >> CLKCTL1_FRGCTL_DIV_SHIFT;
18005fc4:	b2e4      	uxtb	r4, r4
    else
    {
        assert(false);
    }

    switch (clkSel)
18005fc6:	2b03      	cmp	r3, #3
18005fc8:	d81f      	bhi.n	1800600a <CLOCK_GetFRGClock+0x6a>
18005fca:	e8df f003 	tbb	[pc, r3]
18005fce:	2d2a      	.short	0x2d2a
18005fd0:	373a      	.short	0x373a
    else if (id == 14UL)
18005fd2:	280e      	cmp	r0, #14
18005fd4:	d10b      	bne.n	18005fee <CLOCK_GetFRGClock+0x4e>
        clkSel = CLKCTL1->FRG14CLKSEL & CLKCTL1_FRG14CLKSEL_SEL_MASK;
18005fd6:	491c      	ldr	r1, [pc, #112]	; (18006048 <CLOCK_GetFRGClock+0xa8>)
18005fd8:	f8d1 36c0 	ldr.w	r3, [r1, #1728]	; 0x6c0
        frgMul = ((CLKCTL1->FRG14CTL) & CLKCTL1_FRGCTL_MULT_MASK) >> CLKCTL1_FRGCTL_MULT_SHIFT;
18005fdc:	f8d1 56c4 	ldr.w	r5, [r1, #1732]	; 0x6c4
        clkSel = CLKCTL1->FRG14CLKSEL & CLKCTL1_FRG14CLKSEL_SEL_MASK;
18005fe0:	f003 0307 	and.w	r3, r3, #7
        frgDiv = ((CLKCTL1->FRG14CTL) & CLKCTL1_FRGCTL_DIV_MASK) >> CLKCTL1_FRGCTL_DIV_SHIFT;
18005fe4:	f8d1 46c4 	ldr.w	r4, [r1, #1732]	; 0x6c4
        frgMul = ((CLKCTL1->FRG14CTL) & CLKCTL1_FRGCTL_MULT_MASK) >> CLKCTL1_FRGCTL_MULT_SHIFT;
18005fe8:	f3c5 2507 	ubfx	r5, r5, #8, #8
        frgDiv = ((CLKCTL1->FRG14CTL) & CLKCTL1_FRGCTL_DIV_MASK) >> CLKCTL1_FRGCTL_DIV_SHIFT;
18005fec:	e7ea      	b.n	18005fc4 <CLOCK_GetFRGClock+0x24>
    else if (id == 15UL)
18005fee:	280f      	cmp	r0, #15
18005ff0:	d115      	bne.n	1800601e <CLOCK_GetFRGClock+0x7e>
        clkSel = CLKCTL1->FRG15CLKSEL & CLKCTL1_FRG14CLKSEL_SEL_MASK;
18005ff2:	4915      	ldr	r1, [pc, #84]	; (18006048 <CLOCK_GetFRGClock+0xa8>)
18005ff4:	f8d1 36e0 	ldr.w	r3, [r1, #1760]	; 0x6e0
        frgMul = ((CLKCTL1->FRG15CTL) & CLKCTL1_FRGCTL_MULT_MASK) >> CLKCTL1_FRGCTL_MULT_SHIFT;
18005ff8:	f8d1 56e4 	ldr.w	r5, [r1, #1764]	; 0x6e4
        clkSel = CLKCTL1->FRG15CLKSEL & CLKCTL1_FRG14CLKSEL_SEL_MASK;
18005ffc:	f003 0307 	and.w	r3, r3, #7
        frgDiv = ((CLKCTL1->FRG15CTL) & CLKCTL1_FRGCTL_DIV_MASK) >> CLKCTL1_FRGCTL_DIV_SHIFT;
18006000:	f8d1 46e4 	ldr.w	r4, [r1, #1764]	; 0x6e4
        frgMul = ((CLKCTL1->FRG15CTL) & CLKCTL1_FRGCTL_MULT_MASK) >> CLKCTL1_FRGCTL_MULT_SHIFT;
18006004:	f3c5 2507 	ubfx	r5, r5, #8, #8
        frgDiv = ((CLKCTL1->FRG15CTL) & CLKCTL1_FRGCTL_DIV_MASK) >> CLKCTL1_FRGCTL_DIV_SHIFT;
18006008:	e7dc      	b.n	18005fc4 <CLOCK_GetFRGClock+0x24>
    switch (clkSel)
1800600a:	2000      	movs	r0, #0
        default:
            freq = 0U;
            break;
    }

    return (uint32_t)(((uint64_t)freq * ((uint64_t)frgDiv + 1ULL)) / (frgMul + frgDiv + 1UL));
1800600c:	1c61      	adds	r1, r4, #1
1800600e:	1962      	adds	r2, r4, r5
18006010:	2300      	movs	r3, #0
18006012:	3201      	adds	r2, #1
18006014:	fba1 0100 	umull	r0, r1, r1, r0
18006018:	f7fb f98a 	bl	18001330 <__aeabi_uldivmod>
}
1800601c:	bd70      	pop	{r4, r5, r6, pc}
    uint32_t frgMul    = 0U;
1800601e:	2500      	movs	r5, #0
    uint32_t frgDiv    = 0U;
18006020:	462c      	mov	r4, r5
            freq = CLOCK_GetMainClkFreq();
18006022:	f7ff ff89 	bl	18005f38 <CLOCK_GetMainClkFreq>
            break;
18006026:	e7f1      	b.n	1800600c <CLOCK_GetFRGClock+0x6c>
            frgPllDiv = (CLKCTL1->FRGPLLCLKDIV & CLKCTL1_FRGPLLCLKDIV_DIV_MASK) + 1U;
18006028:	4b07      	ldr	r3, [pc, #28]	; (18006048 <CLOCK_GetFRGClock+0xa8>)
1800602a:	f8d3 66fc 	ldr.w	r6, [r3, #1788]	; 0x6fc
            freq      = CLOCK_GetMainPllClkFreq() / frgPllDiv;
1800602e:	f7ff feed 	bl	18005e0c <CLOCK_GetMainPllClkFreq>
            frgPllDiv = (CLKCTL1->FRGPLLCLKDIV & CLKCTL1_FRGPLLCLKDIV_DIV_MASK) + 1U;
18006032:	b2f6      	uxtb	r6, r6
18006034:	1c71      	adds	r1, r6, #1
            freq      = CLOCK_GetMainPllClkFreq() / frgPllDiv;
18006036:	fbb0 f0f1 	udiv	r0, r0, r1
            break;
1800603a:	e7e7      	b.n	1800600c <CLOCK_GetFRGClock+0x6c>
            freq = CLOCK_GetFFroFreq();
1800603c:	f7ff fe74 	bl	18005d28 <CLOCK_GetFFroFreq>
            break;
18006040:	e7e4      	b.n	1800600c <CLOCK_GetFRGClock+0x6c>
            freq = CLOCK_GetSFroFreq();
18006042:	4802      	ldr	r0, [pc, #8]	; (1800604c <CLOCK_GetFRGClock+0xac>)
18006044:	e7e2      	b.n	1800600c <CLOCK_GetFRGClock+0x6c>
18006046:	bf00      	nop
18006048:	50021000 	.word	0x50021000
1800604c:	00f42400 	.word	0x00f42400

18006050 <CLOCK_GetFlexCommClkFreq>:
uint32_t CLOCK_GetFlexCommClkFreq(uint32_t id)
{
    uint32_t freq   = 0U;
    uint32_t clkSel = 0U;

    if (id <= 7UL)
18006050:	2807      	cmp	r0, #7
18006052:	d80d      	bhi.n	18006070 <CLOCK_GetFlexCommClkFreq+0x20>
    {
        clkSel = CLKCTL1->FLEXCOMM[id].FCFCLKSEL;
18006054:	0143      	lsls	r3, r0, #5
18006056:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
1800605a:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
1800605e:	f8d3 3508 	ldr.w	r3, [r3, #1288]	; 0x508
    else
    {
        assert(false);
    }

    switch (clkSel)
18006062:	2b04      	cmp	r3, #4
18006064:	d810      	bhi.n	18006088 <CLOCK_GetFlexCommClkFreq+0x38>
18006066:	e8df f003 	tbb	[pc, r3]
1800606a:	111a      	.short	0x111a
1800606c:	1513      	.short	0x1513
1800606e:	18          	.byte	0x18
1800606f:	00          	.byte	0x00
    else if (id == 14UL)
18006070:	280e      	cmp	r0, #14
18006072:	d103      	bne.n	1800607c <CLOCK_GetFlexCommClkFreq+0x2c>
        clkSel = CLKCTL1->FC14FCLKSEL;
18006074:	4b0b      	ldr	r3, [pc, #44]	; (180060a4 <CLOCK_GetFlexCommClkFreq+0x54>)
18006076:	f8d3 36c8 	ldr.w	r3, [r3, #1736]	; 0x6c8
1800607a:	e7f2      	b.n	18006062 <CLOCK_GetFlexCommClkFreq+0x12>
    else if (id == 15UL)
1800607c:	280f      	cmp	r0, #15
1800607e:	d10e      	bne.n	1800609e <CLOCK_GetFlexCommClkFreq+0x4e>
        clkSel = CLKCTL1->FC15FCLKSEL;
18006080:	4b08      	ldr	r3, [pc, #32]	; (180060a4 <CLOCK_GetFlexCommClkFreq+0x54>)
18006082:	f8d3 36e8 	ldr.w	r3, [r3, #1768]	; 0x6e8
18006086:	e7ec      	b.n	18006062 <CLOCK_GetFlexCommClkFreq+0x12>
    switch (clkSel)
18006088:	2000      	movs	r0, #0
1800608a:	4770      	bx	lr
        case CLKCTL1_FCFCLKSEL_SEL(0):
            freq = CLOCK_GetSFroFreq();
            break;

        case CLKCTL1_FCFCLKSEL_SEL(1):
            freq = CLOCK_GetFFroFreq();
1800608c:	f7ff be4c 	b.w	18005d28 <CLOCK_GetFFroFreq>
            break;

        case CLKCTL1_FCFCLKSEL_SEL(2):
            freq = CLOCK_GetAudioPllClkFreq();
18006090:	f7ff bf44 	b.w	18005f1c <CLOCK_GetAudioPllClkFreq>
    return g_mclkFreq;
18006094:	4b04      	ldr	r3, [pc, #16]	; (180060a8 <CLOCK_GetFlexCommClkFreq+0x58>)
18006096:	6818      	ldr	r0, [r3, #0]
            break;

        case CLKCTL1_FCFCLKSEL_SEL(3):
            freq = CLOCK_GetMclkInClkFreq();
            break;
18006098:	4770      	bx	lr

        case CLKCTL1_FCFCLKSEL_SEL(4):
            freq = CLOCK_GetFRGClock(id);
1800609a:	f7ff bf81 	b.w	18005fa0 <CLOCK_GetFRGClock>
            freq = CLOCK_GetSFroFreq();
1800609e:	4803      	ldr	r0, [pc, #12]	; (180060ac <CLOCK_GetFlexCommClkFreq+0x5c>)
            freq = 0U;
            break;
    }

    return freq;
}
180060a0:	4770      	bx	lr
180060a2:	bf00      	nop
180060a4:	50021000 	.word	0x50021000
180060a8:	301809ec 	.word	0x301809ec
180060ac:	00f42400 	.word	0x00f42400

180060b0 <CLOCK_GetSdioClkFreq>:
        pClkDiv = &CLKCTL0->SDIO0FCLKDIV;
    }
    else
    {
        pClkSel = &CLKCTL0->SDIO1FCLKSEL;
        pClkDiv = &CLKCTL0->SDIO1FCLKDIV;
180060b0:	4b15      	ldr	r3, [pc, #84]	; (18006108 <CLOCK_GetSdioClkFreq+0x58>)
180060b2:	4a16      	ldr	r2, [pc, #88]	; (1800610c <CLOCK_GetSdioClkFreq+0x5c>)
180060b4:	2800      	cmp	r0, #0
{
180060b6:	b510      	push	{r4, lr}
        pClkDiv = &CLKCTL0->SDIO1FCLKDIV;
180060b8:	4c15      	ldr	r4, [pc, #84]	; (18006110 <CLOCK_GetSdioClkFreq+0x60>)
180060ba:	bf18      	it	ne
180060bc:	461c      	movne	r4, r3
180060be:	f1a3 0314 	sub.w	r3, r3, #20
180060c2:	bf18      	it	ne
180060c4:	4613      	movne	r3, r2
    }

    switch ((*pClkSel) & CLKCTL0_SDIO0FCLKSEL_SEL_MASK)
180060c6:	681b      	ldr	r3, [r3, #0]
180060c8:	f003 0307 	and.w	r3, r3, #7
180060cc:	2b04      	cmp	r3, #4
180060ce:	d818      	bhi.n	18006102 <CLOCK_GetSdioClkFreq+0x52>
180060d0:	e8df f003 	tbb	[pc, r3]
180060d4:	110e0b03 	.word	0x110e0b03
180060d8:	14          	.byte	0x14
180060d9:	00          	.byte	0x00
    {
        case CLKCTL0_SDIO0FCLKSEL_SEL(0):
            freq = CLOCK_GetMainClkFreq();
180060da:	f7ff ff2d 	bl	18005f38 <CLOCK_GetMainClkFreq>
        default:
            freq = 0U;
            break;
    }

    return freq / (((*pClkDiv) & CLKCTL0_SDIO0FCLKDIV_DIV_MASK) + 1U);
180060de:	6823      	ldr	r3, [r4, #0]
180060e0:	b2db      	uxtb	r3, r3
180060e2:	3301      	adds	r3, #1
}
180060e4:	fbb0 f0f3 	udiv	r0, r0, r3
180060e8:	bd10      	pop	{r4, pc}
            freq = CLOCK_GetMainPllClkFreq();
180060ea:	f7ff fe8f 	bl	18005e0c <CLOCK_GetMainPllClkFreq>
            break;
180060ee:	e7f6      	b.n	180060de <CLOCK_GetSdioClkFreq+0x2e>
            freq = CLOCK_GetAux0PllClkFreq();
180060f0:	f7ff fe9a 	bl	18005e28 <CLOCK_GetAux0PllClkFreq>
            break;
180060f4:	e7f3      	b.n	180060de <CLOCK_GetSdioClkFreq+0x2e>
            freq = CLOCK_GetFFroFreq();
180060f6:	f7ff fe17 	bl	18005d28 <CLOCK_GetFFroFreq>
            break;
180060fa:	e7f0      	b.n	180060de <CLOCK_GetSdioClkFreq+0x2e>
            freq = CLOCK_GetAux1PllClkFreq();
180060fc:	f7ff fea2 	bl	18005e44 <CLOCK_GetAux1PllClkFreq>
            break;
18006100:	e7ed      	b.n	180060de <CLOCK_GetSdioClkFreq+0x2e>
    switch ((*pClkSel) & CLKCTL0_SDIO0FCLKSEL_SEL_MASK)
18006102:	2000      	movs	r0, #0
18006104:	e7eb      	b.n	180060de <CLOCK_GetSdioClkFreq+0x2e>
18006106:	bf00      	nop
18006108:	50001694 	.word	0x50001694
1800610c:	50001690 	.word	0x50001690
18006110:	50001684 	.word	0x50001684

18006114 <CLOCK_EnableFfroClk>:
 * param  ffroFreq : target fro frequency.
 * return Nothing
 */
void CLOCK_EnableFfroClk(clock_ffro_freq_t ffroFreq)
{
    uint32_t tempco     = 0U;
18006114:	2300      	movs	r3, #0
{
18006116:	b530      	push	{r4, r5, lr}
18006118:	b085      	sub	sp, #20
    uint32_t coarse     = 0U;
1800611a:	e9cd 3300 	strd	r3, r3, [sp]
    uint32_t fine       = 0U;
    uint32_t ffro_delay = 0U;
1800611e:	e9cd 3302 	strd	r3, r3, [sp, #8]

    assert(((SYSCTL0->PDRUNCFG0 & SYSCTL0_PDRUNCFG0_FFRO_PD_MASK) == 0UL) &&
           ((SYSCTL0->PDRUNCFG1 & SYSCTL0_PDRUNCFG1_ROM_PD_MASK) == 0UL));

    /* FFROCTL0, FFROCTL1 and the otp trim value should not be touched by application */
    CLKCTL0->FFROCTL1 |= CLKCTL0_FFROCTL1_UPDATE_MASK;
18006122:	4c27      	ldr	r4, [pc, #156]	; (180061c0 <CLOCK_EnableFfroClk+0xac>)
{
18006124:	4605      	mov	r5, r0
    CLKCTL0->FFROCTL1 |= CLKCTL0_FFROCTL1_UPDATE_MASK;
18006126:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
1800612a:	f043 0301 	orr.w	r3, r3, #1
1800612e:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    OTP_INIT_API(CLOCK_GetMainClkFreq() / ((CLKCTL0->SYSCPUAHBCLKDIV & CLKCTL0_SYSCPUAHBCLKDIV_DIV_MASK) + 1U));
18006132:	f7ff ff01 	bl	18005f38 <CLOCK_GetMainClkFreq>
18006136:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
1800613a:	4c22      	ldr	r4, [pc, #136]	; (180061c4 <CLOCK_EnableFfroClk+0xb0>)
1800613c:	b2db      	uxtb	r3, r3
1800613e:	3301      	adds	r3, #1
18006140:	fbb0 f0f3 	udiv	r0, r0, r3
18006144:	4b20      	ldr	r3, [pc, #128]	; (180061c8 <CLOCK_EnableFfroClk+0xb4>)
18006146:	4798      	blx	r3
    if (ffroFreq == kCLOCK_Ffro48M)
    {
        /* Read 48M FFRO clock Trim settings from fuse. */
        OTP_FUSE_READ_API(FIRC_48MHZ_TRIM_TEMPCO, &tempco);
18006148:	4669      	mov	r1, sp
    if (ffroFreq == kCLOCK_Ffro48M)
1800614a:	2d00      	cmp	r5, #0
1800614c:	d12f      	bne.n	180061ae <CLOCK_EnableFfroClk+0x9a>
        OTP_FUSE_READ_API(FIRC_48MHZ_TRIM_TEMPCO, &tempco);
1800614e:	2030      	movs	r0, #48	; 0x30
18006150:	47a0      	blx	r4
        OTP_FUSE_READ_API(FIRC_48MHZ_TRIM_COARSE, &coarse);
18006152:	2031      	movs	r0, #49	; 0x31
18006154:	a901      	add	r1, sp, #4
18006156:	47a0      	blx	r4
        OTP_FUSE_READ_API(FIRC_48MHZ_TRIM_FINE, &fine);
18006158:	2032      	movs	r0, #50	; 0x32
1800615a:	a902      	add	r1, sp, #8
    else
    {
        /* Read 60M FFRO clock Trim settings from fuse. */
        OTP_FUSE_READ_API(FIRC_60MHZ_TRIM_TEMPCO, &tempco);
        OTP_FUSE_READ_API(FIRC_60MHZ_TRIM_COARSE, &coarse);
        OTP_FUSE_READ_API(FIRC_60MHZ_TRIM_FINE, &fine);
1800615c:	47a0      	blx	r4
    }
    /* Read FFRO stable time from fuse. */
    OTP_FUSE_READ_API(FFRO_STABLE_TIME, &ffro_delay);
1800615e:	a903      	add	r1, sp, #12
18006160:	200c      	movs	r0, #12
18006162:	47a0      	blx	r4
    OTP_DEINIT_API();
18006164:	4b19      	ldr	r3, [pc, #100]	; (180061cc <CLOCK_EnableFfroClk+0xb8>)
18006166:	4798      	blx	r3
    CLKCTL0->FFROCTL0 = CLKCTL0_FFROCTL0_TRIM_TEMPCO(tempco) | CLKCTL0_FFROCTL0_TRIM_COARSE(coarse) |
18006168:	9b01      	ldr	r3, [sp, #4]
                        CLKCTL0_FFROCTL0_TRIM_FINE(fine) |
1800616a:	9a02      	ldr	r2, [sp, #8]
    CLKCTL0->FFROCTL0 = CLKCTL0_FFROCTL0_TRIM_TEMPCO(tempco) | CLKCTL0_FFROCTL0_TRIM_COARSE(coarse) |
1800616c:	015b      	lsls	r3, r3, #5
                        CLKCTL0_FFROCTL0_TRIM_FINE(fine) |
1800616e:	02d2      	lsls	r2, r2, #11
18006170:	f402 327e 	and.w	r2, r2, #260096	; 0x3f800
    CLKCTL0->FFROCTL0 = CLKCTL0_FFROCTL0_TRIM_TEMPCO(tempco) | CLKCTL0_FFROCTL0_TRIM_COARSE(coarse) |
18006174:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
18006178:	4313      	orrs	r3, r2
1800617a:	9a00      	ldr	r2, [sp, #0]
                        CLKCTL0_FFROCTL0_TRIM_RANGE((ffroFreq == kCLOCK_Ffro48M) ? 0 : 3);
1800617c:	2d00      	cmp	r5, #0
    CLKCTL0->FFROCTL0 = CLKCTL0_FFROCTL0_TRIM_TEMPCO(tempco) | CLKCTL0_FFROCTL0_TRIM_COARSE(coarse) |
1800617e:	f002 021f 	and.w	r2, r2, #31
18006182:	ea43 0302 	orr.w	r3, r3, r2
                        CLKCTL0_FFROCTL0_TRIM_RANGE((ffroFreq == kCLOCK_Ffro48M) ? 0 : 3);
18006186:	bf0c      	ite	eq
18006188:	2200      	moveq	r2, #0
1800618a:	f44f 2240 	movne.w	r2, #786432	; 0xc0000
                        CLKCTL0_FFROCTL0_TRIM_FINE(fine) |
1800618e:	4313      	orrs	r3, r2
    CLKCTL0->FFROCTL0 = CLKCTL0_FFROCTL0_TRIM_TEMPCO(tempco) | CLKCTL0_FFROCTL0_TRIM_COARSE(coarse) |
18006190:	4a0b      	ldr	r2, [pc, #44]	; (180061c0 <CLOCK_EnableFfroClk+0xac>)
    CLKCTL0->FFROCTL1 &= ~CLKCTL0_FFROCTL1_UPDATE_MASK;
    /* No FFRO enable/disable control in CLKCTL. Just wait FFRO stable in case FFRO just get powered on. */
    SDK_DelayAtLeastUs(ffro_delay, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
18006192:	490f      	ldr	r1, [pc, #60]	; (180061d0 <CLOCK_EnableFfroClk+0xbc>)
    CLKCTL0->FFROCTL0 = CLKCTL0_FFROCTL0_TRIM_TEMPCO(tempco) | CLKCTL0_FFROCTL0_TRIM_COARSE(coarse) |
18006194:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    CLKCTL0->FFROCTL1 &= ~CLKCTL0_FFROCTL1_UPDATE_MASK;
18006198:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
1800619c:	f023 0301 	bic.w	r3, r3, #1
180061a0:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
    SDK_DelayAtLeastUs(ffro_delay, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
180061a4:	9803      	ldr	r0, [sp, #12]
180061a6:	f000 f989 	bl	180064bc <SDK_DelayAtLeastUs>
}
180061aa:	b005      	add	sp, #20
180061ac:	bd30      	pop	{r4, r5, pc}
        OTP_FUSE_READ_API(FIRC_60MHZ_TRIM_TEMPCO, &tempco);
180061ae:	2033      	movs	r0, #51	; 0x33
180061b0:	47a0      	blx	r4
        OTP_FUSE_READ_API(FIRC_60MHZ_TRIM_COARSE, &coarse);
180061b2:	2034      	movs	r0, #52	; 0x34
180061b4:	a901      	add	r1, sp, #4
180061b6:	47a0      	blx	r4
        OTP_FUSE_READ_API(FIRC_60MHZ_TRIM_FINE, &fine);
180061b8:	2035      	movs	r0, #53	; 0x35
180061ba:	a902      	add	r1, sp, #8
180061bc:	e7ce      	b.n	1800615c <CLOCK_EnableFfroClk+0x48>
180061be:	bf00      	nop
180061c0:	50001000 	.word	0x50001000
180061c4:	1300a057 	.word	0x1300a057
180061c8:	13009ff9 	.word	0x13009ff9
180061cc:	1300a047 	.word	0x1300a047
180061d0:	11e1a300 	.word	0x11e1a300

180061d4 <CLOCK_EnableSfroClk>:
 * return  Nothing
 */

void CLOCK_EnableSfroClk(void)
{
    uint32_t sfro_delay = 0U;
180061d4:	2300      	movs	r3, #0
{
180061d6:	b513      	push	{r0, r1, r4, lr}
    uint32_t sfro_delay = 0U;
180061d8:	9301      	str	r3, [sp, #4]

    assert(((SYSCTL0->PDRUNCFG0 & SYSCTL0_PDRUNCFG0_SFRO_PD_MASK) == 0UL) &&
           ((SYSCTL0->PDRUNCFG1 & SYSCTL0_PDRUNCFG1_ROM_PD_MASK) == 0UL));
    /* The otp trim value should not be touched by application */
    OTP_INIT_API(CLOCK_GetMainClkFreq() / ((CLKCTL0->SYSCPUAHBCLKDIV & CLKCTL0_SYSCPUAHBCLKDIV_DIV_MASK) + 1U));
180061da:	f7ff fead 	bl	18005f38 <CLOCK_GetMainClkFreq>
180061de:	4b0b      	ldr	r3, [pc, #44]	; (1800620c <CLOCK_EnableSfroClk+0x38>)
    /* Read SFRO stable time from fuse. */
    OTP_FUSE_READ_API(SFRO_STABLE_TIME, &sfro_delay);
180061e0:	4c0b      	ldr	r4, [pc, #44]	; (18006210 <CLOCK_EnableSfroClk+0x3c>)
    OTP_INIT_API(CLOCK_GetMainClkFreq() / ((CLKCTL0->SYSCPUAHBCLKDIV & CLKCTL0_SYSCPUAHBCLKDIV_DIV_MASK) + 1U));
180061e2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
180061e6:	b2db      	uxtb	r3, r3
180061e8:	3301      	adds	r3, #1
180061ea:	fbb0 f0f3 	udiv	r0, r0, r3
180061ee:	4b09      	ldr	r3, [pc, #36]	; (18006214 <CLOCK_EnableSfroClk+0x40>)
180061f0:	4798      	blx	r3
    OTP_FUSE_READ_API(SFRO_STABLE_TIME, &sfro_delay);
180061f2:	f104 0357 	add.w	r3, r4, #87	; 0x57
180061f6:	a901      	add	r1, sp, #4
180061f8:	200d      	movs	r0, #13
    OTP_DEINIT_API();
180061fa:	3447      	adds	r4, #71	; 0x47
    OTP_FUSE_READ_API(SFRO_STABLE_TIME, &sfro_delay);
180061fc:	4798      	blx	r3
    OTP_DEINIT_API();
180061fe:	47a0      	blx	r4
    /* No SFRO enable/disable control in CLKCTL. Just wait SFRO stable in case SFRO just get powered on. */
    SDK_DelayAtLeastUs(sfro_delay, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
18006200:	4905      	ldr	r1, [pc, #20]	; (18006218 <CLOCK_EnableSfroClk+0x44>)
18006202:	9801      	ldr	r0, [sp, #4]
18006204:	f000 f95a 	bl	180064bc <SDK_DelayAtLeastUs>
}
18006208:	b002      	add	sp, #8
1800620a:	bd10      	pop	{r4, pc}
1800620c:	50001000 	.word	0x50001000
18006210:	1300a000 	.word	0x1300a000
18006214:	13009ff9 	.word	0x13009ff9
18006218:	11e1a300 	.word	0x11e1a300

1800621c <CLOCK_InitSysPll>:
 *  param  config    : Configuration to set to PLL.
 */
void CLOCK_InitSysPll(const clock_sys_pll_config_t *config)
{
    /* Power down SYSPLL before change fractional settings */
    SYSCTL0->PDRUNCFG0_SET = SYSCTL0_PDRUNCFG0_SYSPLLLDO_PD_MASK | SYSCTL0_PDRUNCFG0_SYSPLLANA_PD_MASK;
1800621c:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
{
18006220:	b510      	push	{r4, lr}
    SYSCTL0->PDRUNCFG0_SET = SYSCTL0_PDRUNCFG0_SYSPLLLDO_PD_MASK | SYSCTL0_PDRUNCFG0_SYSPLLANA_PD_MASK;
18006222:	4b3d      	ldr	r3, [pc, #244]	; (18006318 <CLOCK_InitSysPll+0xfc>)

    CLKCTL0->SYSPLL0CLKSEL = (uint32_t)config->sys_pll_src;
18006224:	4c3d      	ldr	r4, [pc, #244]	; (1800631c <CLOCK_InitSysPll+0x100>)
    SYSCTL0->PDRUNCFG0_SET = SYSCTL0_PDRUNCFG0_SYSPLLLDO_PD_MASK | SYSCTL0_PDRUNCFG0_SYSPLLANA_PD_MASK;
18006226:	f8c3 2620 	str.w	r2, [r3, #1568]	; 0x620
    CLKCTL0->SYSPLL0CLKSEL = (uint32_t)config->sys_pll_src;
1800622a:	7803      	ldrb	r3, [r0, #0]
1800622c:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
    CLKCTL0->SYSPLL0NUM    = config->numerator;
18006230:	6843      	ldr	r3, [r0, #4]
18006232:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
    CLKCTL0->SYSPLL0DENOM  = config->denominator;
18006236:	6883      	ldr	r3, [r0, #8]
18006238:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214
    switch (config->sys_pll_mult)
1800623c:	7b03      	ldrb	r3, [r0, #12]
1800623e:	2b06      	cmp	r3, #6
18006240:	d80d      	bhi.n	1800625e <CLOCK_InitSysPll+0x42>
18006242:	e8df f003 	tbb	[pc, r3]
18006246:	3e04      	.short	0x3e04
18006248:	5a534c45 	.word	0x5a534c45
1800624c:	61          	.byte	0x61
1800624d:	00          	.byte	0x00
    {
        case kCLOCK_SysPllMult16:
            CLKCTL0->SYSPLL0CTL0 =
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(16);
1800624e:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
18006252:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
18006256:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
        case kCLOCK_SysPllMult21:
            CLKCTL0->SYSPLL0CTL0 =
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(21);
            break;
        case kCLOCK_SysPllMult22:
            CLKCTL0->SYSPLL0CTL0 =
1800625a:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
            break;
    }
    /* Clear System PLL reset*/
    CLKCTL0->SYSPLL0CTL0 &= ~CLKCTL0_SYSPLL0CTL0_RESET_MASK;
    /* Power up SYSPLL*/
    SYSCTL0->PDRUNCFG0_CLR = SYSCTL0_PDRUNCFG0_SYSPLLLDO_PD_MASK | SYSCTL0_PDRUNCFG0_SYSPLLANA_PD_MASK;
1800625e:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
    CLKCTL0->SYSPLL0CTL0 &= ~CLKCTL0_SYSPLL0CTL0_RESET_MASK;
18006262:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 2UL,
18006266:	492e      	ldr	r1, [pc, #184]	; (18006320 <CLOCK_InitSysPll+0x104>)
    CLKCTL0->SYSPLL0CTL0 &= ~CLKCTL0_SYSPLL0CTL0_RESET_MASK;
18006268:	f023 0302 	bic.w	r3, r3, #2
1800626c:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
    SYSCTL0->PDRUNCFG0_CLR = SYSCTL0_PDRUNCFG0_SYSPLLLDO_PD_MASK | SYSCTL0_PDRUNCFG0_SYSPLLANA_PD_MASK;
18006270:	4b29      	ldr	r3, [pc, #164]	; (18006318 <CLOCK_InitSysPll+0xfc>)
18006272:	f8c3 2630 	str.w	r2, [r3, #1584]	; 0x630
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 2UL,
18006276:	f8d4 020c 	ldr.w	r0, [r4, #524]	; 0x20c
1800627a:	f3c0 004e 	ubfx	r0, r0, #1, #15
1800627e:	f000 f91d 	bl	180064bc <SDK_DelayAtLeastUs>
                       SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
    /* Set System PLL HOLDRINGOFF_ENA */
    CLKCTL0->SYSPLL0CTL0 |= CLKCTL0_SYSPLL0CTL0_HOLDRINGOFF_ENA_MASK;
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 6UL,
18006282:	2006      	movs	r0, #6
    CLKCTL0->SYSPLL0CTL0 |= CLKCTL0_SYSPLL0CTL0_HOLDRINGOFF_ENA_MASK;
18006284:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 6UL,
18006288:	4925      	ldr	r1, [pc, #148]	; (18006320 <CLOCK_InitSysPll+0x104>)
    CLKCTL0->SYSPLL0CTL0 |= CLKCTL0_SYSPLL0CTL0_HOLDRINGOFF_ENA_MASK;
1800628a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
1800628e:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 6UL,
18006292:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
18006296:	b29b      	uxth	r3, r3
18006298:	fbb3 f0f0 	udiv	r0, r3, r0
1800629c:	f000 f90e 	bl	180064bc <SDK_DelayAtLeastUs>
                       SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
    /* Clear System PLL HOLDRINGOFF_ENA*/
    CLKCTL0->SYSPLL0CTL0 &= ~CLKCTL0_SYSPLL0CTL0_HOLDRINGOFF_ENA_MASK;
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 3UL,
180062a0:	2003      	movs	r0, #3
    CLKCTL0->SYSPLL0CTL0 &= ~CLKCTL0_SYSPLL0CTL0_HOLDRINGOFF_ENA_MASK;
180062a2:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 3UL,
180062a6:	491e      	ldr	r1, [pc, #120]	; (18006320 <CLOCK_InitSysPll+0x104>)
    CLKCTL0->SYSPLL0CTL0 &= ~CLKCTL0_SYSPLL0CTL0_HOLDRINGOFF_ENA_MASK;
180062a8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
180062ac:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 3UL,
180062b0:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
                       SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
}
180062b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SDK_DelayAtLeastUs((CLKCTL0->SYSPLL0LOCKTIMEDIV2 & CLKCTL0_SYSPLL0LOCKTIMEDIV2_LOCKTIMEDIV2_MASK) / 3UL,
180062b8:	b29b      	uxth	r3, r3
180062ba:	fbb3 f0f0 	udiv	r0, r3, r0
180062be:	f000 b8fd 	b.w	180064bc <SDK_DelayAtLeastUs>
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(17);
180062c2:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
180062c6:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
180062ca:	f443 1388 	orr.w	r3, r3, #1114112	; 0x110000
180062ce:	e7c4      	b.n	1800625a <CLOCK_InitSysPll+0x3e>
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(18);
180062d0:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
180062d4:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
180062d8:	f443 1390 	orr.w	r3, r3, #1179648	; 0x120000
180062dc:	e7bd      	b.n	1800625a <CLOCK_InitSysPll+0x3e>
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(19);
180062de:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
180062e2:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
180062e6:	f443 1398 	orr.w	r3, r3, #1245184	; 0x130000
180062ea:	e7b6      	b.n	1800625a <CLOCK_InitSysPll+0x3e>
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(20);
180062ec:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
180062f0:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
180062f4:	f443 13a0 	orr.w	r3, r3, #1310720	; 0x140000
180062f8:	e7af      	b.n	1800625a <CLOCK_InitSysPll+0x3e>
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(21);
180062fa:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
180062fe:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
18006302:	f443 13a8 	orr.w	r3, r3, #1376256	; 0x150000
18006306:	e7a8      	b.n	1800625a <CLOCK_InitSysPll+0x3e>
                (CLKCTL0->SYSPLL0CTL0 & ~CLKCTL0_SYSPLL0CTL0_MULT_MASK) | CLKCTL0_SYSPLL0CTL0_MULT(22);
18006308:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
1800630c:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
18006310:	f443 13b0 	orr.w	r3, r3, #1441792	; 0x160000
18006314:	e7a1      	b.n	1800625a <CLOCK_InitSysPll+0x3e>
18006316:	bf00      	nop
18006318:	50002000 	.word	0x50002000
1800631c:	50001000 	.word	0x50001000
18006320:	11e1a300 	.word	0x11e1a300

18006324 <CLOCK_InitSysPfd>:
    uint32_t pfdIndex = (uint32_t)pfd;
    uint32_t syspfd;

    syspfd = CLKCTL0->SYSPLL0PFD &
             ~(((uint32_t)CLKCTL0_SYSPLL0PFD_PFD0_CLKGATE_MASK | (uint32_t)CLKCTL0_SYSPLL0PFD_PFD0_MASK)
               << (8UL * pfdIndex));
18006324:	00c2      	lsls	r2, r0, #3
18006326:	20bf      	movs	r0, #191	; 0xbf
    syspfd = CLKCTL0->SYSPLL0PFD &
18006328:	4b0e      	ldr	r3, [pc, #56]	; (18006364 <CLOCK_InitSysPfd+0x40>)
{
1800632a:	b510      	push	{r4, lr}
    syspfd = CLKCTL0->SYSPLL0PFD &
1800632c:	f8d3 4218 	ldr.w	r4, [r3, #536]	; 0x218
               << (8UL * pfdIndex));
18006330:	4090      	lsls	r0, r2
    syspfd = CLKCTL0->SYSPLL0PFD &
18006332:	ea24 0400 	bic.w	r4, r4, r0

    /* Disable the clock output first. */
    CLKCTL0->SYSPLL0PFD = syspfd | ((uint32_t)CLKCTL0_SYSPLL0PFD_PFD0_CLKGATE_MASK << (8UL * pfdIndex));
18006336:	2080      	movs	r0, #128	; 0x80
18006338:	4090      	lsls	r0, r2
1800633a:	4320      	orrs	r0, r4
1800633c:	f8c3 0218 	str.w	r0, [r3, #536]	; 0x218

    /* Set the new value and enable output. */
    CLKCTL0->SYSPLL0PFD = syspfd | (CLKCTL0_SYSPLL0PFD_PFD0(divider) << (8UL * pfdIndex));
    /* Wait for output becomes stable. */
    while ((CLKCTL0->SYSPLL0PFD & ((uint32_t)CLKCTL0_SYSPLL0PFD_PFD0_CLKRDY_MASK << (8UL * pfdIndex))) == 0UL)
18006340:	2040      	movs	r0, #64	; 0x40
    CLKCTL0->SYSPLL0PFD = syspfd | (CLKCTL0_SYSPLL0PFD_PFD0(divider) << (8UL * pfdIndex));
18006342:	f001 013f 	and.w	r1, r1, #63	; 0x3f
18006346:	4091      	lsls	r1, r2
18006348:	4321      	orrs	r1, r4
1800634a:	f8c3 1218 	str.w	r1, [r3, #536]	; 0x218
    while ((CLKCTL0->SYSPLL0PFD & ((uint32_t)CLKCTL0_SYSPLL0PFD_PFD0_CLKRDY_MASK << (8UL * pfdIndex))) == 0UL)
1800634e:	4090      	lsls	r0, r2
18006350:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
18006354:	4202      	tst	r2, r0
18006356:	d0fb      	beq.n	18006350 <CLOCK_InitSysPfd+0x2c>
    {
    }
    /* Clear ready status flag. */
    CLKCTL0->SYSPLL0PFD |= ((uint32_t)CLKCTL0_SYSPLL0PFD_PFD0_CLKRDY_MASK << (8UL * pfdIndex));
18006358:	f8d3 2218 	ldr.w	r2, [r3, #536]	; 0x218
1800635c:	4310      	orrs	r0, r2
1800635e:	f8c3 0218 	str.w	r0, [r3, #536]	; 0x218
}
18006362:	bd10      	pop	{r4, pc}
18006364:	50001000 	.word	0x50001000

18006368 <CLOCK_EnableSysOscClk>:
 */
void CLOCK_EnableSysOscClk(bool enable, bool enableLowPower, uint32_t delay_us)
{
    uint32_t ctrl = enableLowPower ? CLKCTL0_SYSOSCCTL0_LP_ENABLE_MASK : 0U;

    if (enable)
18006368:	4b07      	ldr	r3, [pc, #28]	; (18006388 <CLOCK_EnableSysOscClk+0x20>)
1800636a:	b140      	cbz	r0, 1800637e <CLOCK_EnableSysOscClk+0x16>
    {
        CLKCTL0->SYSOSCCTL0   = ctrl;
1800636c:	f8c3 1160 	str.w	r1, [r3, #352]	; 0x160
        CLKCTL0->SYSOSCBYPASS = 0;
18006370:	2100      	movs	r1, #0
        SDK_DelayAtLeastUs(delay_us, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
18006372:	4610      	mov	r0, r2
        CLKCTL0->SYSOSCBYPASS = 0;
18006374:	f8c3 1168 	str.w	r1, [r3, #360]	; 0x168
        SDK_DelayAtLeastUs(delay_us, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
18006378:	4904      	ldr	r1, [pc, #16]	; (1800638c <CLOCK_EnableSysOscClk+0x24>)
1800637a:	f000 b89f 	b.w	180064bc <SDK_DelayAtLeastUs>
    }
    else
    {
        CLKCTL0->SYSOSCCTL0 = ctrl | CLKCTL0_SYSOSCCTL0_BYPASS_ENABLE_MASK;
1800637e:	f041 0102 	orr.w	r1, r1, #2
18006382:	f8c3 1160 	str.w	r1, [r3, #352]	; 0x160
    }
}
18006386:	4770      	bx	lr
18006388:	50001000 	.word	0x50001000
1800638c:	11e1a300 	.word	0x11e1a300

18006390 <POWER_UpdateOscSettlingTime>:
 * @brief  API to update XTAL oscillator settling time .
 * @param  osc_delay : OSC stabilization time in unit of microsecond
 */
void POWER_UpdateOscSettlingTime(uint32_t osc_delay)
{
    oscSettlingTime = osc_delay;
18006390:	4b01      	ldr	r3, [pc, #4]	; (18006398 <POWER_UpdateOscSettlingTime+0x8>)
18006392:	6018      	str	r0, [r3, #0]
}
18006394:	4770      	bx	lr
18006396:	bf00      	nop
18006398:	301809f4 	.word	0x301809f4

1800639c <EnableDeepSleepIRQ>:

void EnableDeepSleepIRQ(IRQn_Type interrupt)
{
    uint32_t intNumber = (uint32_t)interrupt;

    if (intNumber >= 32U)
1800639c:	2301      	movs	r3, #1
1800639e:	281f      	cmp	r0, #31
180063a0:	4a0b      	ldr	r2, [pc, #44]	; (180063d0 <EnableDeepSleepIRQ+0x34>)
    {
        /* enable interrupt wake up in the STARTEN1 register */
        SYSCTL0->STARTEN1_SET = 1UL << (intNumber - 32U);
180063a2:	bf85      	ittet	hi
180063a4:	f1a0 0120 	subhi.w	r1, r0, #32
180063a8:	408b      	lslhi	r3, r1
    }
    else
    {
        /* enable interrupt wake up in the STARTEN0 register */
        SYSCTL0->STARTEN0_SET = 1UL << intNumber;
180063aa:	4083      	lslls	r3, r0
        SYSCTL0->STARTEN1_SET = 1UL << (intNumber - 32U);
180063ac:	f8c2 36a4 	strhi.w	r3, [r2, #1700]	; 0x6a4
        SYSCTL0->STARTEN0_SET = 1UL << intNumber;
180063b0:	bf98      	it	ls
180063b2:	f8c2 36a0 	strls.w	r3, [r2, #1696]	; 0x6a0
  if ((int32_t)(IRQn) >= 0)
180063b6:	2800      	cmp	r0, #0
180063b8:	db08      	blt.n	180063cc <EnableDeepSleepIRQ+0x30>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
180063ba:	2301      	movs	r3, #1
180063bc:	0942      	lsrs	r2, r0, #5
180063be:	f000 001f 	and.w	r0, r0, #31
180063c2:	fa03 f000 	lsl.w	r0, r3, r0
180063c6:	4b03      	ldr	r3, [pc, #12]	; (180063d4 <EnableDeepSleepIRQ+0x38>)
180063c8:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
    }
    /* also enable interrupt at NVIC */
    (void)EnableIRQ(interrupt);
}
180063cc:	4770      	bx	lr
180063ce:	bf00      	nop
180063d0:	50002000 	.word	0x50002000
180063d4:	e000e100 	.word	0xe000e100

180063d8 <RESET_SetPeripheralReset>:
 */
void RESET_SetPeripheralReset(reset_ip_name_t peripheral)
{
    const uint32_t regIndex = ((uint32_t)peripheral & 0x0000FF00u) >> 8;
    const uint32_t bitPos   = ((uint32_t)peripheral & 0x000000FFu);
    const uint32_t bitMask  = 1UL << bitPos;
180063d8:	2201      	movs	r2, #1
    const uint32_t bitPos   = ((uint32_t)peripheral & 0x000000FFu);
180063da:	b2c3      	uxtb	r3, r0

    assert(bitPos < 32u);

    switch (regIndex)
180063dc:	0a00      	lsrs	r0, r0, #8
    const uint32_t bitMask  = 1UL << bitPos;
180063de:	fa02 f303 	lsl.w	r3, r2, r3
    switch (regIndex)
180063e2:	2805      	cmp	r0, #5
180063e4:	d82a      	bhi.n	1800643c <RESET_SetPeripheralReset+0x64>
180063e6:	e8df f000 	tbb	[pc, r0]
180063ea:	0a03      	.short	0x0a03
180063ec:	241e1811 	.word	0x241e1811
    {
        case RST_CTL0_PSCCTL0:
            RSTCTL0->PRSTCTL0_SET = bitMask;
180063f0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
180063f4:	6413      	str	r3, [r2, #64]	; 0x40
            while (0u == (RSTCTL0->PRSTCTL0 & bitMask))
180063f6:	6911      	ldr	r1, [r2, #16]
180063f8:	4219      	tst	r1, r3
180063fa:	d0fc      	beq.n	180063f6 <RESET_SetPeripheralReset+0x1e>
180063fc:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL0_PSCCTL1:
            RSTCTL0->PRSTCTL1_SET = bitMask;
180063fe:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
18006402:	6453      	str	r3, [r2, #68]	; 0x44
            while (0u == (RSTCTL0->PRSTCTL1 & bitMask))
18006404:	6951      	ldr	r1, [r2, #20]
18006406:	4219      	tst	r1, r3
18006408:	d0fc      	beq.n	18006404 <RESET_SetPeripheralReset+0x2c>
1800640a:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL0_PSCCTL2:
            RSTCTL0->PRSTCTL2_SET = bitMask;
1800640c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
18006410:	6493      	str	r3, [r2, #72]	; 0x48
            while (0u == (RSTCTL0->PRSTCTL2 & bitMask))
18006412:	6991      	ldr	r1, [r2, #24]
18006414:	4219      	tst	r1, r3
18006416:	d0fc      	beq.n	18006412 <RESET_SetPeripheralReset+0x3a>
18006418:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL1_PSCCTL0:
            RSTCTL1->PRSTCTL0_SET = bitMask;
1800641a:	4a09      	ldr	r2, [pc, #36]	; (18006440 <RESET_SetPeripheralReset+0x68>)
1800641c:	6413      	str	r3, [r2, #64]	; 0x40
            while (0u == (RSTCTL1->PRSTCTL0 & bitMask))
1800641e:	6911      	ldr	r1, [r2, #16]
18006420:	4219      	tst	r1, r3
18006422:	d0fc      	beq.n	1800641e <RESET_SetPeripheralReset+0x46>
18006424:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL1_PSCCTL1:
            RSTCTL1->PRSTCTL1_SET = bitMask;
18006426:	4a06      	ldr	r2, [pc, #24]	; (18006440 <RESET_SetPeripheralReset+0x68>)
18006428:	6453      	str	r3, [r2, #68]	; 0x44
            while (0u == (RSTCTL1->PRSTCTL1 & bitMask))
1800642a:	6951      	ldr	r1, [r2, #20]
1800642c:	4219      	tst	r1, r3
1800642e:	d0fc      	beq.n	1800642a <RESET_SetPeripheralReset+0x52>
18006430:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL1_PSCCTL2:
            RSTCTL1->PRSTCTL2_SET = bitMask;
18006432:	4a03      	ldr	r2, [pc, #12]	; (18006440 <RESET_SetPeripheralReset+0x68>)
18006434:	6493      	str	r3, [r2, #72]	; 0x48
            while (0u == (RSTCTL1->PRSTCTL2 & bitMask))
18006436:	6991      	ldr	r1, [r2, #24]
18006438:	4219      	tst	r1, r3
1800643a:	d0fc      	beq.n	18006436 <RESET_SetPeripheralReset+0x5e>
            break;
        default:
            /* Added comments to prevent the violation of MISRA C-2012 rule. */
            break;
    }
}
1800643c:	4770      	bx	lr
1800643e:	bf00      	nop
18006440:	50020000 	.word	0x50020000

18006444 <RESET_ClearPeripheralReset>:
 */
void RESET_ClearPeripheralReset(reset_ip_name_t peripheral)
{
    const uint32_t regIndex = ((uint32_t)peripheral & 0x0000FF00u) >> 8;
    const uint32_t bitPos   = ((uint32_t)peripheral & 0x000000FFu);
    const uint32_t bitMask  = 1UL << bitPos;
18006444:	2201      	movs	r2, #1
    const uint32_t bitPos   = ((uint32_t)peripheral & 0x000000FFu);
18006446:	b2c3      	uxtb	r3, r0

    assert(bitPos < 32u);

    switch (regIndex)
18006448:	0a00      	lsrs	r0, r0, #8
    const uint32_t bitMask  = 1UL << bitPos;
1800644a:	fa02 f303 	lsl.w	r3, r2, r3
    switch (regIndex)
1800644e:	2805      	cmp	r0, #5
18006450:	d830      	bhi.n	180064b4 <RESET_ClearPeripheralReset+0x70>
18006452:	e8df f000 	tbb	[pc, r0]
18006456:	0b03      	.short	0x0b03
18006458:	29221b13 	.word	0x29221b13
    {
        case RST_CTL0_PSCCTL0:
            RSTCTL0->PRSTCTL0_CLR = bitMask;
1800645c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
18006460:	6713      	str	r3, [r2, #112]	; 0x70
            while (bitMask == (RSTCTL0->PRSTCTL0 & bitMask))
18006462:	6911      	ldr	r1, [r2, #16]
18006464:	ea33 0101 	bics.w	r1, r3, r1
18006468:	d0fb      	beq.n	18006462 <RESET_ClearPeripheralReset+0x1e>
1800646a:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL0_PSCCTL1:
            RSTCTL0->PRSTCTL1_CLR = bitMask;
1800646c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
18006470:	6753      	str	r3, [r2, #116]	; 0x74
            while (bitMask == (RSTCTL0->PRSTCTL1 & bitMask))
18006472:	6951      	ldr	r1, [r2, #20]
18006474:	ea33 0101 	bics.w	r1, r3, r1
18006478:	d0fb      	beq.n	18006472 <RESET_ClearPeripheralReset+0x2e>
1800647a:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL0_PSCCTL2:
            RSTCTL0->PRSTCTL2_CLR = bitMask;
1800647c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
18006480:	6793      	str	r3, [r2, #120]	; 0x78
            while (bitMask == (RSTCTL0->PRSTCTL2 & bitMask))
18006482:	6991      	ldr	r1, [r2, #24]
18006484:	ea33 0101 	bics.w	r1, r3, r1
18006488:	d0fb      	beq.n	18006482 <RESET_ClearPeripheralReset+0x3e>
1800648a:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL1_PSCCTL0:
            RSTCTL1->PRSTCTL0_CLR = bitMask;
1800648c:	4a0a      	ldr	r2, [pc, #40]	; (180064b8 <RESET_ClearPeripheralReset+0x74>)
1800648e:	6713      	str	r3, [r2, #112]	; 0x70
            while (bitMask == (RSTCTL1->PRSTCTL0 & bitMask))
18006490:	6911      	ldr	r1, [r2, #16]
18006492:	ea33 0101 	bics.w	r1, r3, r1
18006496:	d0fb      	beq.n	18006490 <RESET_ClearPeripheralReset+0x4c>
18006498:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL1_PSCCTL1:
            RSTCTL1->PRSTCTL1_CLR = bitMask;
1800649a:	4a07      	ldr	r2, [pc, #28]	; (180064b8 <RESET_ClearPeripheralReset+0x74>)
1800649c:	6753      	str	r3, [r2, #116]	; 0x74
            while (bitMask == (RSTCTL1->PRSTCTL1 & bitMask))
1800649e:	6951      	ldr	r1, [r2, #20]
180064a0:	ea33 0101 	bics.w	r1, r3, r1
180064a4:	d0fb      	beq.n	1800649e <RESET_ClearPeripheralReset+0x5a>
180064a6:	4770      	bx	lr
            {
            }
            break;
        case RST_CTL1_PSCCTL2:
            RSTCTL1->PRSTCTL2_CLR = bitMask;
180064a8:	4a03      	ldr	r2, [pc, #12]	; (180064b8 <RESET_ClearPeripheralReset+0x74>)
180064aa:	6793      	str	r3, [r2, #120]	; 0x78
            while (bitMask == (RSTCTL1->PRSTCTL2 & bitMask))
180064ac:	6991      	ldr	r1, [r2, #24]
180064ae:	ea33 0101 	bics.w	r1, r3, r1
180064b2:	d0fb      	beq.n	180064ac <RESET_ClearPeripheralReset+0x68>
            break;
        default:
            /* Added comments to prevent the violation of MISRA C-2012 rule. */
            break;
    }
}
180064b4:	4770      	bx	lr
180064b6:	bf00      	nop
180064b8:	50020000 	.word	0x50020000

180064bc <SDK_DelayAtLeastUs>:
 *
 * @param delayTime_us  Delay time in unit of microsecond.
 * @param coreClock_Hz  Core clock frequency with Hz.
 */
void SDK_DelayAtLeastUs(uint32_t delayTime_us, uint32_t coreClock_Hz)
{
180064bc:	b508      	push	{r3, lr}
    uint64_t count;

    if (delayTime_us > 0U)
180064be:	b150      	cbz	r0, 180064d6 <loop+0x8>
         * not matter because other instructions outside while loop is enough to fill the time.
         */
#if (__CORTEX_M == 7)
        count = count / 3U * 2U;
#else
        count = count / 4U;
180064c0:	2300      	movs	r3, #0
180064c2:	4a05      	ldr	r2, [pc, #20]	; (180064d8 <loop+0xa>)
180064c4:	fba0 0101 	umull	r0, r1, r0, r1
180064c8:	f7fa ff32 	bl	18001330 <__aeabi_uldivmod>
    __ASM volatile("    MOV    R0, %0" : : "r"(count));
180064cc:	4600      	mov	r0, r0

180064ce <loop>:
    __ASM volatile(
180064ce:	f1a0 0001 	sub.w	r0, r0, #1
180064d2:	2800      	cmp	r0, #0
180064d4:	d1fb      	bne.n	180064ce <loop>
#endif
        DelayLoop((uint32_t)count);
#endif /* defined(SDK_DELAY_USE_DWT) && defined(DWT) */
    }
}
180064d6:	bd08      	pop	{r3, pc}
180064d8:	003d0900 	.word	0x003d0900

180064dc <CLOCK_EnableClock>:
    switch (index)
180064dc:	0a03      	lsrs	r3, r0, #8
180064de:	2b05      	cmp	r3, #5
180064e0:	d817      	bhi.n	18006512 <CLOCK_EnableClock+0x36>
180064e2:	e8df f003 	tbb	[pc, r3]
180064e6:	0903      	.short	0x0903
180064e8:	231d1710 	.word	0x231d1710
            CLKCTL0->PSCCTL0_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
180064ec:	2301      	movs	r3, #1
180064ee:	fa03 f000 	lsl.w	r0, r3, r0
180064f2:	4b11      	ldr	r3, [pc, #68]	; (18006538 <CLOCK_EnableClock+0x5c>)
            CLKCTL1->PSCCTL0_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
180064f4:	6418      	str	r0, [r3, #64]	; 0x40
            break;
180064f6:	4770      	bx	lr
            CLKCTL0->PSCCTL1_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
180064f8:	2301      	movs	r3, #1
180064fa:	b2c0      	uxtb	r0, r0
180064fc:	fa03 f000 	lsl.w	r0, r3, r0
18006500:	4b0d      	ldr	r3, [pc, #52]	; (18006538 <CLOCK_EnableClock+0x5c>)
            CLKCTL1->PSCCTL1_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006502:	6458      	str	r0, [r3, #68]	; 0x44
            break;
18006504:	4770      	bx	lr
            CLKCTL0->PSCCTL2_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006506:	2301      	movs	r3, #1
18006508:	b2c0      	uxtb	r0, r0
1800650a:	fa03 f000 	lsl.w	r0, r3, r0
1800650e:	4b0a      	ldr	r3, [pc, #40]	; (18006538 <CLOCK_EnableClock+0x5c>)
            CLKCTL1->PSCCTL2_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006510:	6498      	str	r0, [r3, #72]	; 0x48
}
18006512:	4770      	bx	lr
            CLKCTL1->PSCCTL0_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006514:	2301      	movs	r3, #1
18006516:	b2c0      	uxtb	r0, r0
18006518:	fa03 f000 	lsl.w	r0, r3, r0
1800651c:	4b07      	ldr	r3, [pc, #28]	; (1800653c <CLOCK_EnableClock+0x60>)
1800651e:	e7e9      	b.n	180064f4 <CLOCK_EnableClock+0x18>
            CLKCTL1->PSCCTL1_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006520:	2301      	movs	r3, #1
18006522:	b2c0      	uxtb	r0, r0
18006524:	fa03 f000 	lsl.w	r0, r3, r0
18006528:	4b04      	ldr	r3, [pc, #16]	; (1800653c <CLOCK_EnableClock+0x60>)
1800652a:	e7ea      	b.n	18006502 <CLOCK_EnableClock+0x26>
            CLKCTL1->PSCCTL2_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
1800652c:	2301      	movs	r3, #1
1800652e:	b2c0      	uxtb	r0, r0
18006530:	fa03 f000 	lsl.w	r0, r3, r0
18006534:	4b01      	ldr	r3, [pc, #4]	; (1800653c <CLOCK_EnableClock+0x60>)
18006536:	e7eb      	b.n	18006510 <CLOCK_EnableClock+0x34>
18006538:	50001000 	.word	0x50001000
1800653c:	50021000 	.word	0x50021000

18006540 <GPIO_PortInit>:
 *
 * param base   GPIO peripheral base pointer.
 * param port   GPIO port number.
 */
void GPIO_PortInit(GPIO_Type *base, uint32_t port)
{
18006540:	b508      	push	{r3, lr}
    CLOCK_EnableClock(s_gpioClockName[port]);
18006542:	4b06      	ldr	r3, [pc, #24]	; (1800655c <GPIO_PortInit+0x1c>)
18006544:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
18006548:	f7ff ffc8 	bl	180064dc <CLOCK_EnableClock>
    GPIO_EnablePortClock(base, port);

#if !(defined(FSL_FEATURE_GPIO_HAS_NO_RESET) && FSL_FEATURE_GPIO_HAS_NO_RESET)
    /* Reset the GPIO module */
    RESET_PeripheralReset(s_gpioResets[port]);
1800654c:	4b04      	ldr	r3, [pc, #16]	; (18006560 <GPIO_PortInit+0x20>)
1800654e:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
#endif
}
18006552:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RESET_PeripheralReset(s_gpioResets[port]);
18006556:	f004 b8ec 	b.w	1800a732 <RESET_PeripheralReset>
1800655a:	bf00      	nop
1800655c:	1800bc0c 	.word	0x1800bc0c
18006560:	1800bc0c 	.word	0x1800bc0c

18006564 <PINT_Init>:
    uint32_t i;
    uint32_t pmcfg    = 0;
    uint8_t pintcount = 0;
    assert(base != NULL);

    if (base == PINT)
18006564:	4b0d      	ldr	r3, [pc, #52]	; (1800659c <PINT_Init+0x38>)
{
18006566:	b510      	push	{r4, lr}
    if (base == PINT)
18006568:	4298      	cmp	r0, r3
{
1800656a:	4604      	mov	r4, r0
1800656c:	f04f 0300 	mov.w	r3, #0
    if (base == PINT)
18006570:	d111      	bne.n	18006596 <PINT_Init+0x32>
    {
        pintcount = FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS;
        /* clear PINT callback array*/
        for (i = 0; i < (uint32_t)FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS; i++)
        {
            s_pintCallback[i] = NULL;
18006572:	4a0b      	ldr	r2, [pc, #44]	; (180065a0 <PINT_Init+0x3c>)
        /* Enable the clock. */
        CLOCK_EnableClock(kCLOCK_Pint);
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
#if !(defined(FSL_SDK_DISABLE_DRIVER_RESET_CONTROL) && FSL_SDK_DISABLE_DRIVER_RESET_CONTROL)
        /* Reset the module. */
        RESET_PeripheralReset(kPINT_RST_SHIFT_RSTn);
18006574:	f240 501e 	movw	r0, #1310	; 0x51e
            s_pintCallback[i] = NULL;
18006578:	e9c2 3300 	strd	r3, r3, [r2]
1800657c:	e9c2 3302 	strd	r3, r3, [r2, #8]
18006580:	e9c2 3304 	strd	r3, r3, [r2, #16]
18006584:	e9c2 3306 	strd	r3, r3, [r2, #24]
18006588:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
1800658c:	4b05      	ldr	r3, [pc, #20]	; (180065a4 <PINT_Init+0x40>)
1800658e:	649a      	str	r2, [r3, #72]	; 0x48
        RESET_PeripheralReset(kPINT_RST_SHIFT_RSTn);
18006590:	f004 f8cf 	bl	1800a732 <RESET_PeripheralReset>
18006594:	4b04      	ldr	r3, [pc, #16]	; (180065a8 <PINT_Init+0x44>)
#endif /* FSL_FEATURE_SECPINT_NUMBER_OF_CONNECTED_OUTPUTS */
    }
#endif /* FSL_FEATURE_CLOCK_HAS_GPIOINT_CLOCK_SOURCE */

    /* Disable all pattern match bit slices */
    base->PMCFG = pmcfg;
18006596:	6323      	str	r3, [r4, #48]	; 0x30
}
18006598:	bd10      	pop	{r4, pc}
1800659a:	bf00      	nop
1800659c:	50025000 	.word	0x50025000
180065a0:	301809f8 	.word	0x301809f8
180065a4:	50021000 	.word	0x50021000
180065a8:	db6db600 	.word	0xdb6db600

180065ac <PINT_PinInterruptConfig>:
 * param callback Callback.
 *
 * retval None.
 */
void PINT_PinInterruptConfig(PINT_Type *base, pint_pin_int_t intr, pint_pin_enable_t enable, pint_cb_t callback)
{
180065ac:	b530      	push	{r4, r5, lr}
 *
 * @retval None.
 */
static inline void PINT_PinInterruptClrRiseFlag(PINT_Type *base, pint_pin_int_t pintr)
{
    base->RISE = (1UL << (uint32_t)pintr);
180065ae:	2401      	movs	r4, #1
    /* Clear Rise and Fall flags first */
    PINT_PinInterruptClrRiseFlag(base, intr);
    PINT_PinInterruptClrFallFlag(base, intr);

    /* Security PINT uses additional callback array */
    if (base == PINT)
180065b0:	4d0f      	ldr	r5, [pc, #60]	; (180065f0 <PINT_PinInterruptConfig+0x44>)
180065b2:	408c      	lsls	r4, r1
180065b4:	42a8      	cmp	r0, r5
    {
        s_pintCallback[intr] = callback;
180065b6:	bf08      	it	eq
180065b8:	4d0e      	ldreq	r5, [pc, #56]	; (180065f4 <PINT_PinInterruptConfig+0x48>)
180065ba:	61c4      	str	r4, [r0, #28]
180065bc:	bf08      	it	eq
180065be:	f845 3021 	streq.w	r3, [r5, r1, lsl #2]
#endif
    }

    /* select level or edge sensitive */
    base->ISEL = (base->ISEL & ~(1UL << (uint32_t)intr)) |
                 ((((uint32_t)enable & PINT_PIN_INT_LEVEL) != 0U) ? (1UL << (uint32_t)intr) : 0U);
180065c2:	f012 0f10 	tst.w	r2, #16
180065c6:	bf14      	ite	ne
180065c8:	4621      	movne	r1, r4
180065ca:	2100      	moveq	r1, #0
    base->FALL = (1UL << (uint32_t)pintr);
180065cc:	6204      	str	r4, [r0, #32]
    base->ISEL = (base->ISEL & ~(1UL << (uint32_t)intr)) |
180065ce:	6803      	ldr	r3, [r0, #0]

    /* enable rising or level interrupt */
    if (((unsigned)enable & (PINT_PIN_INT_LEVEL | PINT_PIN_INT_RISE)) != 0U)
180065d0:	f012 0f11 	tst.w	r2, #17
    base->ISEL = (base->ISEL & ~(1UL << (uint32_t)intr)) |
180065d4:	ea23 0304 	bic.w	r3, r3, r4
180065d8:	ea43 0301 	orr.w	r3, r3, r1
180065dc:	6003      	str	r3, [r0, #0]
    {
        base->SIENR = 1UL << (uint32_t)intr;
180065de:	bf14      	ite	ne
180065e0:	6084      	strne	r4, [r0, #8]
    }
    else
    {
        base->CIENR = 1UL << (uint32_t)intr;
180065e2:	60c4      	streq	r4, [r0, #12]
    }

    /* Enable falling or select high level */
    if (((unsigned)enable & PINT_PIN_INT_FALL_OR_HIGH_LEVEL) != 0U)
180065e4:	0793      	lsls	r3, r2, #30
    {
        base->SIENF = 1UL << (uint32_t)intr;
180065e6:	bf4c      	ite	mi
180065e8:	6144      	strmi	r4, [r0, #20]
    }
    else
    {
        base->CIENF = 1UL << (uint32_t)intr;
180065ea:	6184      	strpl	r4, [r0, #24]
    }
}
180065ec:	bd30      	pop	{r4, r5, pc}
180065ee:	bf00      	nop
180065f0:	50025000 	.word	0x50025000
180065f4:	301809f8 	.word	0x301809f8

180065f8 <INPUTMUX_Init>:
180065f8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
180065fc:	4b01      	ldr	r3, [pc, #4]	; (18006604 <INPUTMUX_Init+0xc>)
180065fe:	649a      	str	r2, [r3, #72]	; 0x48
    CLOCK_EnableClock(kCLOCK_Dma);
#else
    CLOCK_EnableClock(kCLOCK_InputMux);
#endif /* FSL_FEATURE_INPUTMUX_HAS_NO_INPUTMUX_CLOCK_SOURCE */
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}
18006600:	4770      	bx	lr
18006602:	bf00      	nop
18006604:	50021000 	.word	0x50021000

18006608 <INPUTMUX_Deinit>:
            CLKCTL1->PSCCTL2_CLR = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006608:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
1800660c:	4b01      	ldr	r3, [pc, #4]	; (18006614 <INPUTMUX_Deinit+0xc>)
1800660e:	679a      	str	r2, [r3, #120]	; 0x78
    CLOCK_DisableClock(kCLOCK_Dma);
#else
    CLOCK_DisableClock(kCLOCK_InputMux);
#endif /* FSL_FEATURE_INPUTMUX_HAS_NO_INPUTMUX_CLOCK_SOURCE */
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}
18006610:	4770      	bx	lr
18006612:	bf00      	nop
18006614:	50021000 	.word	0x50021000

18006618 <OSTIMER_GetInstance>:
    }

    assert(instance < ARRAY_SIZE(s_ostimerBases));

    return instance;
}
18006618:	4b02      	ldr	r3, [pc, #8]	; (18006624 <OSTIMER_GetInstance+0xc>)
1800661a:	1ac0      	subs	r0, r0, r3
1800661c:	bf18      	it	ne
1800661e:	2001      	movne	r0, #1
18006620:	4770      	bx	lr
18006622:	bf00      	nop
18006624:	50113000 	.word	0x50113000

18006628 <OSTIMER_HandleIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
18006628:	f44f 7200 	mov.w	r2, #512	; 0x200
1800662c:	4b06      	ldr	r3, [pc, #24]	; (18006648 <OSTIMER_HandleIRQ+0x20>)
1800662e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
18006632:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
18006636:	f3bf 8f6f 	isb	sy
    }
    else
    {
        /* Clear interrupt flag, disable the IRQ and module interrupt enablement. */
        (void)DisableIRQ(s_ostimerIRQ[OSTIMER_GetInstance(base)]);
        base->OSEVENT_CTRL &= ~OSTIMER_OSEVENT_CTRL_OSTIMER_INTENA_MASK; /* Clear interrupt flag by writing 1. */
1800663a:	69c3      	ldr	r3, [r0, #28]
1800663c:	f023 0302 	bic.w	r3, r3, #2
18006640:	61c3      	str	r3, [r0, #28]
void OSTIMER_HandleIRQ(OSTIMER_Type *base, ostimer_callback_t cb)
{
    /* Clear interrupt flag, disable the IRQ and module interrupt enablement. */
    OSTIMER_EnableInterrupt(base, false);

    if (cb != NULL)
18006642:	b101      	cbz	r1, 18006646 <OSTIMER_HandleIRQ+0x1e>
    {
        cb();
18006644:	4708      	bx	r1
    }
}
18006646:	4770      	bx	lr
18006648:	e000e100 	.word	0xe000e100

1800664c <OSTIMER_Init>:
            CLKCTL1->PSCCTL0_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
1800664c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
18006650:	4b01      	ldr	r3, [pc, #4]	; (18006658 <OSTIMER_Init+0xc>)
18006652:	641a      	str	r2, [r3, #64]	; 0x40
}
18006654:	4770      	bx	lr
18006656:	bf00      	nop
18006658:	50021000 	.word	0x50021000

1800665c <OSTIMER_SetMatchRawValue>:
{
1800665c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1800665e:	4615      	mov	r5, r2
18006660:	f44f 7200 	mov.w	r2, #512	; 0x200
18006664:	461e      	mov	r6, r3
18006666:	4604      	mov	r4, r0
    uint32_t instance = OSTIMER_GetInstance(base);
18006668:	f7ff ffd6 	bl	18006618 <OSTIMER_GetInstance>
1800666c:	4b1c      	ldr	r3, [pc, #112]	; (180066e0 <OSTIMER_SetMatchRawValue+0x84>)
1800666e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
18006672:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
18006676:	f3bf 8f6f 	isb	sy
        base->OSEVENT_CTRL &= ~OSTIMER_OSEVENT_CTRL_OSTIMER_INTENA_MASK; /* Clear interrupt flag by writing 1. */
1800667a:	69e3      	ldr	r3, [r4, #28]
    s_ostimerIsr              = OSTIMER_HandleIRQ;
1800667c:	4a19      	ldr	r2, [pc, #100]	; (180066e4 <OSTIMER_SetMatchRawValue+0x88>)
        base->OSEVENT_CTRL &= ~OSTIMER_OSEVENT_CTRL_OSTIMER_INTENA_MASK; /* Clear interrupt flag by writing 1. */
1800667e:	f023 0302 	bic.w	r3, r3, #2
18006682:	61e3      	str	r3, [r4, #28]
    s_ostimerIsr              = OSTIMER_HandleIRQ;
18006684:	4b18      	ldr	r3, [pc, #96]	; (180066e8 <OSTIMER_SetMatchRawValue+0x8c>)
    base->MATCH_L = (uint32_t)tmp;
18006686:	6125      	str	r5, [r4, #16]
    s_ostimerIsr              = OSTIMER_HandleIRQ;
18006688:	601a      	str	r2, [r3, #0]
    s_ostimerHandle[instance] = cb;
1800668a:	9a06      	ldr	r2, [sp, #24]
1800668c:	4b17      	ldr	r3, [pc, #92]	; (180066ec <OSTIMER_SetMatchRawValue+0x90>)
    base->MATCH_H = (uint32_t)(tmp >> 32U);
1800668e:	6166      	str	r6, [r4, #20]
    s_ostimerHandle[instance] = cb;
18006690:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
    while (0U != (base->OSEVENT_CTRL & OSTIMER_OSEVENT_CTRL_MATCH_WR_RDY_MASK))
18006694:	69e3      	ldr	r3, [r4, #28]
18006696:	075a      	lsls	r2, r3, #29
18006698:	d4fc      	bmi.n	18006694 <OSTIMER_SetMatchRawValue+0x38>
    decValueTimer = OSTIMER_GetCurrentTimerValue(base);
1800669a:	4620      	mov	r0, r4
1800669c:	f004 f864 	bl	1800a768 <OSTIMER_GetCurrentTimerValue>
    while (temp != 0U)
180066a0:	462f      	mov	r7, r5
180066a2:	4633      	mov	r3, r6
180066a4:	ea55 0206 	orrs.w	r2, r5, r6
180066a8:	d110      	bne.n	180066cc <OSTIMER_SetMatchRawValue+0x70>
    if ((decValueTimer >= OSTIMER_GrayToDecimal(tmp)) &&
180066aa:	42b8      	cmp	r0, r7
180066ac:	eb71 0303 	sbcs.w	r3, r1, r3
180066b0:	d302      	bcc.n	180066b8 <OSTIMER_SetMatchRawValue+0x5c>
        (0U == (base->OSEVENT_CTRL & (uint32_t)kOSTIMER_MatchInterruptFlag)))
180066b2:	69e3      	ldr	r3, [r4, #28]
    if ((decValueTimer >= OSTIMER_GrayToDecimal(tmp)) &&
180066b4:	07db      	lsls	r3, r3, #31
180066b6:	d510      	bpl.n	180066da <OSTIMER_SetMatchRawValue+0x7e>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
180066b8:	f44f 7200 	mov.w	r2, #512	; 0x200
180066bc:	4b08      	ldr	r3, [pc, #32]	; (180066e0 <OSTIMER_SetMatchRawValue+0x84>)
180066be:	605a      	str	r2, [r3, #4]
        status = kStatus_Success;
180066c0:	2000      	movs	r0, #0
        base->OSEVENT_CTRL |= OSTIMER_OSEVENT_CTRL_OSTIMER_INTENA_MASK;
180066c2:	69e3      	ldr	r3, [r4, #28]
180066c4:	f043 0302 	orr.w	r3, r3, #2
180066c8:	61e3      	str	r3, [r4, #28]
}
180066ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        temp >>= 1U;
180066cc:	086d      	lsrs	r5, r5, #1
180066ce:	ea45 75c6 	orr.w	r5, r5, r6, lsl #31
180066d2:	0876      	lsrs	r6, r6, #1
        gray ^= temp;
180066d4:	406f      	eors	r7, r5
180066d6:	4073      	eors	r3, r6
180066d8:	e7e4      	b.n	180066a4 <OSTIMER_SetMatchRawValue+0x48>
        status = kStatus_Fail;
180066da:	2001      	movs	r0, #1
    return status;
180066dc:	e7f5      	b.n	180066ca <OSTIMER_SetMatchRawValue+0x6e>
180066de:	bf00      	nop
180066e0:	e000e100 	.word	0xe000e100
180066e4:	18006629 	.word	0x18006629
180066e8:	30180a1c 	.word	0x30180a1c
180066ec:	30180a18 	.word	0x30180a18

180066f0 <FLEXCOMM_GetInstance>:
}

/* Get the index corresponding to the FLEXCOMM */
/*! brief Returns instance number for FLEXCOMM module with given base address. */
uint32_t FLEXCOMM_GetInstance(void *base)
{
180066f0:	4603      	mov	r3, r0
    uint32_t i;
    pvoid_to_u32_t BaseAddr;
    BaseAddr.pvoid = base;

    for (i = 0U; i < (uint32_t)FSL_FEATURE_SOC_FLEXCOMM_COUNT; i++)
180066f2:	2000      	movs	r0, #0
180066f4:	4a04      	ldr	r2, [pc, #16]	; (18006708 <FLEXCOMM_GetInstance+0x18>)
    {
        if (BaseAddr.u32 == s_flexcommBaseAddrs[i])
180066f6:	f852 1b04 	ldr.w	r1, [r2], #4
180066fa:	4299      	cmp	r1, r3
180066fc:	d002      	beq.n	18006704 <FLEXCOMM_GetInstance+0x14>
    for (i = 0U; i < (uint32_t)FSL_FEATURE_SOC_FLEXCOMM_COUNT; i++)
180066fe:	3001      	adds	r0, #1
18006700:	280a      	cmp	r0, #10
18006702:	d1f8      	bne.n	180066f6 <FLEXCOMM_GetInstance+0x6>
        }
    }

    assert(i < (uint32_t)FSL_FEATURE_SOC_FLEXCOMM_COUNT);
    return i;
}
18006704:	4770      	bx	lr
18006706:	bf00      	nop
18006708:	1800bbb8 	.word	0x1800bbb8

1800670c <FLEXCOMM_Init>:
    return kStatus_Success;
}

/*! brief Initializes FLEXCOMM and selects peripheral mode according to the second parameter. */
status_t FLEXCOMM_Init(void *base, FLEXCOMM_PERIPH_T periph)
{
1800670c:	b538      	push	{r3, r4, r5, lr}
1800670e:	4605      	mov	r5, r0
18006710:	460c      	mov	r4, r1
    uint32_t idx = FLEXCOMM_GetInstance(base);
18006712:	f7ff ffed 	bl	180066f0 <FLEXCOMM_GetInstance>

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Enable the peripheral clock */
    CLOCK_EnableClock(s_flexcommClocks[idx]);
18006716:	4b2c      	ldr	r3, [pc, #176]	; (180067c8 <FLEXCOMM_Init+0xbc>)
18006718:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    switch (index)
1800671c:	0a1a      	lsrs	r2, r3, #8
1800671e:	2a05      	cmp	r2, #5
18006720:	d809      	bhi.n	18006736 <FLEXCOMM_Init+0x2a>
18006722:	e8df f002 	tbb	[pc, r2]
18006726:	2503      	.short	0x2503
18006728:	3f39332c 	.word	0x3f39332c
            CLKCTL0->PSCCTL0_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
1800672c:	2201      	movs	r2, #1
1800672e:	fa02 f303 	lsl.w	r3, r2, r3
18006732:	4a26      	ldr	r2, [pc, #152]	; (180067cc <FLEXCOMM_Init+0xc0>)
            CLKCTL1->PSCCTL0_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006734:	6413      	str	r3, [r2, #64]	; 0x40
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

#if !(defined(FSL_FEATURE_FLEXCOMM_HAS_NO_RESET) && FSL_FEATURE_FLEXCOMM_HAS_NO_RESET)
    /* Reset the FLEXCOMM module */
    RESET_PeripheralReset(s_flexcommResets[idx]);
18006736:	4b26      	ldr	r3, [pc, #152]	; (180067d0 <FLEXCOMM_Init+0xc4>)
18006738:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1800673c:	f003 fff9 	bl	1800a732 <RESET_PeripheralReset>
    if (periph == FLEXCOMM_PERIPH_NONE)
18006740:	b144      	cbz	r4, 18006754 <FLEXCOMM_Init+0x48>
    else if (periph <= FLEXCOMM_PERIPH_I2S_TX)
18006742:	2c04      	cmp	r4, #4
18006744:	d834      	bhi.n	180067b0 <FLEXCOMM_Init+0xa4>
        return (base->PSELID & (1UL << ((uint32_t)periph + 3U))) > 0UL ? true : false;
18006746:	f8d5 3ff8 	ldr.w	r3, [r5, #4088]	; 0xff8
1800674a:	1ce2      	adds	r2, r4, #3
1800674c:	40d3      	lsrs	r3, r2
    if (!FLEXCOMM_PeripheralIsPresent(base, periph))
1800674e:	f013 0f01 	tst.w	r3, #1
18006752:	d034      	beq.n	180067be <FLEXCOMM_Init+0xb2>
    if (((base->PSELID & FLEXCOMM_PSELID_LOCK_MASK) != 0U) &&
18006754:	f8d5 3ff8 	ldr.w	r3, [r5, #4088]	; 0xff8
18006758:	071b      	lsls	r3, r3, #28
1800675a:	d505      	bpl.n	18006768 <FLEXCOMM_Init+0x5c>
        ((base->PSELID & FLEXCOMM_PSELID_PERSEL_MASK) != (uint32_t)periph))
1800675c:	f8d5 3ff8 	ldr.w	r3, [r5, #4088]	; 0xff8
18006760:	f003 0307 	and.w	r3, r3, #7
    if (((base->PSELID & FLEXCOMM_PSELID_LOCK_MASK) != 0U) &&
18006764:	42a3      	cmp	r3, r4
18006766:	d12c      	bne.n	180067c2 <FLEXCOMM_Init+0xb6>
    return kStatus_Success;
18006768:	2000      	movs	r0, #0
        base->PSELID = (uint32_t)periph;
1800676a:	f8c5 4ff8 	str.w	r4, [r5, #4088]	; 0xff8
#endif

    /* Set the FLEXCOMM to given peripheral */
    return FLEXCOMM_SetPeriph((FLEXCOMM_Type *)base, periph, 0);
}
1800676e:	bd38      	pop	{r3, r4, r5, pc}
            CLKCTL0->PSCCTL1_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006770:	2201      	movs	r2, #1
18006772:	b2db      	uxtb	r3, r3
18006774:	fa02 f303 	lsl.w	r3, r2, r3
18006778:	4a14      	ldr	r2, [pc, #80]	; (180067cc <FLEXCOMM_Init+0xc0>)
            CLKCTL1->PSCCTL1_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
1800677a:	6453      	str	r3, [r2, #68]	; 0x44
            break;
1800677c:	e7db      	b.n	18006736 <FLEXCOMM_Init+0x2a>
            CLKCTL0->PSCCTL2_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
1800677e:	2201      	movs	r2, #1
18006780:	b2db      	uxtb	r3, r3
18006782:	fa02 f303 	lsl.w	r3, r2, r3
18006786:	4a11      	ldr	r2, [pc, #68]	; (180067cc <FLEXCOMM_Init+0xc0>)
            CLKCTL1->PSCCTL2_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006788:	6493      	str	r3, [r2, #72]	; 0x48
            break;
1800678a:	e7d4      	b.n	18006736 <FLEXCOMM_Init+0x2a>
            CLKCTL1->PSCCTL0_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
1800678c:	2201      	movs	r2, #1
1800678e:	b2db      	uxtb	r3, r3
18006790:	fa02 f303 	lsl.w	r3, r2, r3
18006794:	4a0f      	ldr	r2, [pc, #60]	; (180067d4 <FLEXCOMM_Init+0xc8>)
18006796:	e7cd      	b.n	18006734 <FLEXCOMM_Init+0x28>
            CLKCTL1->PSCCTL1_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
18006798:	2201      	movs	r2, #1
1800679a:	b2db      	uxtb	r3, r3
1800679c:	fa02 f303 	lsl.w	r3, r2, r3
180067a0:	4a0c      	ldr	r2, [pc, #48]	; (180067d4 <FLEXCOMM_Init+0xc8>)
180067a2:	e7ea      	b.n	1800677a <FLEXCOMM_Init+0x6e>
            CLKCTL1->PSCCTL2_SET = (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
180067a4:	2201      	movs	r2, #1
180067a6:	b2db      	uxtb	r3, r3
180067a8:	fa02 f303 	lsl.w	r3, r2, r3
180067ac:	4a09      	ldr	r2, [pc, #36]	; (180067d4 <FLEXCOMM_Init+0xc8>)
180067ae:	e7eb      	b.n	18006788 <FLEXCOMM_Init+0x7c>
    else if (periph == FLEXCOMM_PERIPH_I2S_RX)
180067b0:	2c05      	cmp	r4, #5
180067b2:	d104      	bne.n	180067be <FLEXCOMM_Init+0xb2>
        return (base->PSELID & (1U << 7U)) > (uint32_t)0U ? true : false;
180067b4:	f8d5 3ff8 	ldr.w	r3, [r5, #4088]	; 0xff8
    if (!FLEXCOMM_PeripheralIsPresent(base, periph))
180067b8:	f013 0f80 	tst.w	r3, #128	; 0x80
180067bc:	e7c9      	b.n	18006752 <FLEXCOMM_Init+0x46>
        return kStatus_OutOfRange;
180067be:	2003      	movs	r0, #3
180067c0:	e7d5      	b.n	1800676e <FLEXCOMM_Init+0x62>
        return kStatus_Fail;
180067c2:	2001      	movs	r0, #1
    return FLEXCOMM_SetPeriph((FLEXCOMM_Type *)base, periph, 0);
180067c4:	e7d3      	b.n	1800676e <FLEXCOMM_Init+0x62>
180067c6:	bf00      	nop
180067c8:	1800bc1c 	.word	0x1800bc1c
180067cc:	50001000 	.word	0x50001000
180067d0:	1800bc1c 	.word	0x1800bc1c
180067d4:	50021000 	.word	0x50021000

180067d8 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
180067d8:	4b0e      	ldr	r3, [pc, #56]	; (18006814 <z_sys_init_run_level+0x3c>)
{
180067da:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
180067dc:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
180067e0:	3001      	adds	r0, #1
180067e2:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
180067e6:	42a6      	cmp	r6, r4
180067e8:	d800      	bhi.n	180067ec <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
180067ea:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
180067ec:	e9d4 3500 	ldrd	r3, r5, [r4]
180067f0:	4628      	mov	r0, r5
180067f2:	4798      	blx	r3
		if (dev != NULL) {
180067f4:	b165      	cbz	r5, 18006810 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
180067f6:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
180067f8:	b130      	cbz	r0, 18006808 <z_sys_init_run_level+0x30>
				if (rc < 0) {
180067fa:	2800      	cmp	r0, #0
180067fc:	bfb8      	it	lt
180067fe:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
18006800:	28ff      	cmp	r0, #255	; 0xff
18006802:	bfa8      	it	ge
18006804:	20ff      	movge	r0, #255	; 0xff
18006806:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
18006808:	785a      	ldrb	r2, [r3, #1]
1800680a:	f042 0201 	orr.w	r2, r2, #1
1800680e:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
18006810:	3408      	adds	r4, #8
18006812:	e7e8      	b.n	180067e6 <z_sys_init_run_level+0xe>
18006814:	1800bbe0 	.word	0x1800bbe0

18006818 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
18006818:	4b01      	ldr	r3, [pc, #4]	; (18006820 <z_impl_z_errno+0x8>)
1800681a:	6898      	ldr	r0, [r3, #8]
}
1800681c:	3098      	adds	r0, #152	; 0x98
1800681e:	4770      	bx	lr
18006820:	30180a20 	.word	0x30180a20

18006824 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
18006824:	b510      	push	{r4, lr}
18006826:	4604      	mov	r4, r0
	z_impl_log_panic();
18006828:	f7fb feea 	bl	18002600 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
1800682c:	4907      	ldr	r1, [pc, #28]	; (1800684c <k_sys_fatal_error_handler+0x28>)
1800682e:	680b      	ldr	r3, [r1, #0]
18006830:	075b      	lsls	r3, r3, #29
18006832:	d008      	beq.n	18006846 <k_sys_fatal_error_handler+0x22>
18006834:	4b06      	ldr	r3, [pc, #24]	; (18006850 <k_sys_fatal_error_handler+0x2c>)
18006836:	4807      	ldr	r0, [pc, #28]	; (18006854 <k_sys_fatal_error_handler+0x30>)
18006838:	1ac9      	subs	r1, r1, r3
1800683a:	0889      	lsrs	r1, r1, #2
1800683c:	0189      	lsls	r1, r1, #6
1800683e:	f041 0101 	orr.w	r1, r1, #1
18006842:	f001 ffb4 	bl	180087ae <log_0>
	arch_system_halt(reason);
18006846:	4620      	mov	r0, r4
18006848:	f004 f8b3 	bl	1800a9b2 <arch_system_halt>
1800684c:	3018009c 	.word	0x3018009c
18006850:	3018008c 	.word	0x3018008c
18006854:	1800dcd9 	.word	0x1800dcd9

18006858 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
18006858:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
1800685c:	4606      	mov	r6, r0
1800685e:	460f      	mov	r7, r1
	__asm__ volatile(
18006860:	f04f 0320 	mov.w	r3, #32
18006864:	f3ef 8811 	mrs	r8, BASEPRI
18006868:	f383 8812 	msr	BASEPRI_MAX, r3
1800686c:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
18006870:	f000 ff92 	bl	18007798 <z_impl_z_current_get>
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
18006874:	4c2c      	ldr	r4, [pc, #176]	; (18006928 <z_fatal_error+0xd0>)
18006876:	4605      	mov	r5, r0
18006878:	6823      	ldr	r3, [r4, #0]
1800687a:	0759      	lsls	r1, r3, #29
1800687c:	d051      	beq.n	18006922 <z_fatal_error+0xca>
1800687e:	4b2b      	ldr	r3, [pc, #172]	; (1800692c <z_fatal_error+0xd4>)
18006880:	2e04      	cmp	r6, #4
18006882:	eba4 0303 	sub.w	r3, r4, r3
18006886:	ea4f 0393 	mov.w	r3, r3, lsr #2
1800688a:	bf98      	it	ls
1800688c:	4a28      	ldrls	r2, [pc, #160]	; (18006930 <z_fatal_error+0xd8>)
1800688e:	ea4f 1383 	mov.w	r3, r3, lsl #6
18006892:	f043 0301 	orr.w	r3, r3, #1
	switch (reason) {
18006896:	bf94      	ite	ls
18006898:	f852 2026 	ldrls.w	r2, [r2, r6, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
1800689c:	4a25      	ldrhi	r2, [pc, #148]	; (18006934 <z_fatal_error+0xdc>)
1800689e:	f8ad 3000 	strh.w	r3, [sp]
180068a2:	4631      	mov	r1, r6
180068a4:	2300      	movs	r3, #0
180068a6:	4824      	ldr	r0, [pc, #144]	; (18006938 <z_fatal_error+0xe0>)
180068a8:	f001 ffbb 	bl	18008822 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
180068ac:	b17f      	cbz	r7, 180068ce <z_fatal_error+0x76>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
180068ae:	69fb      	ldr	r3, [r7, #28]
180068b0:	f3c3 0308 	ubfx	r3, r3, #0, #9
180068b4:	b15b      	cbz	r3, 180068ce <z_fatal_error+0x76>
		LOG_ERR("Fault during interrupt handling\n");
180068b6:	6823      	ldr	r3, [r4, #0]
180068b8:	075a      	lsls	r2, r3, #29
180068ba:	d01b      	beq.n	180068f4 <z_fatal_error+0x9c>
180068bc:	491b      	ldr	r1, [pc, #108]	; (1800692c <z_fatal_error+0xd4>)
180068be:	481f      	ldr	r0, [pc, #124]	; (1800693c <z_fatal_error+0xe4>)
180068c0:	1a61      	subs	r1, r4, r1
180068c2:	0889      	lsrs	r1, r1, #2
180068c4:	0189      	lsls	r1, r1, #6
180068c6:	f041 0101 	orr.w	r1, r1, #1
180068ca:	f001 ff70 	bl	180087ae <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
180068ce:	6823      	ldr	r3, [r4, #0]
180068d0:	075b      	lsls	r3, r3, #29
180068d2:	d00f      	beq.n	180068f4 <z_fatal_error+0x9c>
180068d4:	4b15      	ldr	r3, [pc, #84]	; (1800692c <z_fatal_error+0xd4>)
180068d6:	1ae4      	subs	r4, r4, r3
180068d8:	08a4      	lsrs	r4, r4, #2
180068da:	01a4      	lsls	r4, r4, #6
180068dc:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
180068e0:	b9b5      	cbnz	r5, 18006910 <z_fatal_error+0xb8>
		thread_name = "unknown";
180068e2:	4817      	ldr	r0, [pc, #92]	; (18006940 <z_fatal_error+0xe8>)
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
180068e4:	f7fb fd1a 	bl	1800231c <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
180068e8:	4623      	mov	r3, r4
180068ea:	4602      	mov	r2, r0
180068ec:	4629      	mov	r1, r5
180068ee:	4815      	ldr	r0, [pc, #84]	; (18006944 <z_fatal_error+0xec>)
180068f0:	f001 ff7e 	bl	180087f0 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
180068f4:	4639      	mov	r1, r7
180068f6:	4630      	mov	r0, r6
180068f8:	f7ff ff94 	bl	18006824 <k_sys_fatal_error_handler>
	__asm__ volatile(
180068fc:	f388 8811 	msr	BASEPRI, r8
18006900:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
18006904:	4628      	mov	r0, r5
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
18006906:	b002      	add	sp, #8
18006908:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
1800690c:	f7fe be8a 	b.w	18005624 <z_impl_k_thread_abort>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
18006910:	4628      	mov	r0, r5
18006912:	f004 f8a2 	bl	1800aa5a <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
18006916:	2800      	cmp	r0, #0
18006918:	d0e3      	beq.n	180068e2 <z_fatal_error+0x8a>
1800691a:	7803      	ldrb	r3, [r0, #0]
1800691c:	2b00      	cmp	r3, #0
1800691e:	d0e0      	beq.n	180068e2 <z_fatal_error+0x8a>
18006920:	e7e0      	b.n	180068e4 <z_fatal_error+0x8c>
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
18006922:	2f00      	cmp	r7, #0
18006924:	d1c3      	bne.n	180068ae <z_fatal_error+0x56>
18006926:	e7e5      	b.n	180068f4 <z_fatal_error+0x9c>
18006928:	3018009c 	.word	0x3018009c
1800692c:	3018008c 	.word	0x3018008c
18006930:	1800bbf8 	.word	0x1800bbf8
18006934:	1800dce8 	.word	0x1800dce8
18006938:	1800dcfe 	.word	0x1800dcfe
1800693c:	1800dd26 	.word	0x1800dd26
18006940:	1800dcf6 	.word	0x1800dcf6
18006944:	1800dd47 	.word	0x1800dd47

18006948 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
18006948:	b570      	push	{r4, r5, r6, lr}
1800694a:	b088      	sub	sp, #32
	k_thread_stack_t *stack = z_idle_stacks[i];

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
1800694c:	ae06      	add	r6, sp, #24
{
1800694e:	4604      	mov	r4, r0
	snprintk(tname, 8, "idle %02d", i);
18006950:	4603      	mov	r3, r0
18006952:	2108      	movs	r1, #8
18006954:	4630      	mov	r0, r6
18006956:	4a11      	ldr	r2, [pc, #68]	; (1800699c <init_idle_thread+0x54>)
18006958:	f001 fb9b 	bl	18008092 <snprintk>
	struct k_thread *thread = &z_idle_threads[i];
1800695c:	23b8      	movs	r3, #184	; 0xb8
1800695e:	4d10      	ldr	r5, [pc, #64]	; (180069a0 <init_idle_thread+0x58>)
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
18006960:	2201      	movs	r2, #1
	struct k_thread *thread = &z_idle_threads[i];
18006962:	fb03 5504 	mla	r5, r3, r4, r5
	z_setup_new_thread(thread, stack,
18006966:	230f      	movs	r3, #15
18006968:	e9cd 3203 	strd	r3, r2, [sp, #12]
1800696c:	2300      	movs	r3, #0
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
1800696e:	2218      	movs	r2, #24
	z_setup_new_thread(thread, stack,
18006970:	e9cd 3301 	strd	r3, r3, [sp, #4]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
18006974:	4b0b      	ldr	r3, [pc, #44]	; (180069a4 <init_idle_thread+0x5c>)
	z_setup_new_thread(thread, stack,
18006976:	490c      	ldr	r1, [pc, #48]	; (180069a8 <init_idle_thread+0x60>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
18006978:	fb02 3304 	mla	r3, r2, r4, r3
	z_setup_new_thread(thread, stack,
1800697c:	f44f 72a0 	mov.w	r2, #320	; 0x140
18006980:	9300      	str	r3, [sp, #0]
18006982:	4628      	mov	r0, r5
18006984:	fb02 1104 	mla	r1, r2, r4, r1
18006988:	4b08      	ldr	r3, [pc, #32]	; (180069ac <init_idle_thread+0x64>)
1800698a:	9605      	str	r6, [sp, #20]
1800698c:	f000 f986 	bl	18006c9c <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
18006990:	7b6b      	ldrb	r3, [r5, #13]
18006992:	f023 0304 	bic.w	r3, r3, #4
18006996:	736b      	strb	r3, [r5, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
18006998:	b008      	add	sp, #32
1800699a:	bd70      	pop	{r4, r5, r6, pc}
1800699c:	1800dda9 	.word	0x1800dda9
180069a0:	301802d8 	.word	0x301802d8
180069a4:	30180a20 	.word	0x30180a20
180069a8:	30182158 	.word	0x30182158
180069ac:	1800aa7f 	.word	0x1800aa7f

180069b0 <bg_thread_main>:
	z_sys_post_kernel = true;
180069b0:	2201      	movs	r2, #1
{
180069b2:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
180069b4:	4b09      	ldr	r3, [pc, #36]	; (180069dc <bg_thread_main+0x2c>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
180069b6:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
180069b8:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
180069ba:	f7ff ff0d 	bl	180067d8 <z_sys_init_run_level>
	boot_banner();
180069be:	f001 f9ef 	bl	18007da0 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
180069c2:	2003      	movs	r0, #3
180069c4:	f7ff ff08 	bl	180067d8 <z_sys_init_run_level>
	z_init_static_threads();
180069c8:	f000 f9f4 	bl	18006db4 <z_init_static_threads>
	main();
180069cc:	f7fa fee8 	bl	180017a0 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
180069d0:	4a03      	ldr	r2, [pc, #12]	; (180069e0 <bg_thread_main+0x30>)
180069d2:	7b13      	ldrb	r3, [r2, #12]
180069d4:	f023 0301 	bic.w	r3, r3, #1
180069d8:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
180069da:	bd08      	pop	{r3, pc}
180069dc:	30180a87 	.word	0x30180a87
180069e0:	30180390 	.word	0x30180390

180069e4 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
180069e4:	4802      	ldr	r0, [pc, #8]	; (180069f0 <z_bss_zero+0xc>)
180069e6:	4a03      	ldr	r2, [pc, #12]	; (180069f4 <z_bss_zero+0x10>)
180069e8:	2100      	movs	r1, #0
180069ea:	1a12      	subs	r2, r2, r0
180069ec:	f003 bbbc 	b.w	1800a168 <memset>
180069f0:	301800f0 	.word	0x301800f0
180069f4:	30180a88 	.word	0x30180a88

180069f8 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
180069f8:	b580      	push	{r7, lr}
180069fa:	b0b4      	sub	sp, #208	; 0xd0
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
180069fc:	f7fb fbda 	bl	180021b4 <log_core_init>
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
18006a00:	4b35      	ldr	r3, [pc, #212]	; (18006ad8 <z_cstart+0xe0>)
	uint32_t msp =
18006a02:	f503 6700 	add.w	r7, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
18006a06:	f387 8808 	msr	MSP, r7
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
18006a0a:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
18006a0e:	2400      	movs	r4, #0
18006a10:	23e0      	movs	r3, #224	; 0xe0
18006a12:	4d32      	ldr	r5, [pc, #200]	; (18006adc <z_cstart+0xe4>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
18006a14:	4e32      	ldr	r6, [pc, #200]	; (18006ae0 <z_cstart+0xe8>)
18006a16:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
18006a1a:	77ec      	strb	r4, [r5, #31]
18006a1c:	762c      	strb	r4, [r5, #24]
18006a1e:	766c      	strb	r4, [r5, #25]
18006a20:	76ac      	strb	r4, [r5, #26]
18006a22:	f885 4020 	strb.w	r4, [r5, #32]
18006a26:	76ec      	strb	r4, [r5, #27]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
18006a28:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
18006a2a:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 18006ae4 <z_cstart+0xec>
18006a2e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
18006a32:	626b      	str	r3, [r5, #36]	; 0x24
		      SCB_SHCSR_BUSFAULTENA_Msk;
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	/* Enable Secure Fault */
	SCB->SHCSR |= SCB_SHCSR_SECUREFAULTENA_Msk;
18006a34:	6a6b      	ldr	r3, [r5, #36]	; 0x24
18006a36:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
18006a3a:	626b      	str	r3, [r5, #36]	; 0x24
	/* Clear BFAR before setting BusFaults to target Non-Secure state. */
	SCB->BFAR = 0;
18006a3c:	63ac      	str	r4, [r5, #56]	; 0x38
	/* Set NMI, Hard, and Bus Faults as Non-Secure.
	 * NMI and Bus Faults targeting the Secure state will
	 * escalate to a SecureFault or SecureHardFault.
	 */
	SCB->AIRCR =
		(SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk)))
18006a3e:	68eb      	ldr	r3, [r5, #12]
18006a40:	b29b      	uxth	r3, r3
		| SCB_AIRCR_BFHFNMINS_Msk
		| ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos) &
18006a42:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
18006a46:	f443 3308 	orr.w	r3, r3, #139264	; 0x22000
	SCB->AIRCR =
18006a4a:	60eb      	str	r3, [r5, #12]
18006a4c:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
18006a50:	f7fe fd98 	bl	18005584 <z_arm_fault_init>
	z_arm_cpu_idle_init();
18006a54:	f7fe f880 	bl	18004b58 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
18006a58:	f04f 33ff 	mov.w	r3, #4294967295
18006a5c:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
18006a5e:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
18006a60:	f7fe ff92 	bl	18005988 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
18006a64:	f7fe fdf0 	bl	18005648 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
18006a68:	f240 1301 	movw	r3, #257	; 0x101
18006a6c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
18006a70:	ab06      	add	r3, sp, #24
18006a72:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
18006a74:	e9cd 442d 	strd	r4, r4, [sp, #180]	; 0xb4
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
18006a78:	f003 ff90 	bl	1800a99c <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
18006a7c:	4620      	mov	r0, r4
18006a7e:	f7ff feab 	bl	180067d8 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
18006a82:	2001      	movs	r0, #1
18006a84:	f7ff fea8 	bl	180067d8 <z_sys_init_run_level>
	z_sched_init();
18006a88:	f000 fdda 	bl	18007640 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
18006a8c:	4b16      	ldr	r3, [pc, #88]	; (18006ae8 <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
18006a8e:	4d17      	ldr	r5, [pc, #92]	; (18006aec <z_cstart+0xf4>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
18006a90:	9305      	str	r3, [sp, #20]
18006a92:	2301      	movs	r3, #1
18006a94:	4916      	ldr	r1, [pc, #88]	; (18006af0 <z_cstart+0xf8>)
18006a96:	f44f 6280 	mov.w	r2, #1024	; 0x400
18006a9a:	e9cd 4303 	strd	r4, r3, [sp, #12]
18006a9e:	4628      	mov	r0, r5
18006aa0:	464b      	mov	r3, r9
18006aa2:	e9cd 4401 	strd	r4, r4, [sp, #4]
18006aa6:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
18006aa8:	61b5      	str	r5, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
18006aaa:	f000 f8f7 	bl	18006c9c <z_setup_new_thread>
18006aae:	4680      	mov	r8, r0
18006ab0:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
18006ab2:	4628      	mov	r0, r5
18006ab4:	f022 0204 	bic.w	r2, r2, #4
18006ab8:	736a      	strb	r2, [r5, #13]
18006aba:	f004 f870 	bl	1800ab9e <z_ready_thread>
		init_idle_thread(i);
18006abe:	4620      	mov	r0, r4
18006ac0:	f7ff ff42 	bl	18006948 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
18006ac4:	4b0b      	ldr	r3, [pc, #44]	; (18006af4 <z_cstart+0xfc>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
18006ac6:	464a      	mov	r2, r9
18006ac8:	4641      	mov	r1, r8
18006aca:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
18006acc:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
18006ace:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
18006ad0:	6077      	str	r7, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
18006ad2:	f7fe f95d 	bl	18004d90 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
18006ad6:	bf00      	nop
18006ad8:	30182298 	.word	0x30182298
18006adc:	e000ed00 	.word	0xe000ed00
18006ae0:	30180a20 	.word	0x30180a20
18006ae4:	180069b1 	.word	0x180069b1
18006ae8:	1800c6f6 	.word	0x1800c6f6
18006aec:	30180390 	.word	0x30180390
18006af0:	30181d58 	.word	0x30181d58
18006af4:	301802d8 	.word	0x301802d8

18006af8 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
18006af8:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
18006afa:	4b0e      	ldr	r3, [pc, #56]	; (18006b34 <init_mem_slab_module+0x3c>)
18006afc:	4c0e      	ldr	r4, [pc, #56]	; (18006b38 <init_mem_slab_module+0x40>)
18006afe:	42a3      	cmp	r3, r4
18006b00:	d301      	bcc.n	18006b06 <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
18006b02:	2000      	movs	r0, #0
	return rc;
}
18006b04:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
18006b06:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
18006b0a:	ea41 0200 	orr.w	r2, r1, r0
18006b0e:	f012 0203 	ands.w	r2, r2, #3
18006b12:	d10b      	bne.n	18006b2c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
18006b14:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
18006b16:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
18006b18:	42aa      	cmp	r2, r5
18006b1a:	d101      	bne.n	18006b20 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
18006b1c:	331c      	adds	r3, #28
18006b1e:	e7ee      	b.n	18006afe <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
18006b20:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
18006b22:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
18006b24:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
18006b26:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
18006b28:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
18006b2a:	e7f5      	b.n	18006b18 <init_mem_slab_module+0x20>
	return rc;
18006b2c:	f06f 0015 	mvn.w	r0, #21
18006b30:	e7e8      	b.n	18006b04 <init_mem_slab_module+0xc>
18006b32:	bf00      	nop
18006b34:	301800a8 	.word	0x301800a8
18006b38:	301800a8 	.word	0x301800a8

18006b3c <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
18006b3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
18006b3e:	460c      	mov	r4, r1
	__asm__ volatile(
18006b40:	f04f 0520 	mov.w	r5, #32
18006b44:	f3ef 8111 	mrs	r1, BASEPRI
18006b48:	f385 8812 	msr	BASEPRI_MAX, r5
18006b4c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
18006b50:	6945      	ldr	r5, [r0, #20]
18006b52:	b15d      	cbz	r5, 18006b6c <k_mem_slab_alloc+0x30>
		/* take a free block */
		*mem = slab->free_list;
18006b54:	6025      	str	r5, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
18006b56:	682b      	ldr	r3, [r5, #0]
18006b58:	6143      	str	r3, [r0, #20]
		slab->num_used++;
18006b5a:	6983      	ldr	r3, [r0, #24]
18006b5c:	3301      	adds	r3, #1
18006b5e:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
18006b60:	2000      	movs	r0, #0
	__asm__ volatile(
18006b62:	f381 8811 	msr	BASEPRI, r1
18006b66:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
18006b6a:	e011      	b.n	18006b90 <k_mem_slab_alloc+0x54>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
18006b6c:	ea52 0c03 	orrs.w	ip, r2, r3
18006b70:	d103      	bne.n	18006b7a <k_mem_slab_alloc+0x3e>
		result = -ENOMEM;
18006b72:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
18006b76:	6025      	str	r5, [r4, #0]
		result = -ENOMEM;
18006b78:	e7f3      	b.n	18006b62 <k_mem_slab_alloc+0x26>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
18006b7a:	e9cd 2300 	strd	r2, r3, [sp]
18006b7e:	4602      	mov	r2, r0
18006b80:	3008      	adds	r0, #8
18006b82:	f000 fcb3 	bl	180074ec <z_pend_curr>
		if (result == 0) {
18006b86:	b918      	cbnz	r0, 18006b90 <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
18006b88:	4b02      	ldr	r3, [pc, #8]	; (18006b94 <k_mem_slab_alloc+0x58>)
18006b8a:	689b      	ldr	r3, [r3, #8]
18006b8c:	695b      	ldr	r3, [r3, #20]
18006b8e:	6023      	str	r3, [r4, #0]
}
18006b90:	b003      	add	sp, #12
18006b92:	bd30      	pop	{r4, r5, pc}
18006b94:	30180a20 	.word	0x30180a20

18006b98 <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
18006b98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18006b9a:	4605      	mov	r5, r0
18006b9c:	460e      	mov	r6, r1
	__asm__ volatile(
18006b9e:	f04f 0320 	mov.w	r3, #32
18006ba2:	f3ef 8711 	mrs	r7, BASEPRI
18006ba6:	f383 8812 	msr	BASEPRI_MAX, r3
18006baa:	f3bf 8f6f 	isb	sy
	 */
	key = k_spin_lock(&z_thread_monitor_lock);

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, foreach);

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
18006bae:	4b06      	ldr	r3, [pc, #24]	; (18006bc8 <k_thread_foreach+0x30>)
18006bb0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
18006bb2:	b924      	cbnz	r4, 18006bbe <k_thread_foreach+0x26>
	__asm__ volatile(
18006bb4:	f387 8811 	msr	BASEPRI, r7
18006bb8:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, foreach);

	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
18006bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		user_cb(thread, user_data);
18006bbe:	4620      	mov	r0, r4
18006bc0:	4631      	mov	r1, r6
18006bc2:	47a8      	blx	r5
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
18006bc4:	6f64      	ldr	r4, [r4, #116]	; 0x74
18006bc6:	e7f4      	b.n	18006bb2 <k_thread_foreach+0x1a>
18006bc8:	30180a20 	.word	0x30180a20

18006bcc <z_thread_monitor_exit>:
	__asm__ volatile(
18006bcc:	f04f 0320 	mov.w	r3, #32
18006bd0:	f3ef 8111 	mrs	r1, BASEPRI
18006bd4:	f383 8812 	msr	BASEPRI_MAX, r3
18006bd8:	f3bf 8f6f 	isb	sy
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
18006bdc:	4a09      	ldr	r2, [pc, #36]	; (18006c04 <z_thread_monitor_exit+0x38>)
18006bde:	6a53      	ldr	r3, [r2, #36]	; 0x24
18006be0:	4283      	cmp	r3, r0
18006be2:	d107      	bne.n	18006bf4 <z_thread_monitor_exit+0x28>
		_kernel.threads = _kernel.threads->next_thread;
18006be4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
18006be6:	6253      	str	r3, [r2, #36]	; 0x24
	__asm__ volatile(
18006be8:	f381 8811 	msr	BASEPRI, r1
18006bec:	f3bf 8f6f 	isb	sy
			prev_thread->next_thread = thread->next_thread;
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
18006bf0:	4770      	bx	lr
18006bf2:	4613      	mov	r3, r2
		while ((prev_thread != NULL) &&
18006bf4:	2b00      	cmp	r3, #0
18006bf6:	d0f7      	beq.n	18006be8 <z_thread_monitor_exit+0x1c>
			(thread != prev_thread->next_thread)) {
18006bf8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
		while ((prev_thread != NULL) &&
18006bfa:	4282      	cmp	r2, r0
18006bfc:	d1f9      	bne.n	18006bf2 <z_thread_monitor_exit+0x26>
			prev_thread->next_thread = thread->next_thread;
18006bfe:	6f42      	ldr	r2, [r0, #116]	; 0x74
18006c00:	675a      	str	r2, [r3, #116]	; 0x74
18006c02:	e7f1      	b.n	18006be8 <z_thread_monitor_exit+0x1c>
18006c04:	30180a20 	.word	0x30180a20

18006c08 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
18006c08:	b510      	push	{r4, lr}
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
18006c0a:	4604      	mov	r4, r0
18006c0c:	b908      	cbnz	r0, 18006c12 <z_impl_k_thread_name_set+0xa>
		thread = _current;
18006c0e:	4b05      	ldr	r3, [pc, #20]	; (18006c24 <z_impl_k_thread_name_set+0x1c>)
18006c10:	689c      	ldr	r4, [r3, #8]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
18006c12:	2220      	movs	r2, #32
18006c14:	f104 0078 	add.w	r0, r4, #120	; 0x78
18006c18:	f003 fa25 	bl	1800a066 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
18006c1c:	2000      	movs	r0, #0
18006c1e:	f884 0097 	strb.w	r0, [r4, #151]	; 0x97

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
18006c22:	bd10      	pop	{r4, pc}
18006c24:	30180a20 	.word	0x30180a20

18006c28 <k_thread_state_str>:
#endif /* CONFIG_THREAD_NAME */
}

const char *k_thread_state_str(k_tid_t thread_id)
{
	switch (thread_id->base.thread_state) {
18006c28:	7b43      	ldrb	r3, [r0, #13]
18006c2a:	2b10      	cmp	r3, #16
18006c2c:	d80e      	bhi.n	18006c4c <k_thread_state_str+0x24>
18006c2e:	2b10      	cmp	r3, #16
18006c30:	d81c      	bhi.n	18006c6c <k_thread_state_str+0x44>
18006c32:	e8df f003 	tbb	[pc, r3]
18006c36:	091d      	.short	0x091d
18006c38:	1b151b13 	.word	0x1b151b13
18006c3c:	1b171b1b 	.word	0x1b171b1b
18006c40:	1b1b1b1b 	.word	0x1b1b1b1b
18006c44:	1b1b      	.short	0x1b1b
18006c46:	19          	.byte	0x19
18006c47:	00          	.byte	0x00
18006c48:	480b      	ldr	r0, [pc, #44]	; (18006c78 <k_thread_state_str+0x50>)
18006c4a:	4770      	bx	lr
18006c4c:	2b20      	cmp	r3, #32
18006c4e:	d011      	beq.n	18006c74 <k_thread_state_str+0x4c>
	case _THREAD_SUSPENDED:
		return "suspended";
	case _THREAD_ABORTING:
		return "aborting";
	case _THREAD_QUEUED:
		return "queued";
18006c50:	4a0a      	ldr	r2, [pc, #40]	; (18006c7c <k_thread_state_str+0x54>)
18006c52:	480b      	ldr	r0, [pc, #44]	; (18006c80 <k_thread_state_str+0x58>)
18006c54:	2b80      	cmp	r3, #128	; 0x80
18006c56:	bf08      	it	eq
18006c58:	4610      	moveq	r0, r2
18006c5a:	4770      	bx	lr
		return "pending";
18006c5c:	4809      	ldr	r0, [pc, #36]	; (18006c84 <k_thread_state_str+0x5c>)
18006c5e:	4770      	bx	lr
		return "prestart";
18006c60:	4809      	ldr	r0, [pc, #36]	; (18006c88 <k_thread_state_str+0x60>)
18006c62:	4770      	bx	lr
		return "dead";
18006c64:	4809      	ldr	r0, [pc, #36]	; (18006c8c <k_thread_state_str+0x64>)
18006c66:	4770      	bx	lr
		return "suspended";
18006c68:	4809      	ldr	r0, [pc, #36]	; (18006c90 <k_thread_state_str+0x68>)
18006c6a:	4770      	bx	lr
	/* Add a break, some day when another case gets added at the end,
	 * this bit of defensive programming will be useful
	 */
		break;
	}
	return "unknown";
18006c6c:	4804      	ldr	r0, [pc, #16]	; (18006c80 <k_thread_state_str+0x58>)
18006c6e:	4770      	bx	lr
		return "";
18006c70:	4808      	ldr	r0, [pc, #32]	; (18006c94 <k_thread_state_str+0x6c>)
18006c72:	4770      	bx	lr
		return "aborting";
18006c74:	4808      	ldr	r0, [pc, #32]	; (18006c98 <k_thread_state_str+0x70>)
}
18006c76:	4770      	bx	lr
18006c78:	1800ddd3 	.word	0x1800ddd3
18006c7c:	1800dde2 	.word	0x1800dde2
18006c80:	1800dcf6 	.word	0x1800dcf6
18006c84:	1800ddb3 	.word	0x1800ddb3
18006c88:	1800ddbb 	.word	0x1800ddbb
18006c8c:	1800ddc4 	.word	0x1800ddc4
18006c90:	1800ddc9 	.word	0x1800ddc9
18006c94:	1800ccbe 	.word	0x1800ccbe
18006c98:	1800ddd9 	.word	0x1800ddd9

18006c9c <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
18006c9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18006ca0:	460e      	mov	r6, r1
18006ca2:	b085      	sub	sp, #20
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
18006ca4:	f100 0158 	add.w	r1, r0, #88	; 0x58
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
18006ca8:	e9c0 1116 	strd	r1, r1, [r0, #88]	; 0x58
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
18006cac:	9912      	ldr	r1, [sp, #72]	; 0x48
	thread_base->pended_on = NULL;
18006cae:	2500      	movs	r5, #0
	thread_base->user_options = (uint8_t)options;
18006cb0:	7301      	strb	r1, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
18006cb2:	2104      	movs	r1, #4
{
18006cb4:	4604      	mov	r4, r0
18006cb6:	4699      	mov	r9, r3
	thread_base->thread_state = (uint8_t)initial_state;
18006cb8:	7341      	strb	r1, [r0, #13]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
18006cba:	3207      	adds	r2, #7

	thread_base->prio = priority;
18006cbc:	9911      	ldr	r1, [sp, #68]	; 0x44
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
18006cbe:	f022 0a07 	bic.w	sl, r2, #7
	memset(stack_buf_start, 0xaa, stack_buf_size);
18006cc2:	4652      	mov	r2, sl
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
18006cc4:	e9c0 5506 	strd	r5, r5, [r0, #24]
	thread_base->pended_on = NULL;
18006cc8:	6085      	str	r5, [r0, #8]
	thread_base->prio = priority;
18006cca:	7381      	strb	r1, [r0, #14]

	thread_base->sched_locked = 0U;
18006ccc:	73c5      	strb	r5, [r0, #15]
	memset(stack_buf_start, 0xaa, stack_buf_size);
18006cce:	21aa      	movs	r1, #170	; 0xaa
18006cd0:	4630      	mov	r0, r6
{
18006cd2:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
18006cd6:	9f13      	ldr	r7, [sp, #76]	; 0x4c
	memset(stack_buf_start, 0xaa, stack_buf_size);
18006cd8:	f003 fa46 	bl	1800a168 <memset>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
18006cdc:	9b10      	ldr	r3, [sp, #64]	; 0x40
	stack_ptr = (char *)stack + stack_obj_size;
18006cde:	eb06 080a 	add.w	r8, r6, sl
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
18006ce2:	9302      	str	r3, [sp, #8]
18006ce4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
18006ce6:	4642      	mov	r2, r8
18006ce8:	e9cd b300 	strd	fp, r3, [sp]
18006cec:	4631      	mov	r1, r6
18006cee:	464b      	mov	r3, r9
18006cf0:	4620      	mov	r0, r4
	new_thread->stack_info.size = stack_buf_size;
18006cf2:	e9c4 6a27 	strd	r6, sl, [r4, #156]	; 0x9c
	new_thread->stack_info.delta = delta;
18006cf6:	f8c4 50a4 	str.w	r5, [r4, #164]	; 0xa4
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
18006cfa:	f7fe f82d 	bl	18004d58 <arch_new_thread>
	new_thread->entry.parameter2 = p2;
18006cfe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	new_thread->entry.parameter1 = p1;
18006d00:	e9c4 9b19 	strd	r9, fp, [r4, #100]	; 0x64
	new_thread->entry.parameter2 = p2;
18006d04:	66e3      	str	r3, [r4, #108]	; 0x6c
	new_thread->entry.parameter3 = p3;
18006d06:	9b10      	ldr	r3, [sp, #64]	; 0x40
	new_thread->init_data = NULL;
18006d08:	6565      	str	r5, [r4, #84]	; 0x54
	new_thread->entry.parameter3 = p3;
18006d0a:	6723      	str	r3, [r4, #112]	; 0x70
	__asm__ volatile(
18006d0c:	f04f 0220 	mov.w	r2, #32
18006d10:	f3ef 8311 	mrs	r3, BASEPRI
18006d14:	f382 8812 	msr	BASEPRI_MAX, r2
18006d18:	f3bf 8f6f 	isb	sy
	new_thread->next_thread = _kernel.threads;
18006d1c:	4e0e      	ldr	r6, [pc, #56]	; (18006d58 <z_setup_new_thread+0xbc>)
18006d1e:	6a72      	ldr	r2, [r6, #36]	; 0x24
	_kernel.threads = new_thread;
18006d20:	6274      	str	r4, [r6, #36]	; 0x24
	new_thread->next_thread = _kernel.threads;
18006d22:	6762      	str	r2, [r4, #116]	; 0x74
	__asm__ volatile(
18006d24:	f383 8811 	msr	BASEPRI, r3
18006d28:	f3bf 8f6f 	isb	sy
	if (name != NULL) {
18006d2c:	b18f      	cbz	r7, 18006d52 <z_setup_new_thread+0xb6>
		strncpy(new_thread->name, name,
18006d2e:	221f      	movs	r2, #31
18006d30:	4639      	mov	r1, r7
18006d32:	f104 0078 	add.w	r0, r4, #120	; 0x78
18006d36:	f003 f996 	bl	1800a066 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
18006d3a:	f884 5097 	strb.w	r5, [r4, #151]	; 0x97
	if (!_current) {
18006d3e:	68b3      	ldr	r3, [r6, #8]
18006d40:	b10b      	cbz	r3, 18006d46 <z_setup_new_thread+0xaa>
	new_thread->resource_pool = _current->resource_pool;
18006d42:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
}
18006d46:	4640      	mov	r0, r8
18006d48:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
18006d4c:	b005      	add	sp, #20
18006d4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		new_thread->name[0] = '\0';
18006d52:	f884 7078 	strb.w	r7, [r4, #120]	; 0x78
18006d56:	e7f2      	b.n	18006d3e <z_setup_new_thread+0xa2>
18006d58:	30180a20 	.word	0x30180a20

18006d5c <z_impl_k_thread_create>:
{
18006d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
18006d5e:	2700      	movs	r7, #0
{
18006d60:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
18006d62:	9705      	str	r7, [sp, #20]
18006d64:	9f10      	ldr	r7, [sp, #64]	; 0x40
{
18006d66:	e9dd 6512 	ldrd	r6, r5, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
18006d6a:	9704      	str	r7, [sp, #16]
18006d6c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
{
18006d6e:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
18006d70:	9703      	str	r7, [sp, #12]
18006d72:	9f0e      	ldr	r7, [sp, #56]	; 0x38
18006d74:	9702      	str	r7, [sp, #8]
18006d76:	9f0d      	ldr	r7, [sp, #52]	; 0x34
18006d78:	9701      	str	r7, [sp, #4]
18006d7a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
18006d7c:	9700      	str	r7, [sp, #0]
18006d7e:	f7ff ff8d 	bl	18006c9c <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
18006d82:	f1b5 3fff 	cmp.w	r5, #4294967295
18006d86:	bf08      	it	eq
18006d88:	f1b6 3fff 	cmpeq.w	r6, #4294967295
18006d8c:	d005      	beq.n	18006d9a <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
18006d8e:	ea55 0306 	orrs.w	r3, r5, r6
18006d92:	d105      	bne.n	18006da0 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
18006d94:	4620      	mov	r0, r4
18006d96:	f000 fb4d 	bl	18007434 <z_sched_start>
}
18006d9a:	4620      	mov	r0, r4
18006d9c:	b007      	add	sp, #28
18006d9e:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
18006da0:	4632      	mov	r2, r6
18006da2:	462b      	mov	r3, r5
18006da4:	4902      	ldr	r1, [pc, #8]	; (18006db0 <z_impl_k_thread_create+0x54>)
18006da6:	f104 0018 	add.w	r0, r4, #24
18006daa:	f000 fdd9 	bl	18007960 <z_add_timeout>
18006dae:	e7f4      	b.n	18006d9a <z_impl_k_thread_create+0x3e>
18006db0:	1800abbf 	.word	0x1800abbf

18006db4 <z_init_static_threads>:
{
18006db4:	b5f0      	push	{r4, r5, r6, r7, lr}
18006db6:	4c22      	ldr	r4, [pc, #136]	; (18006e40 <z_init_static_threads+0x8c>)
	_FOREACH_STATIC_THREAD(thread_data) {
18006db8:	4d22      	ldr	r5, [pc, #136]	; (18006e44 <z_init_static_threads+0x90>)
{
18006dba:	b087      	sub	sp, #28
18006dbc:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
18006dbe:	42ae      	cmp	r6, r5
18006dc0:	f104 0430 	add.w	r4, r4, #48	; 0x30
18006dc4:	d30b      	bcc.n	18006dde <z_init_static_threads+0x2a>
	k_sched_lock();
18006dc6:	f000 fa51 	bl	1800726c <k_sched_lock>
18006dca:	260a      	movs	r6, #10
	_FOREACH_STATIC_THREAD(thread_data) {
18006dcc:	4c1c      	ldr	r4, [pc, #112]	; (18006e40 <z_init_static_threads+0x8c>)
18006dce:	4f1e      	ldr	r7, [pc, #120]	; (18006e48 <z_init_static_threads+0x94>)
18006dd0:	42ac      	cmp	r4, r5
18006dd2:	d320      	bcc.n	18006e16 <z_init_static_threads+0x62>
}
18006dd4:	b007      	add	sp, #28
18006dd6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
18006dda:	f000 bc15 	b.w	18007608 <k_sched_unlock>
		z_setup_new_thread(
18006dde:	f854 3c04 	ldr.w	r3, [r4, #-4]
18006de2:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
18006de6:	9305      	str	r3, [sp, #20]
18006de8:	f854 3c10 	ldr.w	r3, [r4, #-16]
18006dec:	9304      	str	r3, [sp, #16]
18006dee:	f854 3c14 	ldr.w	r3, [r4, #-20]
18006df2:	9303      	str	r3, [sp, #12]
18006df4:	f854 3c18 	ldr.w	r3, [r4, #-24]
18006df8:	9302      	str	r3, [sp, #8]
18006dfa:	f854 3c1c 	ldr.w	r3, [r4, #-28]
18006dfe:	9301      	str	r3, [sp, #4]
18006e00:	f854 3c20 	ldr.w	r3, [r4, #-32]
18006e04:	9300      	str	r3, [sp, #0]
18006e06:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
18006e0a:	f7ff ff47 	bl	18006c9c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
18006e0e:	f854 3c30 	ldr.w	r3, [r4, #-48]
18006e12:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
18006e14:	e7d2      	b.n	18006dbc <z_init_static_threads+0x8>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
18006e16:	6a62      	ldr	r2, [r4, #36]	; 0x24
18006e18:	1c53      	adds	r3, r2, #1
18006e1a:	d009      	beq.n	18006e30 <z_init_static_threads+0x7c>
					    K_MSEC(thread_data->init_delay));
18006e1c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
18006e20:	fb82 2306 	smull	r2, r3, r2, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
18006e24:	ea52 0103 	orrs.w	r1, r2, r3
			schedule_new_thread(thread_data->init_thread,
18006e28:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
18006e2a:	d103      	bne.n	18006e34 <z_init_static_threads+0x80>
	z_sched_start(thread);
18006e2c:	f000 fb02 	bl	18007434 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
18006e30:	3430      	adds	r4, #48	; 0x30
18006e32:	e7cd      	b.n	18006dd0 <z_init_static_threads+0x1c>
18006e34:	4639      	mov	r1, r7
18006e36:	3018      	adds	r0, #24
18006e38:	f000 fd92 	bl	18007960 <z_add_timeout>
18006e3c:	e7f8      	b.n	18006e30 <z_init_static_threads+0x7c>
18006e3e:	bf00      	nop
18006e40:	301800a8 	.word	0x301800a8
18006e44:	301800a8 	.word	0x301800a8
18006e48:	1800abbf 	.word	0x1800abbf

18006e4c <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
18006e4c:	4800      	ldr	r0, [pc, #0]	; (18006e50 <sys_kernel_version_get+0x4>)
18006e4e:	4770      	bx	lr
18006e50:	02076300 	.word	0x02076300

18006e54 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
18006e54:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
18006e58:	4604      	mov	r4, r0
18006e5a:	460e      	mov	r6, r1

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
18006e5c:	f100 0808 	add.w	r8, r0, #8
	__asm__ volatile(
18006e60:	f04f 0120 	mov.w	r1, #32
18006e64:	f3ef 8711 	mrs	r7, BASEPRI
18006e68:	f381 8812 	msr	BASEPRI_MAX, r1
18006e6c:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
18006e70:	6a05      	ldr	r5, [r0, #32]
18006e72:	68c1      	ldr	r1, [r0, #12]
18006e74:	428d      	cmp	r5, r1
18006e76:	d232      	bcs.n	18006ede <z_impl_k_msgq_put+0x8a>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
18006e78:	f003 ff02 	bl	1800ac80 <z_unpend_first_thread>
		if (pending_thread != NULL) {
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
18006e7c:	4631      	mov	r1, r6
		if (pending_thread != NULL) {
18006e7e:	4605      	mov	r5, r0
			(void)memcpy(pending_thread->base.swap_data, data,
18006e80:	68a2      	ldr	r2, [r4, #8]
		if (pending_thread != NULL) {
18006e82:	b180      	cbz	r0, 18006ea6 <z_impl_k_msgq_put+0x52>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
18006e84:	2400      	movs	r4, #0
			(void)memcpy(pending_thread->base.swap_data, data,
18006e86:	6940      	ldr	r0, [r0, #20]
18006e88:	f003 f963 	bl	1800a152 <memcpy>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
18006e8c:	4628      	mov	r0, r5
18006e8e:	f8c5 40b0 	str.w	r4, [r5, #176]	; 0xb0
18006e92:	f003 fe84 	bl	1800ab9e <z_ready_thread>
			z_reschedule(&msgq->lock, key);
18006e96:	4640      	mov	r0, r8
18006e98:	4639      	mov	r1, r7
18006e9a:	f000 f9d5 	bl	18007248 <z_reschedule>
			return 0;
18006e9e:	4620      	mov	r0, r4
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
18006ea0:	b002      	add	sp, #8
18006ea2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
18006ea6:	69e0      	ldr	r0, [r4, #28]
18006ea8:	f003 f953 	bl	1800a152 <memcpy>
			msgq->write_ptr += msgq->msg_size;
18006eac:	69e3      	ldr	r3, [r4, #28]
18006eae:	68a2      	ldr	r2, [r4, #8]
	z_handle_obj_poll_events(&msgq->poll_events, state);
18006eb0:	f104 0024 	add.w	r0, r4, #36	; 0x24
			msgq->write_ptr += msgq->msg_size;
18006eb4:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
18006eb6:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
18006eb8:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
18006eba:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
18006ebc:	bf08      	it	eq
18006ebe:	6923      	ldreq	r3, [r4, #16]
	z_handle_obj_poll_events(&msgq->poll_events, state);
18006ec0:	f04f 0110 	mov.w	r1, #16
				msgq->write_ptr = msgq->buffer_start;
18006ec4:	bf08      	it	eq
18006ec6:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
18006ec8:	6a23      	ldr	r3, [r4, #32]
18006eca:	3301      	adds	r3, #1
18006ecc:	6223      	str	r3, [r4, #32]
	z_handle_obj_poll_events(&msgq->poll_events, state);
18006ece:	f004 f8ad 	bl	1800b02c <z_handle_obj_poll_events>
		result = 0;
18006ed2:	2000      	movs	r0, #0
	__asm__ volatile(
18006ed4:	f387 8811 	msr	BASEPRI, r7
18006ed8:	f3bf 8f6f 	isb	sy
	return result;
18006edc:	e7e0      	b.n	18006ea0 <z_impl_k_msgq_put+0x4c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
18006ede:	ea52 0103 	orrs.w	r1, r2, r3
18006ee2:	d00a      	beq.n	18006efa <z_impl_k_msgq_put+0xa6>
		_current->base.swap_data = (void *) data;
18006ee4:	4906      	ldr	r1, [pc, #24]	; (18006f00 <z_impl_k_msgq_put+0xac>)
18006ee6:	6889      	ldr	r1, [r1, #8]
18006ee8:	614e      	str	r6, [r1, #20]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
18006eea:	e9cd 2300 	strd	r2, r3, [sp]
18006eee:	4639      	mov	r1, r7
18006ef0:	4602      	mov	r2, r0
18006ef2:	4640      	mov	r0, r8
18006ef4:	f000 fafa 	bl	180074ec <z_pend_curr>
		return result;
18006ef8:	e7d2      	b.n	18006ea0 <z_impl_k_msgq_put+0x4c>
		result = -ENOMSG;
18006efa:	f06f 0022 	mvn.w	r0, #34	; 0x22
18006efe:	e7e9      	b.n	18006ed4 <z_impl_k_msgq_put+0x80>
18006f00:	30180a20 	.word	0x30180a20

18006f04 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
18006f04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
18006f06:	4604      	mov	r4, r0
18006f08:	4608      	mov	r0, r1

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
18006f0a:	f104 0708 	add.w	r7, r4, #8
	__asm__ volatile(
18006f0e:	f04f 0120 	mov.w	r1, #32
18006f12:	f3ef 8611 	mrs	r6, BASEPRI
18006f16:	f381 8812 	msr	BASEPRI_MAX, r1
18006f1a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
18006f1e:	6a21      	ldr	r1, [r4, #32]
18006f20:	2900      	cmp	r1, #0
18006f22:	d032      	beq.n	18006f8a <z_impl_k_msgq_get+0x86>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
18006f24:	68a2      	ldr	r2, [r4, #8]
18006f26:	69a1      	ldr	r1, [r4, #24]
18006f28:	f003 f913 	bl	1800a152 <memcpy>
		msgq->read_ptr += msgq->msg_size;
18006f2c:	69a3      	ldr	r3, [r4, #24]
18006f2e:	68a2      	ldr	r2, [r4, #8]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
18006f30:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
18006f32:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
18006f34:	6962      	ldr	r2, [r4, #20]
		msgq->read_ptr += msgq->msg_size;
18006f36:	61a3      	str	r3, [r4, #24]
		if (msgq->read_ptr == msgq->buffer_end) {
18006f38:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
18006f3a:	bf04      	itt	eq
18006f3c:	6923      	ldreq	r3, [r4, #16]
18006f3e:	61a3      	streq	r3, [r4, #24]
		msgq->used_msgs--;
18006f40:	6a23      	ldr	r3, [r4, #32]
18006f42:	3b01      	subs	r3, #1
18006f44:	6223      	str	r3, [r4, #32]
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
18006f46:	f003 fe9b 	bl	1800ac80 <z_unpend_first_thread>
		if (pending_thread != NULL) {
18006f4a:	4605      	mov	r5, r0
18006f4c:	b368      	cbz	r0, 18006faa <z_impl_k_msgq_get+0xa6>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
18006f4e:	6941      	ldr	r1, [r0, #20]
18006f50:	68a2      	ldr	r2, [r4, #8]
18006f52:	69e0      	ldr	r0, [r4, #28]
18006f54:	f003 f8fd 	bl	1800a152 <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
18006f58:	69e3      	ldr	r3, [r4, #28]
18006f5a:	68a2      	ldr	r2, [r4, #8]
			}
			msgq->used_msgs++;

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
18006f5c:	4628      	mov	r0, r5
			msgq->write_ptr += msgq->msg_size;
18006f5e:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
18006f60:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
18006f62:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
18006f64:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
18006f66:	bf04      	itt	eq
18006f68:	6923      	ldreq	r3, [r4, #16]
18006f6a:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
18006f6c:	6a23      	ldr	r3, [r4, #32]
18006f6e:	3301      	adds	r3, #1
18006f70:	6223      	str	r3, [r4, #32]
18006f72:	2400      	movs	r4, #0
18006f74:	f8c5 40b0 	str.w	r4, [r5, #176]	; 0xb0
			z_ready_thread(pending_thread);
18006f78:	f003 fe11 	bl	1800ab9e <z_ready_thread>
			z_reschedule(&msgq->lock, key);
18006f7c:	4638      	mov	r0, r7
18006f7e:	4631      	mov	r1, r6
18006f80:	f000 f962 	bl	18007248 <z_reschedule>

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
18006f84:	4620      	mov	r0, r4
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
18006f86:	b003      	add	sp, #12
18006f88:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
18006f8a:	ea52 0103 	orrs.w	r1, r2, r3
18006f8e:	d00a      	beq.n	18006fa6 <z_impl_k_msgq_get+0xa2>
		_current->base.swap_data = data;
18006f90:	4908      	ldr	r1, [pc, #32]	; (18006fb4 <z_impl_k_msgq_get+0xb0>)
18006f92:	6889      	ldr	r1, [r1, #8]
18006f94:	6148      	str	r0, [r1, #20]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
18006f96:	e9cd 2300 	strd	r2, r3, [sp]
18006f9a:	4631      	mov	r1, r6
18006f9c:	4622      	mov	r2, r4
18006f9e:	4638      	mov	r0, r7
18006fa0:	f000 faa4 	bl	180074ec <z_pend_curr>
		return result;
18006fa4:	e7ef      	b.n	18006f86 <z_impl_k_msgq_get+0x82>
		result = -ENOMSG;
18006fa6:	f06f 0022 	mvn.w	r0, #34	; 0x22
	__asm__ volatile(
18006faa:	f386 8811 	msr	BASEPRI, r6
18006fae:	f3bf 8f6f 	isb	sy
	return result;
18006fb2:	e7e8      	b.n	18006f86 <z_impl_k_msgq_get+0x82>
18006fb4:	30180a20 	.word	0x30180a20

18006fb8 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
18006fb8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
18006fbc:	4604      	mov	r4, r0
18006fbe:	4617      	mov	r7, r2
18006fc0:	461e      	mov	r6, r3
	__asm__ volatile(
18006fc2:	f04f 0320 	mov.w	r3, #32
18006fc6:	f3ef 8811 	mrs	r8, BASEPRI
18006fca:	f383 8812 	msr	BASEPRI_MAX, r3
18006fce:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
18006fd2:	68c3      	ldr	r3, [r0, #12]
18006fd4:	4a32      	ldr	r2, [pc, #200]	; (180070a0 <z_impl_k_mutex_lock+0xe8>)
18006fd6:	b16b      	cbz	r3, 18006ff4 <z_impl_k_mutex_lock+0x3c>
18006fd8:	6880      	ldr	r0, [r0, #8]
18006fda:	6891      	ldr	r1, [r2, #8]
18006fdc:	4288      	cmp	r0, r1
18006fde:	d019      	beq.n	18007014 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
18006fe0:	ea57 0306 	orrs.w	r3, r7, r6
18006fe4:	d118      	bne.n	18007018 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
18006fe6:	f388 8811 	msr	BASEPRI, r8
18006fea:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
18006fee:	f06f 000f 	mvn.w	r0, #15
18006ff2:	e00c      	b.n	1800700e <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
18006ff4:	6891      	ldr	r1, [r2, #8]
18006ff6:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
18006ffa:	3301      	adds	r3, #1
18006ffc:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
18006ffe:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
18007000:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
18007002:	60a3      	str	r3, [r4, #8]
18007004:	f388 8811 	msr	BASEPRI, r8
18007008:	f3bf 8f6f 	isb	sy
		return 0;
1800700c:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
1800700e:	b002      	add	sp, #8
18007010:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
18007014:	6921      	ldr	r1, [r4, #16]
18007016:	e7f0      	b.n	18006ffa <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
18007018:	f991 100e 	ldrsb.w	r1, [r1, #14]
1800701c:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
18007020:	f06f 027e 	mvn.w	r2, #126	; 0x7e
18007024:	4299      	cmp	r1, r3
18007026:	bfa8      	it	ge
18007028:	4619      	movge	r1, r3
1800702a:	4291      	cmp	r1, r2
1800702c:	bfb8      	it	lt
1800702e:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
18007030:	428b      	cmp	r3, r1
18007032:	dd2e      	ble.n	18007092 <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
18007034:	f003 fd49 	bl	1800aaca <adjust_owner_prio.isra.0>
18007038:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
1800703a:	4622      	mov	r2, r4
1800703c:	4641      	mov	r1, r8
1800703e:	e9cd 7600 	strd	r7, r6, [sp]
18007042:	4818      	ldr	r0, [pc, #96]	; (180070a4 <z_impl_k_mutex_lock+0xec>)
18007044:	f000 fa52 	bl	180074ec <z_pend_curr>
	if (got_mutex == 0) {
18007048:	2800      	cmp	r0, #0
1800704a:	d0e0      	beq.n	1800700e <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
1800704c:	f04f 0320 	mov.w	r3, #32
18007050:	f3ef 8611 	mrs	r6, BASEPRI
18007054:	f383 8812 	msr	BASEPRI_MAX, r3
18007058:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
1800705c:	6823      	ldr	r3, [r4, #0]
1800705e:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
18007060:	429c      	cmp	r4, r3
18007062:	d00a      	beq.n	1800707a <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
18007064:	b14b      	cbz	r3, 1800707a <z_impl_k_mutex_lock+0xc2>
18007066:	f993 300e 	ldrsb.w	r3, [r3, #14]
1800706a:	4299      	cmp	r1, r3
1800706c:	bfa8      	it	ge
1800706e:	4619      	movge	r1, r3
18007070:	f06f 037e 	mvn.w	r3, #126	; 0x7e
18007074:	4299      	cmp	r1, r3
18007076:	bfb8      	it	lt
18007078:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
1800707a:	68a0      	ldr	r0, [r4, #8]
1800707c:	f003 fd25 	bl	1800aaca <adjust_owner_prio.isra.0>
18007080:	b900      	cbnz	r0, 18007084 <z_impl_k_mutex_lock+0xcc>
	if (resched) {
18007082:	b145      	cbz	r5, 18007096 <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
18007084:	4631      	mov	r1, r6
18007086:	4807      	ldr	r0, [pc, #28]	; (180070a4 <z_impl_k_mutex_lock+0xec>)
18007088:	f000 f8de 	bl	18007248 <z_reschedule>
	return -EAGAIN;
1800708c:	f06f 000a 	mvn.w	r0, #10
18007090:	e7bd      	b.n	1800700e <z_impl_k_mutex_lock+0x56>
	bool resched = false;
18007092:	2500      	movs	r5, #0
18007094:	e7d1      	b.n	1800703a <z_impl_k_mutex_lock+0x82>
	__asm__ volatile(
18007096:	f386 8811 	msr	BASEPRI, r6
1800709a:	f3bf 8f6f 	isb	sy
1800709e:	e7f5      	b.n	1800708c <z_impl_k_mutex_lock+0xd4>
180070a0:	30180a20 	.word	0x30180a20
180070a4:	30180a88 	.word	0x30180a88

180070a8 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
180070a8:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
180070aa:	6883      	ldr	r3, [r0, #8]
{
180070ac:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
180070ae:	2b00      	cmp	r3, #0
180070b0:	d033      	beq.n	1800711a <z_impl_k_mutex_unlock+0x72>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
180070b2:	4a1d      	ldr	r2, [pc, #116]	; (18007128 <z_impl_k_mutex_unlock+0x80>)
180070b4:	6892      	ldr	r2, [r2, #8]
180070b6:	4293      	cmp	r3, r2
180070b8:	d132      	bne.n	18007120 <z_impl_k_mutex_unlock+0x78>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
180070ba:	7bda      	ldrb	r2, [r3, #15]
180070bc:	3a01      	subs	r2, #1
180070be:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
180070c0:	68c3      	ldr	r3, [r0, #12]
180070c2:	2b01      	cmp	r3, #1
180070c4:	d905      	bls.n	180070d2 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
180070c6:	3b01      	subs	r3, #1
180070c8:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
180070ca:	f000 fa9d 	bl	18007608 <k_sched_unlock>

	return 0;
180070ce:	2000      	movs	r0, #0
}
180070d0:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
180070d2:	f04f 0320 	mov.w	r3, #32
180070d6:	f3ef 8511 	mrs	r5, BASEPRI
180070da:	f383 8812 	msr	BASEPRI_MAX, r3
180070de:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
180070e2:	6901      	ldr	r1, [r0, #16]
180070e4:	6880      	ldr	r0, [r0, #8]
180070e6:	f003 fcf0 	bl	1800aaca <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
180070ea:	4620      	mov	r0, r4
180070ec:	f003 fdc8 	bl	1800ac80 <z_unpend_first_thread>
	mutex->owner = new_owner;
180070f0:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
180070f2:	b160      	cbz	r0, 1800710e <z_impl_k_mutex_unlock+0x66>
		mutex->owner_orig_prio = new_owner->base.prio;
180070f4:	f990 200e 	ldrsb.w	r2, [r0, #14]
180070f8:	6122      	str	r2, [r4, #16]
180070fa:	2200      	movs	r2, #0
180070fc:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
		z_ready_thread(new_owner);
18007100:	f003 fd4d 	bl	1800ab9e <z_ready_thread>
		z_reschedule(&lock, key);
18007104:	4629      	mov	r1, r5
18007106:	4809      	ldr	r0, [pc, #36]	; (1800712c <z_impl_k_mutex_unlock+0x84>)
18007108:	f000 f89e 	bl	18007248 <z_reschedule>
1800710c:	e7dd      	b.n	180070ca <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
1800710e:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
18007110:	f385 8811 	msr	BASEPRI, r5
18007114:	f3bf 8f6f 	isb	sy
18007118:	e7d7      	b.n	180070ca <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
1800711a:	f06f 0015 	mvn.w	r0, #21
1800711e:	e7d7      	b.n	180070d0 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
18007120:	f04f 30ff 	mov.w	r0, #4294967295
18007124:	e7d4      	b.n	180070d0 <z_impl_k_mutex_unlock+0x28>
18007126:	bf00      	nop
18007128:	30180a20 	.word	0x30180a20
1800712c:	30180a88 	.word	0x30180a88

18007130 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
18007130:	b538      	push	{r3, r4, r5, lr}
18007132:	4604      	mov	r4, r0
	__asm__ volatile(
18007134:	f04f 0320 	mov.w	r3, #32
18007138:	f3ef 8511 	mrs	r5, BASEPRI
1800713c:	f383 8812 	msr	BASEPRI_MAX, r3
18007140:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
18007144:	f003 fd9c 	bl	1800ac80 <z_unpend_first_thread>

	if (thread != NULL) {
18007148:	b150      	cbz	r0, 18007160 <z_impl_k_sem_give+0x30>
1800714a:	2200      	movs	r2, #0
1800714c:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
18007150:	f003 fd25 	bl	1800ab9e <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
18007154:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
18007156:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
1800715a:	4807      	ldr	r0, [pc, #28]	; (18007178 <z_impl_k_sem_give+0x48>)
1800715c:	f000 b874 	b.w	18007248 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
18007160:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
18007164:	429a      	cmp	r2, r3
18007166:	bf18      	it	ne
18007168:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
1800716a:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
1800716c:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
1800716e:	f104 0010 	add.w	r0, r4, #16
18007172:	f003 ff5b 	bl	1800b02c <z_handle_obj_poll_events>
}
18007176:	e7ed      	b.n	18007154 <z_impl_k_sem_give+0x24>
18007178:	30180a88 	.word	0x30180a88

1800717c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
1800717c:	b513      	push	{r0, r1, r4, lr}
1800717e:	f04f 0420 	mov.w	r4, #32
18007182:	f3ef 8111 	mrs	r1, BASEPRI
18007186:	f384 8812 	msr	BASEPRI_MAX, r4
1800718a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
1800718e:	6884      	ldr	r4, [r0, #8]
18007190:	b144      	cbz	r4, 180071a4 <z_impl_k_sem_take+0x28>
		sem->count--;
18007192:	3c01      	subs	r4, #1
18007194:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
18007196:	f381 8811 	msr	BASEPRI, r1
1800719a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
1800719e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
180071a0:	b002      	add	sp, #8
180071a2:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
180071a4:	ea52 0403 	orrs.w	r4, r2, r3
180071a8:	d106      	bne.n	180071b8 <z_impl_k_sem_take+0x3c>
180071aa:	f381 8811 	msr	BASEPRI, r1
180071ae:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
180071b2:	f06f 000f 	mvn.w	r0, #15
180071b6:	e7f3      	b.n	180071a0 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
180071b8:	e9cd 2300 	strd	r2, r3, [sp]
180071bc:	4602      	mov	r2, r0
180071be:	4802      	ldr	r0, [pc, #8]	; (180071c8 <z_impl_k_sem_take+0x4c>)
180071c0:	f000 f994 	bl	180074ec <z_pend_curr>
	return ret;
180071c4:	e7ec      	b.n	180071a0 <z_impl_k_sem_take+0x24>
180071c6:	bf00      	nop
180071c8:	30180a88 	.word	0x30180a88

180071cc <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
180071cc:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
180071ce:	4c08      	ldr	r4, [pc, #32]	; (180071f0 <z_reset_time_slice+0x24>)
180071d0:	6823      	ldr	r3, [r4, #0]
180071d2:	b15b      	cbz	r3, 180071ec <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
180071d4:	f7fe fd62 	bl	18005c9c <sys_clock_elapsed>
180071d8:	4603      	mov	r3, r0
180071da:	6820      	ldr	r0, [r4, #0]
180071dc:	4a05      	ldr	r2, [pc, #20]	; (180071f4 <z_reset_time_slice+0x28>)
180071de:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
180071e0:	2100      	movs	r1, #0
	}
}
180071e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
180071e6:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
180071e8:	f003 bd96 	b.w	1800ad18 <z_set_timeout_expiry>
}
180071ec:	bd10      	pop	{r4, pc}
180071ee:	bf00      	nop
180071f0:	30180a50 	.word	0x30180a50
180071f4:	30180a20 	.word	0x30180a20

180071f8 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
180071f8:	b510      	push	{r4, lr}
	__asm__ volatile(
180071fa:	f04f 0320 	mov.w	r3, #32
180071fe:	f3ef 8411 	mrs	r4, BASEPRI
18007202:	f383 8812 	msr	BASEPRI_MAX, r3
18007206:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
1800720a:	2200      	movs	r2, #0
1800720c:	4b0b      	ldr	r3, [pc, #44]	; (1800723c <k_sched_time_slice_set+0x44>)
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
1800720e:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
18007210:	611a      	str	r2, [r3, #16]
			return ((uint32_t)t) * (to_hz / from_hz);
18007212:	f04f 030a 	mov.w	r3, #10
18007216:	4a0a      	ldr	r2, [pc, #40]	; (18007240 <k_sched_time_slice_set+0x48>)
18007218:	fb00 f303 	mul.w	r3, r0, r3
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
1800721c:	dc09      	bgt.n	18007232 <k_sched_time_slice_set+0x3a>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
1800721e:	6013      	str	r3, [r2, #0]
		}
		slice_max_prio = prio;
18007220:	4b08      	ldr	r3, [pc, #32]	; (18007244 <k_sched_time_slice_set+0x4c>)
18007222:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
18007224:	f7ff ffd2 	bl	180071cc <z_reset_time_slice>
	__asm__ volatile(
18007228:	f384 8811 	msr	BASEPRI, r4
1800722c:	f3bf 8f6f 	isb	sy
	}
}
18007230:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
18007232:	2b02      	cmp	r3, #2
18007234:	bfb8      	it	lt
18007236:	2302      	movlt	r3, #2
18007238:	e7f1      	b.n	1800721e <k_sched_time_slice_set+0x26>
1800723a:	bf00      	nop
1800723c:	30180a20 	.word	0x30180a20
18007240:	30180a50 	.word	0x30180a50
18007244:	30180a4c 	.word	0x30180a4c

18007248 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
18007248:	b949      	cbnz	r1, 1800725e <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1800724a:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
1800724e:	b930      	cbnz	r0, 1800725e <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
18007250:	4b05      	ldr	r3, [pc, #20]	; (18007268 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
18007252:	699a      	ldr	r2, [r3, #24]
18007254:	689b      	ldr	r3, [r3, #8]
18007256:	429a      	cmp	r2, r3
18007258:	d001      	beq.n	1800725e <z_reschedule+0x16>
	ret = arch_swap(key);
1800725a:	f7fd bd23 	b.w	18004ca4 <arch_swap>
1800725e:	f381 8811 	msr	BASEPRI, r1
18007262:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
18007266:	4770      	bx	lr
18007268:	30180a20 	.word	0x30180a20

1800726c <k_sched_lock>:
	__asm__ volatile(
1800726c:	f04f 0320 	mov.w	r3, #32
18007270:	f3ef 8111 	mrs	r1, BASEPRI
18007274:	f383 8812 	msr	BASEPRI_MAX, r3
18007278:	f3bf 8f6f 	isb	sy
1800727c:	4b04      	ldr	r3, [pc, #16]	; (18007290 <k_sched_lock+0x24>)
1800727e:	689a      	ldr	r2, [r3, #8]
18007280:	7bd3      	ldrb	r3, [r2, #15]
18007282:	3b01      	subs	r3, #1
18007284:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
18007286:	f381 8811 	msr	BASEPRI, r1
1800728a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
1800728e:	4770      	bx	lr
18007290:	30180a20 	.word	0x30180a20

18007294 <update_cache>:
{
18007294:	b538      	push	{r3, r4, r5, lr}
18007296:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
18007298:	480c      	ldr	r0, [pc, #48]	; (180072cc <update_cache+0x38>)
1800729a:	f003 fc7a 	bl	1800ab92 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
1800729e:	4d0c      	ldr	r5, [pc, #48]	; (180072d0 <update_cache+0x3c>)
180072a0:	4604      	mov	r4, r0
180072a2:	b900      	cbnz	r0, 180072a6 <update_cache+0x12>
180072a4:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
180072a6:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
180072a8:	b94a      	cbnz	r2, 180072be <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
180072aa:	7b5a      	ldrb	r2, [r3, #13]
180072ac:	06d2      	lsls	r2, r2, #27
180072ae:	d106      	bne.n	180072be <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
180072b0:	69a2      	ldr	r2, [r4, #24]
180072b2:	b922      	cbnz	r2, 180072be <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
180072b4:	89da      	ldrh	r2, [r3, #14]
180072b6:	2a7f      	cmp	r2, #127	; 0x7f
180072b8:	d901      	bls.n	180072be <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
180072ba:	61ab      	str	r3, [r5, #24]
}
180072bc:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
180072be:	429c      	cmp	r4, r3
180072c0:	d001      	beq.n	180072c6 <update_cache+0x32>
			z_reset_time_slice();
180072c2:	f7ff ff83 	bl	180071cc <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
180072c6:	61ac      	str	r4, [r5, #24]
}
180072c8:	e7f8      	b.n	180072bc <update_cache+0x28>
180072ca:	bf00      	nop
180072cc:	30180a3c 	.word	0x30180a3c
180072d0:	30180a20 	.word	0x30180a20

180072d4 <move_thread_to_end_of_prio_q>:
{
180072d4:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
180072d6:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
180072da:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
180072dc:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
180072de:	7b43      	ldrb	r3, [r0, #13]
180072e0:	da04      	bge.n	180072ec <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
180072e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
180072e6:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
180072e8:	f003 fbfe 	bl	1800aae8 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
180072ec:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
180072ee:	4a15      	ldr	r2, [pc, #84]	; (18007344 <move_thread_to_end_of_prio_q+0x70>)
180072f0:	f063 037f 	orn	r3, r3, #127	; 0x7f
180072f4:	734b      	strb	r3, [r1, #13]
	return sys_dlist_is_empty(list) ? NULL : list->head;
180072f6:	f102 051c 	add.w	r5, r2, #28
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
180072fa:	e9d2 3407 	ldrd	r3, r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
180072fe:	42ab      	cmp	r3, r5
18007300:	d01b      	beq.n	1800733a <move_thread_to_end_of_prio_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
18007302:	b1d3      	cbz	r3, 1800733a <move_thread_to_end_of_prio_q+0x66>
	int32_t b1 = thread_1->base.prio;
18007304:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
18007308:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
1800730c:	4286      	cmp	r6, r0
1800730e:	d00f      	beq.n	18007330 <move_thread_to_end_of_prio_q+0x5c>
		return b2 - b1;
18007310:	1b80      	subs	r0, r0, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
18007312:	2800      	cmp	r0, #0
18007314:	dd0c      	ble.n	18007330 <move_thread_to_end_of_prio_q+0x5c>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
18007316:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
18007318:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
1800731c:	6001      	str	r1, [r0, #0]
	successor->prev = node;
1800731e:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
18007320:	6890      	ldr	r0, [r2, #8]
}
18007322:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
18007326:	1a43      	subs	r3, r0, r1
18007328:	4258      	negs	r0, r3
1800732a:	4158      	adcs	r0, r3
1800732c:	f7ff bfb2 	b.w	18007294 <update_cache>
	return (node == list->tail) ? NULL : node->next;
18007330:	42a3      	cmp	r3, r4
18007332:	d002      	beq.n	1800733a <move_thread_to_end_of_prio_q+0x66>
18007334:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
18007336:	2b00      	cmp	r3, #0
18007338:	d1e6      	bne.n	18007308 <move_thread_to_end_of_prio_q+0x34>
	node->prev = tail;
1800733a:	e9c1 5400 	strd	r5, r4, [r1]
	tail->next = node;
1800733e:	6021      	str	r1, [r4, #0]
	list->tail = node;
18007340:	6211      	str	r1, [r2, #32]
}
18007342:	e7ed      	b.n	18007320 <move_thread_to_end_of_prio_q+0x4c>
18007344:	30180a20 	.word	0x30180a20

18007348 <z_time_slice>:
{
18007348:	4601      	mov	r1, r0
1800734a:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
1800734c:	f04f 0320 	mov.w	r3, #32
18007350:	f3ef 8411 	mrs	r4, BASEPRI
18007354:	f383 8812 	msr	BASEPRI_MAX, r3
18007358:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
1800735c:	4b15      	ldr	r3, [pc, #84]	; (180073b4 <z_time_slice+0x6c>)
1800735e:	4a16      	ldr	r2, [pc, #88]	; (180073b8 <z_time_slice+0x70>)
18007360:	6898      	ldr	r0, [r3, #8]
18007362:	6815      	ldr	r5, [r2, #0]
18007364:	42a8      	cmp	r0, r5
18007366:	d106      	bne.n	18007376 <z_time_slice+0x2e>
			z_reset_time_slice();
18007368:	f7ff ff30 	bl	180071cc <z_reset_time_slice>
	__asm__ volatile(
1800736c:	f384 8811 	msr	BASEPRI, r4
18007370:	f3bf 8f6f 	isb	sy
}
18007374:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
18007376:	2500      	movs	r5, #0
18007378:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
1800737a:	4a10      	ldr	r2, [pc, #64]	; (180073bc <z_time_slice+0x74>)
1800737c:	6812      	ldr	r2, [r2, #0]
1800737e:	b1ba      	cbz	r2, 180073b0 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
18007380:	89c2      	ldrh	r2, [r0, #14]
18007382:	2a7f      	cmp	r2, #127	; 0x7f
18007384:	d814      	bhi.n	180073b0 <z_time_slice+0x68>
		&& !z_is_thread_prevented_from_running(thread)
18007386:	7b42      	ldrb	r2, [r0, #13]
18007388:	06d2      	lsls	r2, r2, #27
1800738a:	d111      	bne.n	180073b0 <z_time_slice+0x68>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
1800738c:	4a0c      	ldr	r2, [pc, #48]	; (180073c0 <z_time_slice+0x78>)
1800738e:	f990 500e 	ldrsb.w	r5, [r0, #14]
18007392:	6812      	ldr	r2, [r2, #0]
18007394:	4295      	cmp	r5, r2
18007396:	db0b      	blt.n	180073b0 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
18007398:	4a0a      	ldr	r2, [pc, #40]	; (180073c4 <z_time_slice+0x7c>)
1800739a:	4290      	cmp	r0, r2
1800739c:	d008      	beq.n	180073b0 <z_time_slice+0x68>
		if (ticks >= _current_cpu->slice_ticks) {
1800739e:	691a      	ldr	r2, [r3, #16]
180073a0:	428a      	cmp	r2, r1
180073a2:	dc02      	bgt.n	180073aa <z_time_slice+0x62>
			move_thread_to_end_of_prio_q(_current);
180073a4:	f7ff ff96 	bl	180072d4 <move_thread_to_end_of_prio_q>
180073a8:	e7de      	b.n	18007368 <z_time_slice+0x20>
			_current_cpu->slice_ticks -= ticks;
180073aa:	1a52      	subs	r2, r2, r1
		_current_cpu->slice_ticks = 0;
180073ac:	611a      	str	r2, [r3, #16]
180073ae:	e7dd      	b.n	1800736c <z_time_slice+0x24>
180073b0:	2200      	movs	r2, #0
180073b2:	e7fb      	b.n	180073ac <z_time_slice+0x64>
180073b4:	30180a20 	.word	0x30180a20
180073b8:	30180a48 	.word	0x30180a48
180073bc:	30180a50 	.word	0x30180a50
180073c0:	30180a4c 	.word	0x30180a4c
180073c4:	301802d8 	.word	0x301802d8

180073c8 <ready_thread>:
{
180073c8:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
180073ca:	f990 200d 	ldrsb.w	r2, [r0, #13]
180073ce:	7b43      	ldrb	r3, [r0, #13]
180073d0:	2a00      	cmp	r2, #0
180073d2:	db2a      	blt.n	1800742a <ready_thread+0x62>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
180073d4:	06da      	lsls	r2, r3, #27
180073d6:	d128      	bne.n	1800742a <ready_thread+0x62>
180073d8:	6982      	ldr	r2, [r0, #24]
180073da:	bb32      	cbnz	r2, 1800742a <ready_thread+0x62>
	return list->head == list;
180073dc:	4a14      	ldr	r2, [pc, #80]	; (18007430 <ready_thread+0x68>)
	thread->base.thread_state |= _THREAD_QUEUED;
180073de:	f063 037f 	orn	r3, r3, #127	; 0x7f
180073e2:	7343      	strb	r3, [r0, #13]
	return sys_dlist_is_empty(list) ? NULL : list->head;
180073e4:	f102 051c 	add.w	r5, r2, #28
	return (node == list->tail) ? NULL : node->next;
180073e8:	e9d2 3407 	ldrd	r3, r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
180073ec:	42ab      	cmp	r3, r5
180073ee:	d017      	beq.n	18007420 <ready_thread+0x58>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
180073f0:	b1b3      	cbz	r3, 18007420 <ready_thread+0x58>
	int32_t b1 = thread_1->base.prio;
180073f2:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
180073f6:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
180073fa:	428e      	cmp	r6, r1
180073fc:	d00b      	beq.n	18007416 <ready_thread+0x4e>
		return b2 - b1;
180073fe:	1b89      	subs	r1, r1, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
18007400:	2900      	cmp	r1, #0
18007402:	dd08      	ble.n	18007416 <ready_thread+0x4e>
	sys_dnode_t *const prev = successor->prev;
18007404:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
18007406:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
1800740a:	6010      	str	r0, [r2, #0]
	successor->prev = node;
1800740c:	6058      	str	r0, [r3, #4]
		update_cache(0);
1800740e:	2000      	movs	r0, #0
}
18007410:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
18007412:	f7ff bf3f 	b.w	18007294 <update_cache>
	return (node == list->tail) ? NULL : node->next;
18007416:	42a3      	cmp	r3, r4
18007418:	d002      	beq.n	18007420 <ready_thread+0x58>
1800741a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1800741c:	2b00      	cmp	r3, #0
1800741e:	d1ea      	bne.n	180073f6 <ready_thread+0x2e>
	node->prev = tail;
18007420:	e9c0 5400 	strd	r5, r4, [r0]
	tail->next = node;
18007424:	6020      	str	r0, [r4, #0]
	list->tail = node;
18007426:	6210      	str	r0, [r2, #32]
}
18007428:	e7f1      	b.n	1800740e <ready_thread+0x46>
}
1800742a:	bc70      	pop	{r4, r5, r6}
1800742c:	4770      	bx	lr
1800742e:	bf00      	nop
18007430:	30180a20 	.word	0x30180a20

18007434 <z_sched_start>:
{
18007434:	b510      	push	{r4, lr}
	__asm__ volatile(
18007436:	f04f 0220 	mov.w	r2, #32
1800743a:	f3ef 8411 	mrs	r4, BASEPRI
1800743e:	f382 8812 	msr	BASEPRI_MAX, r2
18007442:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
18007446:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
18007448:	0751      	lsls	r1, r2, #29
1800744a:	d404      	bmi.n	18007456 <z_sched_start+0x22>
	__asm__ volatile(
1800744c:	f384 8811 	msr	BASEPRI, r4
18007450:	f3bf 8f6f 	isb	sy
}
18007454:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
18007456:	f022 0204 	bic.w	r2, r2, #4
1800745a:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
1800745c:	f7ff ffb4 	bl	180073c8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
18007460:	4621      	mov	r1, r4
}
18007462:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
18007466:	4801      	ldr	r0, [pc, #4]	; (1800746c <z_sched_start+0x38>)
18007468:	f7ff beee 	b.w	18007248 <z_reschedule>
1800746c:	30180a88 	.word	0x30180a88

18007470 <unready_thread>:
{
18007470:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
18007472:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
18007476:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
18007478:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
1800747a:	7b43      	ldrb	r3, [r0, #13]
1800747c:	da04      	bge.n	18007488 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1800747e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
18007482:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
18007484:	f003 fb30 	bl	1800aae8 <sys_dlist_remove>
	update_cache(thread == _current);
18007488:	4b04      	ldr	r3, [pc, #16]	; (1800749c <unready_thread+0x2c>)
1800748a:	6898      	ldr	r0, [r3, #8]
1800748c:	1a43      	subs	r3, r0, r1
1800748e:	4258      	negs	r0, r3
18007490:	4158      	adcs	r0, r3
}
18007492:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
18007496:	f7ff befd 	b.w	18007294 <update_cache>
1800749a:	bf00      	nop
1800749c:	30180a20 	.word	0x30180a20

180074a0 <pend>:
{
180074a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
180074a4:	4606      	mov	r6, r0
180074a6:	4615      	mov	r5, r2
180074a8:	461c      	mov	r4, r3
	__asm__ volatile(
180074aa:	f04f 0320 	mov.w	r3, #32
180074ae:	f3ef 8711 	mrs	r7, BASEPRI
180074b2:	f383 8812 	msr	BASEPRI_MAX, r3
180074b6:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
180074ba:	f003 fba2 	bl	1800ac02 <add_to_waitq_locked>
	__asm__ volatile(
180074be:	f387 8811 	msr	BASEPRI, r7
180074c2:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
180074c6:	f1b4 3fff 	cmp.w	r4, #4294967295
180074ca:	bf08      	it	eq
180074cc:	f1b5 3fff 	cmpeq.w	r5, #4294967295
180074d0:	d008      	beq.n	180074e4 <pend+0x44>
180074d2:	462a      	mov	r2, r5
180074d4:	4623      	mov	r3, r4
180074d6:	f106 0018 	add.w	r0, r6, #24
180074da:	4903      	ldr	r1, [pc, #12]	; (180074e8 <pend+0x48>)
}
180074dc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
180074e0:	f000 ba3e 	b.w	18007960 <z_add_timeout>
180074e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
180074e8:	1800abbf 	.word	0x1800abbf

180074ec <z_pend_curr>:
{
180074ec:	b510      	push	{r4, lr}
180074ee:	460c      	mov	r4, r1
	pending_current = _current;
180074f0:	4b06      	ldr	r3, [pc, #24]	; (1800750c <z_pend_curr+0x20>)
{
180074f2:	4611      	mov	r1, r2
	pending_current = _current;
180074f4:	6898      	ldr	r0, [r3, #8]
180074f6:	4b06      	ldr	r3, [pc, #24]	; (18007510 <z_pend_curr+0x24>)
180074f8:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
180074fa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
180074fe:	f7ff ffcf 	bl	180074a0 <pend>
18007502:	4620      	mov	r0, r4
}
18007504:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
18007508:	f7fd bbcc 	b.w	18004ca4 <arch_swap>
1800750c:	30180a20 	.word	0x30180a20
18007510:	30180a48 	.word	0x30180a48

18007514 <z_set_prio>:
{
18007514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18007516:	4604      	mov	r4, r0
	__asm__ volatile(
18007518:	f04f 0320 	mov.w	r3, #32
1800751c:	f3ef 8611 	mrs	r6, BASEPRI
18007520:	f383 8812 	msr	BASEPRI_MAX, r3
18007524:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
18007528:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
1800752a:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
1800752c:	06da      	lsls	r2, r3, #27
1800752e:	d133      	bne.n	18007598 <z_set_prio+0x84>
		if (need_sched) {
18007530:	6982      	ldr	r2, [r0, #24]
18007532:	bb8a      	cbnz	r2, 18007598 <z_set_prio+0x84>
	thread->base.thread_state &= ~_THREAD_QUEUED;
18007534:	f003 037f 	and.w	r3, r3, #127	; 0x7f
18007538:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1800753a:	f003 fad5 	bl	1800aae8 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
1800753e:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
18007540:	4a17      	ldr	r2, [pc, #92]	; (180075a0 <z_set_prio+0x8c>)
18007542:	f063 037f 	orn	r3, r3, #127	; 0x7f
18007546:	7343      	strb	r3, [r0, #13]
				thread->base.prio = prio;
18007548:	7381      	strb	r1, [r0, #14]
1800754a:	4610      	mov	r0, r2
1800754c:	f850 3f1c 	ldr.w	r3, [r0, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
18007550:	4283      	cmp	r3, r0
18007552:	d01b      	beq.n	1800758c <z_set_prio+0x78>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
18007554:	b1d3      	cbz	r3, 1800758c <z_set_prio+0x78>
	return (node == list->tail) ? NULL : node->next;
18007556:	6a17      	ldr	r7, [r2, #32]
	int32_t b2 = thread_2->base.prio;
18007558:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
1800755c:	42a9      	cmp	r1, r5
1800755e:	d010      	beq.n	18007582 <z_set_prio+0x6e>
		return b2 - b1;
18007560:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
18007562:	2d00      	cmp	r5, #0
18007564:	dd0d      	ble.n	18007582 <z_set_prio+0x6e>
	sys_dnode_t *const prev = successor->prev;
18007566:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
18007568:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
1800756c:	6014      	str	r4, [r2, #0]
	successor->prev = node;
1800756e:	605c      	str	r4, [r3, #4]
			update_cache(1);
18007570:	2001      	movs	r0, #1
18007572:	f7ff fe8f 	bl	18007294 <update_cache>
18007576:	2001      	movs	r0, #1
	__asm__ volatile(
18007578:	f386 8811 	msr	BASEPRI, r6
1800757c:	f3bf 8f6f 	isb	sy
}
18007580:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
18007582:	42bb      	cmp	r3, r7
18007584:	d002      	beq.n	1800758c <z_set_prio+0x78>
18007586:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
18007588:	2b00      	cmp	r3, #0
1800758a:	d1e5      	bne.n	18007558 <z_set_prio+0x44>
	sys_dnode_t *const tail = list->tail;
1800758c:	6a13      	ldr	r3, [r2, #32]
	node->prev = tail;
1800758e:	e9c4 0300 	strd	r0, r3, [r4]
	tail->next = node;
18007592:	601c      	str	r4, [r3, #0]
	list->tail = node;
18007594:	6214      	str	r4, [r2, #32]
}
18007596:	e7eb      	b.n	18007570 <z_set_prio+0x5c>
			thread->base.prio = prio;
18007598:	2000      	movs	r0, #0
1800759a:	73a1      	strb	r1, [r4, #14]
1800759c:	e7ec      	b.n	18007578 <z_set_prio+0x64>
1800759e:	bf00      	nop
180075a0:	30180a20 	.word	0x30180a20

180075a4 <z_impl_k_thread_suspend>:
{
180075a4:	b570      	push	{r4, r5, r6, lr}
180075a6:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
180075a8:	3018      	adds	r0, #24
180075aa:	f003 fb9f 	bl	1800acec <z_abort_timeout>
	__asm__ volatile(
180075ae:	f04f 0320 	mov.w	r3, #32
180075b2:	f3ef 8611 	mrs	r6, BASEPRI
180075b6:	f383 8812 	msr	BASEPRI_MAX, r3
180075ba:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
180075be:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
180075c2:	7b63      	ldrb	r3, [r4, #13]
180075c4:	2a00      	cmp	r2, #0
180075c6:	da05      	bge.n	180075d4 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
180075c8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
180075cc:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
180075ce:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
180075d0:	f003 fa8a 	bl	1800aae8 <sys_dlist_remove>
		update_cache(thread == _current);
180075d4:	4d0b      	ldr	r5, [pc, #44]	; (18007604 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
180075d6:	7b63      	ldrb	r3, [r4, #13]
180075d8:	68a8      	ldr	r0, [r5, #8]
180075da:	f043 0310 	orr.w	r3, r3, #16
180075de:	7363      	strb	r3, [r4, #13]
180075e0:	1b03      	subs	r3, r0, r4
180075e2:	4258      	negs	r0, r3
180075e4:	4158      	adcs	r0, r3
180075e6:	f7ff fe55 	bl	18007294 <update_cache>
	__asm__ volatile(
180075ea:	f386 8811 	msr	BASEPRI, r6
180075ee:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
180075f2:	68ab      	ldr	r3, [r5, #8]
180075f4:	42a3      	cmp	r3, r4
180075f6:	d103      	bne.n	18007600 <z_impl_k_thread_suspend+0x5c>
}
180075f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
180075fc:	f003 babf 	b.w	1800ab7e <z_reschedule_unlocked>
}
18007600:	bd70      	pop	{r4, r5, r6, pc}
18007602:	bf00      	nop
18007604:	30180a20 	.word	0x30180a20

18007608 <k_sched_unlock>:
{
18007608:	b510      	push	{r4, lr}
	__asm__ volatile(
1800760a:	f04f 0320 	mov.w	r3, #32
1800760e:	f3ef 8411 	mrs	r4, BASEPRI
18007612:	f383 8812 	msr	BASEPRI_MAX, r3
18007616:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
1800761a:	4b08      	ldr	r3, [pc, #32]	; (1800763c <k_sched_unlock+0x34>)
		update_cache(0);
1800761c:	2000      	movs	r0, #0
		++_current->base.sched_locked;
1800761e:	689a      	ldr	r2, [r3, #8]
18007620:	7bd3      	ldrb	r3, [r2, #15]
18007622:	3301      	adds	r3, #1
18007624:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
18007626:	f7ff fe35 	bl	18007294 <update_cache>
	__asm__ volatile(
1800762a:	f384 8811 	msr	BASEPRI, r4
1800762e:	f3bf 8f6f 	isb	sy
}
18007632:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
18007636:	f003 baa2 	b.w	1800ab7e <z_reschedule_unlocked>
1800763a:	bf00      	nop
1800763c:	30180a20 	.word	0x30180a20

18007640 <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
18007640:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
18007642:	4b04      	ldr	r3, [pc, #16]	; (18007654 <z_sched_init+0x14>)
18007644:	4608      	mov	r0, r1
18007646:	f103 021c 	add.w	r2, r3, #28
	list->tail = (sys_dnode_t *)list;
1800764a:	e9c3 2207 	strd	r2, r2, [r3, #28]
1800764e:	f7ff bdd3 	b.w	180071f8 <k_sched_time_slice_set>
18007652:	bf00      	nop
18007654:	30180a20 	.word	0x30180a20

18007658 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
18007658:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
1800765a:	f04f 0320 	mov.w	r3, #32
1800765e:	f3ef 8511 	mrs	r5, BASEPRI
18007662:	f383 8812 	msr	BASEPRI_MAX, r3
18007666:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
1800766a:	491a      	ldr	r1, [pc, #104]	; (180076d4 <z_impl_k_yield+0x7c>)
1800766c:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
1800766e:	7b43      	ldrb	r3, [r0, #13]
18007670:	f003 037f 	and.w	r3, r3, #127	; 0x7f
18007674:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
18007676:	f003 fa37 	bl	1800aae8 <sys_dlist_remove>
	return list->head == list;
1800767a:	4608      	mov	r0, r1
	}
	queue_thread(_current);
1800767c:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
1800767e:	7b5a      	ldrb	r2, [r3, #13]
18007680:	f062 027f 	orn	r2, r2, #127	; 0x7f
18007684:	735a      	strb	r2, [r3, #13]
18007686:	f850 2f1c 	ldr.w	r2, [r0, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
1800768a:	4282      	cmp	r2, r0
1800768c:	d01c      	beq.n	180076c8 <z_impl_k_yield+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1800768e:	b1da      	cbz	r2, 180076c8 <z_impl_k_yield+0x70>
	return (node == list->tail) ? NULL : node->next;
18007690:	6a0f      	ldr	r7, [r1, #32]
	int32_t b1 = thread_1->base.prio;
18007692:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
18007696:	f992 400e 	ldrsb.w	r4, [r2, #14]
	if (b1 != b2) {
1800769a:	42a6      	cmp	r6, r4
1800769c:	d00f      	beq.n	180076be <z_impl_k_yield+0x66>
		return b2 - b1;
1800769e:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
180076a0:	2c00      	cmp	r4, #0
180076a2:	dd0c      	ble.n	180076be <z_impl_k_yield+0x66>
	sys_dnode_t *const prev = successor->prev;
180076a4:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
180076a6:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
180076aa:	600b      	str	r3, [r1, #0]
	successor->prev = node;
180076ac:	6053      	str	r3, [r2, #4]
	update_cache(1);
180076ae:	2001      	movs	r0, #1
180076b0:	f7ff fdf0 	bl	18007294 <update_cache>
180076b4:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
180076b6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
180076ba:	f7fd baf3 	b.w	18004ca4 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
180076be:	42ba      	cmp	r2, r7
180076c0:	d002      	beq.n	180076c8 <z_impl_k_yield+0x70>
180076c2:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
180076c4:	2a00      	cmp	r2, #0
180076c6:	d1e6      	bne.n	18007696 <z_impl_k_yield+0x3e>
	sys_dnode_t *const tail = list->tail;
180076c8:	6a0a      	ldr	r2, [r1, #32]
	node->prev = tail;
180076ca:	e9c3 0200 	strd	r0, r2, [r3]
	tail->next = node;
180076ce:	6013      	str	r3, [r2, #0]
	list->tail = node;
180076d0:	620b      	str	r3, [r1, #32]
}
180076d2:	e7ec      	b.n	180076ae <z_impl_k_yield+0x56>
180076d4:	30180a20 	.word	0x30180a20

180076d8 <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
180076d8:	ea50 0301 	orrs.w	r3, r0, r1
{
180076dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
180076e0:	4605      	mov	r5, r0
180076e2:	460e      	mov	r6, r1
	if (ticks == 0) {
180076e4:	d103      	bne.n	180076ee <z_tick_sleep+0x16>
	z_impl_k_yield();
180076e6:	f7ff ffb7 	bl	18007658 <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
180076ea:	2000      	movs	r0, #0
180076ec:	e033      	b.n	18007756 <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
180076ee:	f06f 0401 	mvn.w	r4, #1
180076f2:	f04f 33ff 	mov.w	r3, #4294967295
180076f6:	1a24      	subs	r4, r4, r0
180076f8:	eb63 0301 	sbc.w	r3, r3, r1
180076fc:	2c01      	cmp	r4, #1
180076fe:	f173 0300 	sbcs.w	r3, r3, #0
18007702:	da02      	bge.n	1800770a <z_tick_sleep+0x32>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
18007704:	f003 fb22 	bl	1800ad4c <sys_clock_tick_get_32>
18007708:	1944      	adds	r4, r0, r5
1800770a:	f04f 0320 	mov.w	r3, #32
1800770e:	f3ef 8811 	mrs	r8, BASEPRI
18007712:	f383 8812 	msr	BASEPRI_MAX, r3
18007716:	f3bf 8f6f 	isb	sy
	pending_current = _current;
1800771a:	4f10      	ldr	r7, [pc, #64]	; (1800775c <z_tick_sleep+0x84>)
1800771c:	4b10      	ldr	r3, [pc, #64]	; (18007760 <z_tick_sleep+0x88>)
1800771e:	68b8      	ldr	r0, [r7, #8]
18007720:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
18007722:	f7ff fea5 	bl	18007470 <unready_thread>
	z_add_thread_timeout(_current, timeout);
18007726:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
18007728:	490e      	ldr	r1, [pc, #56]	; (18007764 <z_tick_sleep+0x8c>)
1800772a:	462a      	mov	r2, r5
1800772c:	4633      	mov	r3, r6
1800772e:	3018      	adds	r0, #24
18007730:	f000 f916 	bl	18007960 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
18007734:	68ba      	ldr	r2, [r7, #8]
18007736:	4640      	mov	r0, r8
18007738:	7b53      	ldrb	r3, [r2, #13]
1800773a:	f043 0310 	orr.w	r3, r3, #16
1800773e:	7353      	strb	r3, [r2, #13]
18007740:	f7fd fab0 	bl	18004ca4 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
18007744:	f003 fb02 	bl	1800ad4c <sys_clock_tick_get_32>
18007748:	1a20      	subs	r0, r4, r0
1800774a:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
1800774e:	2801      	cmp	r0, #1
18007750:	f173 0300 	sbcs.w	r3, r3, #0
18007754:	dbc9      	blt.n	180076ea <z_tick_sleep+0x12>
}
18007756:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1800775a:	bf00      	nop
1800775c:	30180a20 	.word	0x30180a20
18007760:	30180a48 	.word	0x30180a48
18007764:	1800abbf 	.word	0x1800abbf

18007768 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
18007768:	f1b1 3fff 	cmp.w	r1, #4294967295
1800776c:	bf08      	it	eq
1800776e:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
18007772:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
18007774:	d106      	bne.n	18007784 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
18007776:	4b07      	ldr	r3, [pc, #28]	; (18007794 <z_impl_k_sleep+0x2c>)
18007778:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
1800777a:	f7ff ff13 	bl	180075a4 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
1800777e:	f04f 30ff 	mov.w	r0, #4294967295
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
18007782:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
18007784:	f7ff ffa8 	bl	180076d8 <z_tick_sleep>
			return t / ((uint64_t)from_hz / to_hz);
18007788:	220a      	movs	r2, #10
1800778a:	2300      	movs	r3, #0
1800778c:	17c1      	asrs	r1, r0, #31
1800778e:	f7f9 fdcf 	bl	18001330 <__aeabi_uldivmod>
	return ret;
18007792:	e7f6      	b.n	18007782 <z_impl_k_sleep+0x1a>
18007794:	30180a20 	.word	0x30180a20

18007798 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
18007798:	4b01      	ldr	r3, [pc, #4]	; (180077a0 <z_impl_z_current_get+0x8>)
1800779a:	6898      	ldr	r0, [r3, #8]
1800779c:	4770      	bx	lr
1800779e:	bf00      	nop
180077a0:	30180a20 	.word	0x30180a20

180077a4 <z_impl_k_is_preempt_thread>:
180077a4:	f3ef 8305 	mrs	r3, IPSR
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
180077a8:	b93b      	cbnz	r3, 180077ba <z_impl_k_is_preempt_thread+0x16>
180077aa:	4b05      	ldr	r3, [pc, #20]	; (180077c0 <z_impl_k_is_preempt_thread+0x1c>)
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
180077ac:	689b      	ldr	r3, [r3, #8]
	return !arch_is_in_isr() && is_preempt(_current);
180077ae:	89d8      	ldrh	r0, [r3, #14]
180077b0:	287f      	cmp	r0, #127	; 0x7f
180077b2:	bf8c      	ite	hi
180077b4:	2000      	movhi	r0, #0
180077b6:	2001      	movls	r0, #1
180077b8:	4770      	bx	lr
180077ba:	2000      	movs	r0, #0
}
180077bc:	4770      	bx	lr
180077be:	bf00      	nop
180077c0:	30180a20 	.word	0x30180a20

180077c4 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
180077c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
180077c8:	4604      	mov	r4, r0
180077ca:	f04f 0320 	mov.w	r3, #32
180077ce:	f3ef 8611 	mrs	r6, BASEPRI
180077d2:	f383 8812 	msr	BASEPRI_MAX, r3
180077d6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
180077da:	7b43      	ldrb	r3, [r0, #13]
180077dc:	071a      	lsls	r2, r3, #28
180077de:	d505      	bpl.n	180077ec <z_thread_abort+0x28>
	__asm__ volatile(
180077e0:	f386 8811 	msr	BASEPRI, r6
180077e4:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
180077e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
180077ec:	f023 0220 	bic.w	r2, r3, #32
180077f0:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
180077f4:	09d2      	lsrs	r2, r2, #7
180077f6:	d123      	bne.n	18007840 <z_thread_abort+0x7c>
		thread->base.thread_state &= ~_THREAD_ABORTING;
180077f8:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
180077fa:	68a3      	ldr	r3, [r4, #8]
180077fc:	b113      	cbz	r3, 18007804 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
180077fe:	4620      	mov	r0, r4
18007800:	f003 f97a 	bl	1800aaf8 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
18007804:	f104 0018 	add.w	r0, r4, #24
18007808:	f003 fa70 	bl	1800acec <z_abort_timeout>
1800780c:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
18007810:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
18007814:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
18007816:	42bd      	cmp	r5, r7
18007818:	d000      	beq.n	1800781c <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
1800781a:	b9cd      	cbnz	r5, 18007850 <z_thread_abort+0x8c>
		update_cache(1);
1800781c:	2001      	movs	r0, #1
1800781e:	f7ff fd39 	bl	18007294 <update_cache>
		z_thread_monitor_exit(thread);
18007822:	4620      	mov	r0, r4
18007824:	f7ff f9d2 	bl	18006bcc <z_thread_monitor_exit>
	if (thread == _current && !arch_is_in_isr()) {
18007828:	4b10      	ldr	r3, [pc, #64]	; (1800786c <z_thread_abort+0xa8>)
1800782a:	689b      	ldr	r3, [r3, #8]
1800782c:	42a3      	cmp	r3, r4
1800782e:	d1d7      	bne.n	180077e0 <z_thread_abort+0x1c>
18007830:	f3ef 8305 	mrs	r3, IPSR
18007834:	2b00      	cmp	r3, #0
18007836:	d1d3      	bne.n	180077e0 <z_thread_abort+0x1c>
18007838:	4630      	mov	r0, r6
1800783a:	f7fd fa33 	bl	18004ca4 <arch_swap>
	return ret;
1800783e:	e7cf      	b.n	180077e0 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
18007840:	f003 035f 	and.w	r3, r3, #95	; 0x5f
18007844:	f043 0308 	orr.w	r3, r3, #8
18007848:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1800784a:	f003 f94d 	bl	1800aae8 <sys_dlist_remove>
}
1800784e:	e7d4      	b.n	180077fa <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
18007850:	4628      	mov	r0, r5
18007852:	f003 f951 	bl	1800aaf8 <unpend_thread_no_timeout>
18007856:	f105 0018 	add.w	r0, r5, #24
1800785a:	f003 fa47 	bl	1800acec <z_abort_timeout>
		ready_thread(thread);
1800785e:	4628      	mov	r0, r5
18007860:	f8c5 80b0 	str.w	r8, [r5, #176]	; 0xb0
18007864:	f7ff fdb0 	bl	180073c8 <ready_thread>
18007868:	e7d4      	b.n	18007814 <z_thread_abort+0x50>
1800786a:	bf00      	nop
1800786c:	30180a20 	.word	0x30180a20

18007870 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
18007870:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
18007872:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
18007876:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
18007878:	e9cd 6700 	strd	r6, r7, [sp]
1800787c:	f7ff fe36 	bl	180074ec <z_pend_curr>

	if (data != NULL) {
18007880:	b11c      	cbz	r4, 1800788a <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
18007882:	4b03      	ldr	r3, [pc, #12]	; (18007890 <z_sched_wait+0x20>)
18007884:	689b      	ldr	r3, [r3, #8]
18007886:	695b      	ldr	r3, [r3, #20]
18007888:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
1800788a:	b002      	add	sp, #8
1800788c:	bdd0      	pop	{r4, r6, r7, pc}
1800788e:	bf00      	nop
18007890:	30180a20 	.word	0x30180a20

18007894 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
18007894:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
18007896:	4806      	ldr	r0, [pc, #24]	; (180078b0 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
18007898:	4a06      	ldr	r2, [pc, #24]	; (180078b4 <z_data_copy+0x20>)
1800789a:	4907      	ldr	r1, [pc, #28]	; (180078b8 <z_data_copy+0x24>)
1800789c:	1a12      	subs	r2, r2, r0
1800789e:	f002 fc58 	bl	1800a152 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
180078a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
180078a6:	4a05      	ldr	r2, [pc, #20]	; (180078bc <z_data_copy+0x28>)
180078a8:	4905      	ldr	r1, [pc, #20]	; (180078c0 <z_data_copy+0x2c>)
180078aa:	4806      	ldr	r0, [pc, #24]	; (180078c4 <z_data_copy+0x30>)
180078ac:	f002 bc51 	b.w	1800a152 <memcpy>
180078b0:	30180000 	.word	0x30180000
180078b4:	301800f0 	.word	0x301800f0
180078b8:	1800de34 	.word	0x1800de34
180078bc:	00000000 	.word	0x00000000
180078c0:	1800de34 	.word	0x1800de34
180078c4:	30180000 	.word	0x30180000

180078c8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
180078c8:	4b03      	ldr	r3, [pc, #12]	; (180078d8 <elapsed+0x10>)
180078ca:	681b      	ldr	r3, [r3, #0]
180078cc:	b90b      	cbnz	r3, 180078d2 <elapsed+0xa>
180078ce:	f7fe b9e5 	b.w	18005c9c <sys_clock_elapsed>
}
180078d2:	2000      	movs	r0, #0
180078d4:	4770      	bx	lr
180078d6:	bf00      	nop
180078d8:	30180a54 	.word	0x30180a54

180078dc <next_timeout>:
	return list->head == list;
180078dc:	4b11      	ldr	r3, [pc, #68]	; (18007924 <next_timeout+0x48>)

static int32_t next_timeout(void)
{
180078de:	b510      	push	{r4, lr}
180078e0:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
180078e2:	429c      	cmp	r4, r3
180078e4:	bf08      	it	eq
180078e6:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
180078e8:	f7ff ffee 	bl	180078c8 <elapsed>
180078ec:	4603      	mov	r3, r0
	int32_t ret = to == NULL ? MAX_WAIT
180078ee:	b16c      	cbz	r4, 1800790c <next_timeout+0x30>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
180078f0:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
180078f4:	1ac0      	subs	r0, r0, r3
180078f6:	eb62 73e3 	sbc.w	r3, r2, r3, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
180078fa:	2801      	cmp	r0, #1
180078fc:	f173 0200 	sbcs.w	r2, r3, #0
18007900:	db0d      	blt.n	1800791e <next_timeout+0x42>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
18007902:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
18007906:	f173 0300 	sbcs.w	r3, r3, #0
1800790a:	db01      	blt.n	18007910 <next_timeout+0x34>
	int32_t ret = to == NULL ? MAX_WAIT
1800790c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
18007910:	4b05      	ldr	r3, [pc, #20]	; (18007928 <next_timeout+0x4c>)
18007912:	691b      	ldr	r3, [r3, #16]
18007914:	b113      	cbz	r3, 1800791c <next_timeout+0x40>
18007916:	4298      	cmp	r0, r3
18007918:	bfa8      	it	ge
1800791a:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
1800791c:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
1800791e:	2000      	movs	r0, #0
18007920:	e7f6      	b.n	18007910 <next_timeout+0x34>
18007922:	bf00      	nop
18007924:	30180064 	.word	0x30180064
18007928:	30180a20 	.word	0x30180a20

1800792c <remove_timeout>:
{
1800792c:	b530      	push	{r4, r5, lr}
	return (node == list->tail) ? NULL : node->next;
1800792e:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
18007930:	b168      	cbz	r0, 1800794e <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
18007932:	4a0a      	ldr	r2, [pc, #40]	; (1800795c <remove_timeout+0x30>)
18007934:	6852      	ldr	r2, [r2, #4]
18007936:	4290      	cmp	r0, r2
18007938:	d009      	beq.n	1800794e <remove_timeout+0x22>
	if (next(t) != NULL) {
1800793a:	b143      	cbz	r3, 1800794e <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
1800793c:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
18007940:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
18007944:	1912      	adds	r2, r2, r4
18007946:	eb41 0105 	adc.w	r1, r1, r5
1800794a:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
1800794e:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
18007950:	6013      	str	r3, [r2, #0]
	next->prev = prev;
18007952:	605a      	str	r2, [r3, #4]
	node->next = NULL;
18007954:	2300      	movs	r3, #0
	node->prev = NULL;
18007956:	e9c0 3300 	strd	r3, r3, [r0]
}
1800795a:	bd30      	pop	{r4, r5, pc}
1800795c:	30180064 	.word	0x30180064

18007960 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
18007960:	f1b3 3fff 	cmp.w	r3, #4294967295
18007964:	bf08      	it	eq
18007966:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
1800796a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1800796c:	4604      	mov	r4, r0
1800796e:	461f      	mov	r7, r3
18007970:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
18007972:	d067      	beq.n	18007a44 <z_add_timeout+0xe4>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
18007974:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
18007976:	f04f 0320 	mov.w	r3, #32
1800797a:	f3ef 8611 	mrs	r6, BASEPRI
1800797e:	f383 8812 	msr	BASEPRI_MAX, r3
18007982:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
18007986:	f06f 0201 	mvn.w	r2, #1
1800798a:	f04f 3cff 	mov.w	ip, #4294967295
1800798e:	1b53      	subs	r3, r2, r5
18007990:	eb6c 0307 	sbc.w	r3, ip, r7
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
18007994:	2b00      	cmp	r3, #0
18007996:	db1b      	blt.n	180079d0 <z_add_timeout+0x70>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
18007998:	4b2b      	ldr	r3, [pc, #172]	; (18007a48 <z_add_timeout+0xe8>)
1800799a:	e9d3 1300 	ldrd	r1, r3, [r3]
1800799e:	1a52      	subs	r2, r2, r1
180079a0:	eb6c 0303 	sbc.w	r3, ip, r3
180079a4:	1b55      	subs	r5, r2, r5

			to->dticks = MAX(1, ticks);
180079a6:	eb63 0307 	sbc.w	r3, r3, r7
180079aa:	2d01      	cmp	r5, #1
180079ac:	f173 0200 	sbcs.w	r2, r3, #0
180079b0:	bfbc      	itt	lt
180079b2:	2501      	movlt	r5, #1
180079b4:	2300      	movlt	r3, #0
180079b6:	e9c0 5304 	strd	r5, r3, [r0, #16]
	return list->head == list;
180079ba:	4824      	ldr	r0, [pc, #144]	; (18007a4c <z_add_timeout+0xec>)
	sys_dnode_t *const tail = list->tail;
180079bc:	e9d0 3c00 	ldrd	r3, ip, [r0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
180079c0:	4283      	cmp	r3, r0
180079c2:	d118      	bne.n	180079f6 <z_add_timeout+0x96>
	node->prev = tail;
180079c4:	e9c4 0c00 	strd	r0, ip, [r4]
	tail->next = node;
180079c8:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
180079cc:	6044      	str	r4, [r0, #4]
}
180079ce:	e026      	b.n	18007a1e <z_add_timeout+0xbe>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
180079d0:	f7ff ff7a 	bl	180078c8 <elapsed>
180079d4:	3501      	adds	r5, #1
180079d6:	f147 0700 	adc.w	r7, r7, #0
180079da:	182d      	adds	r5, r5, r0
180079dc:	eb47 77e0 	adc.w	r7, r7, r0, asr #31
180079e0:	e9c4 5704 	strd	r5, r7, [r4, #16]
180079e4:	e7e9      	b.n	180079ba <z_add_timeout+0x5a>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
180079e6:	1a52      	subs	r2, r2, r1
180079e8:	eb65 0507 	sbc.w	r5, r5, r7
	return (node == list->tail) ? NULL : node->next;
180079ec:	459c      	cmp	ip, r3
180079ee:	e9c4 2504 	strd	r2, r5, [r4, #16]
180079f2:	d0e7      	beq.n	180079c4 <z_add_timeout+0x64>
180079f4:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
180079f6:	2b00      	cmp	r3, #0
180079f8:	d0e4      	beq.n	180079c4 <z_add_timeout+0x64>
			if (t->dticks > to->dticks) {
180079fa:	e9d3 1704 	ldrd	r1, r7, [r3, #16]
180079fe:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
18007a02:	428a      	cmp	r2, r1
18007a04:	eb75 0e07 	sbcs.w	lr, r5, r7
18007a08:	daed      	bge.n	180079e6 <z_add_timeout+0x86>
				t->dticks -= to->dticks;
18007a0a:	1a8a      	subs	r2, r1, r2
18007a0c:	eb67 0505 	sbc.w	r5, r7, r5
18007a10:	e9c3 2504 	strd	r2, r5, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
18007a14:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
18007a16:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
18007a1a:	6014      	str	r4, [r2, #0]
	successor->prev = node;
18007a1c:	605c      	str	r4, [r3, #4]
	return list->head == list;
18007a1e:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
18007a20:	4283      	cmp	r3, r0
18007a22:	d00b      	beq.n	18007a3c <z_add_timeout+0xdc>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
18007a24:	429c      	cmp	r4, r3
18007a26:	d109      	bne.n	18007a3c <z_add_timeout+0xdc>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
18007a28:	f7ff ff58 	bl	180078dc <next_timeout>

			if (next_time == 0 ||
18007a2c:	b118      	cbz	r0, 18007a36 <z_add_timeout+0xd6>
			    _current_cpu->slice_ticks != next_time) {
18007a2e:	4b08      	ldr	r3, [pc, #32]	; (18007a50 <z_add_timeout+0xf0>)
			if (next_time == 0 ||
18007a30:	691b      	ldr	r3, [r3, #16]
18007a32:	4283      	cmp	r3, r0
18007a34:	d002      	beq.n	18007a3c <z_add_timeout+0xdc>
				sys_clock_set_timeout(next_time, false);
18007a36:	2100      	movs	r1, #0
18007a38:	f7fe f8e6 	bl	18005c08 <sys_clock_set_timeout>
	__asm__ volatile(
18007a3c:	f386 8811 	msr	BASEPRI, r6
18007a40:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
18007a44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
18007a46:	bf00      	nop
18007a48:	30180448 	.word	0x30180448
18007a4c:	30180064 	.word	0x30180064
18007a50:	30180a20 	.word	0x30180a20

18007a54 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
18007a54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
18007a58:	4605      	mov	r5, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
18007a5a:	f7ff fc75 	bl	18007348 <z_time_slice>
	__asm__ volatile(
18007a5e:	f04f 0320 	mov.w	r3, #32
18007a62:	f3ef 8411 	mrs	r4, BASEPRI
18007a66:	f383 8812 	msr	BASEPRI_MAX, r3
18007a6a:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
18007a6e:	4e24      	ldr	r6, [pc, #144]	; (18007b00 <sys_clock_announce+0xac>)
	return list->head == list;
18007a70:	f8df 8090 	ldr.w	r8, [pc, #144]	; 18007b04 <sys_clock_announce+0xb0>
18007a74:	6035      	str	r5, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
18007a76:	4d24      	ldr	r5, [pc, #144]	; (18007b08 <sys_clock_announce+0xb4>)
18007a78:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
18007a7c:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
18007a7e:	4540      	cmp	r0, r8
18007a80:	ea4f 77e2 	mov.w	r7, r2, asr #31
		curr_tick += dt;
18007a84:	e9d5 1e00 	ldrd	r1, lr, [r5]
18007a88:	d00b      	beq.n	18007aa2 <sys_clock_announce+0x4e>
	while (first() != NULL && first()->dticks <= announce_remaining) {
18007a8a:	b150      	cbz	r0, 18007aa2 <sys_clock_announce+0x4e>
18007a8c:	e9d0 3c04 	ldrd	r3, ip, [r0, #16]
18007a90:	429a      	cmp	r2, r3
18007a92:	eb77 090c 	sbcs.w	r9, r7, ip
18007a96:	da16      	bge.n	18007ac6 <sys_clock_announce+0x72>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
18007a98:	1a9b      	subs	r3, r3, r2
18007a9a:	eb6c 0c07 	sbc.w	ip, ip, r7
18007a9e:	e9c0 3c04 	strd	r3, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
18007aa2:	1852      	adds	r2, r2, r1
18007aa4:	eb4e 0707 	adc.w	r7, lr, r7
18007aa8:	e9c5 2700 	strd	r2, r7, [r5]
	announce_remaining = 0;
18007aac:	2500      	movs	r5, #0
18007aae:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
18007ab0:	f7ff ff14 	bl	180078dc <next_timeout>
18007ab4:	4629      	mov	r1, r5
18007ab6:	f7fe f8a7 	bl	18005c08 <sys_clock_set_timeout>
	__asm__ volatile(
18007aba:	f384 8811 	msr	BASEPRI, r4
18007abe:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
18007ac2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
18007ac6:	1859      	adds	r1, r3, r1
18007ac8:	eb4e 77e3 	adc.w	r7, lr, r3, asr #31
		announce_remaining -= dt;
18007acc:	1ad3      	subs	r3, r2, r3
18007ace:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
18007ad0:	2200      	movs	r2, #0
18007ad2:	2300      	movs	r3, #0
18007ad4:	e9c0 2304 	strd	r2, r3, [r0, #16]
		curr_tick += dt;
18007ad8:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
18007adc:	f7ff ff26 	bl	1800792c <remove_timeout>
18007ae0:	f384 8811 	msr	BASEPRI, r4
18007ae4:	f3bf 8f6f 	isb	sy
		t->fn(t);
18007ae8:	6883      	ldr	r3, [r0, #8]
18007aea:	4798      	blx	r3
	__asm__ volatile(
18007aec:	f04f 0320 	mov.w	r3, #32
18007af0:	f3ef 8411 	mrs	r4, BASEPRI
18007af4:	f383 8812 	msr	BASEPRI_MAX, r3
18007af8:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
18007afc:	e7bc      	b.n	18007a78 <sys_clock_announce+0x24>
18007afe:	bf00      	nop
18007b00:	30180a54 	.word	0x30180a54
18007b04:	30180064 	.word	0x30180064
18007b08:	30180448 	.word	0x30180448

18007b0c <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
18007b0c:	b510      	push	{r4, lr}
18007b0e:	f04f 0320 	mov.w	r3, #32
18007b12:	f3ef 8411 	mrs	r4, BASEPRI
18007b16:	f383 8812 	msr	BASEPRI_MAX, r3
18007b1a:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
18007b1e:	f7fe f8bd 	bl	18005c9c <sys_clock_elapsed>
18007b22:	4a05      	ldr	r2, [pc, #20]	; (18007b38 <sys_clock_tick_get+0x2c>)
18007b24:	e9d2 3100 	ldrd	r3, r1, [r2]
18007b28:	18c0      	adds	r0, r0, r3
18007b2a:	f141 0100 	adc.w	r1, r1, #0
	__asm__ volatile(
18007b2e:	f384 8811 	msr	BASEPRI, r4
18007b32:	f3bf 8f6f 	isb	sy
	}
	return t;
}
18007b36:	bd10      	pop	{r4, pc}
18007b38:	30180448 	.word	0x30180448

18007b3c <z_impl_k_busy_wait>:
}
#include <syscalls/k_uptime_ticks_mrsh.c>
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
18007b3c:	b538      	push	{r3, r4, r5, lr}
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
18007b3e:	4604      	mov	r4, r0
18007b40:	b178      	cbz	r0, 18007b62 <z_impl_k_busy_wait+0x26>
18007b42:	f7fe f8c7 	bl	18005cd4 <sys_clock_cycle_get_32>
18007b46:	4605      	mov	r5, r0
#if !defined(CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT)
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
18007b48:	4806      	ldr	r0, [pc, #24]	; (18007b64 <z_impl_k_busy_wait+0x28>)
		(uint64_t)sys_clock_hw_cycles_per_sec() /
18007b4a:	2300      	movs	r3, #0
18007b4c:	fba4 0100 	umull	r0, r1, r4, r0
18007b50:	4a04      	ldr	r2, [pc, #16]	; (18007b64 <z_impl_k_busy_wait+0x28>)
18007b52:	f7f9 fbed 	bl	18001330 <__aeabi_uldivmod>
18007b56:	4604      	mov	r4, r0
18007b58:	f7fe f8bc 	bl	18005cd4 <sys_clock_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
18007b5c:	1b43      	subs	r3, r0, r5
18007b5e:	42a3      	cmp	r3, r4
18007b60:	d3fa      	bcc.n	18007b58 <z_impl_k_busy_wait+0x1c>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
18007b62:	bd38      	pop	{r3, r4, r5, pc}
18007b64:	000f4240 	.word	0x000f4240

18007b68 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
18007b68:	b570      	push	{r4, r5, r6, lr}
18007b6a:	4604      	mov	r4, r0
	__asm__ volatile(
18007b6c:	f04f 0320 	mov.w	r3, #32
18007b70:	f3ef 8511 	mrs	r5, BASEPRI
18007b74:	f383 8812 	msr	BASEPRI_MAX, r3
18007b78:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
18007b7c:	e9d0 320a 	ldrd	r3, r2, [r0, #40]	; 0x28
18007b80:	3301      	adds	r3, #1
18007b82:	f142 0200 	adc.w	r2, r2, #0
18007b86:	2b02      	cmp	r3, #2
18007b88:	f172 0300 	sbcs.w	r3, r2, #0
18007b8c:	d304      	bcc.n	18007b98 <z_timer_expiration_handler+0x30>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
18007b8e:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
18007b92:	4918      	ldr	r1, [pc, #96]	; (18007bf4 <z_timer_expiration_handler+0x8c>)
18007b94:	f7ff fee4 	bl	18007960 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
18007b98:	6b23      	ldr	r3, [r4, #48]	; 0x30
18007b9a:	3301      	adds	r3, #1
18007b9c:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
18007b9e:	6a23      	ldr	r3, [r4, #32]
18007ba0:	b173      	cbz	r3, 18007bc0 <z_timer_expiration_handler+0x58>
	__asm__ volatile(
18007ba2:	f385 8811 	msr	BASEPRI, r5
18007ba6:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
18007baa:	4620      	mov	r0, r4
18007bac:	6a23      	ldr	r3, [r4, #32]
18007bae:	4798      	blx	r3
	__asm__ volatile(
18007bb0:	f04f 0320 	mov.w	r3, #32
18007bb4:	f3ef 8511 	mrs	r5, BASEPRI
18007bb8:	f383 8812 	msr	BASEPRI_MAX, r3
18007bbc:	f3bf 8f6f 	isb	sy
	return list->head == list;
18007bc0:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
18007bc4:	42a6      	cmp	r6, r4
18007bc6:	d000      	beq.n	18007bca <z_timer_expiration_handler+0x62>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
18007bc8:	b926      	cbnz	r6, 18007bd4 <z_timer_expiration_handler+0x6c>
	__asm__ volatile(
18007bca:	f385 8811 	msr	BASEPRI, r5
18007bce:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
18007bd2:	bd70      	pop	{r4, r5, r6, pc}
	z_unpend_thread_no_timeout(thread);
18007bd4:	4630      	mov	r0, r6
18007bd6:	f002 ffa2 	bl	1800ab1e <z_unpend_thread_no_timeout>
18007bda:	2300      	movs	r3, #0
18007bdc:	f8c6 30b0 	str.w	r3, [r6, #176]	; 0xb0
18007be0:	f385 8811 	msr	BASEPRI, r5
18007be4:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
18007be8:	4630      	mov	r0, r6
}
18007bea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
18007bee:	f002 bfd6 	b.w	1800ab9e <z_ready_thread>
18007bf2:	bf00      	nop
18007bf4:	18007b69 	.word	0x18007b69

18007bf8 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
18007bf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
18007bfc:	4611      	mov	r1, r2
18007bfe:	4605      	mov	r5, r0
18007c00:	4618      	mov	r0, r3
18007c02:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
18007c06:	f1b0 3fff 	cmp.w	r0, #4294967295
18007c0a:	bf08      	it	eq
18007c0c:	f1b1 3fff 	cmpeq.w	r1, #4294967295
18007c10:	4688      	mov	r8, r1
18007c12:	4607      	mov	r7, r0
18007c14:	d03c      	beq.n	18007c90 <z_impl_k_timer_start+0x98>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
18007c16:	f1b3 3fff 	cmp.w	r3, #4294967295
18007c1a:	bf08      	it	eq
18007c1c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
18007c20:	4614      	mov	r4, r2
18007c22:	461e      	mov	r6, r3
18007c24:	d013      	beq.n	18007c4e <z_impl_k_timer_start+0x56>
18007c26:	431a      	orrs	r2, r3
18007c28:	d011      	beq.n	18007c4e <z_impl_k_timer_start+0x56>
	    Z_TICK_ABS(period.ticks) < 0) {
18007c2a:	f06f 0201 	mvn.w	r2, #1
18007c2e:	1b12      	subs	r2, r2, r4
18007c30:	f04f 32ff 	mov.w	r2, #4294967295
18007c34:	eb62 0203 	sbc.w	r2, r2, r3
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
18007c38:	2a00      	cmp	r2, #0
18007c3a:	da08      	bge.n	18007c4e <z_impl_k_timer_start+0x56>
		period.ticks = MAX(period.ticks - 1, 1);
18007c3c:	3c01      	subs	r4, #1
18007c3e:	f163 0600 	sbc.w	r6, r3, #0
18007c42:	2c01      	cmp	r4, #1
18007c44:	f176 0300 	sbcs.w	r3, r6, #0
18007c48:	bfbc      	itt	lt
18007c4a:	2401      	movlt	r4, #1
18007c4c:	2600      	movlt	r6, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
18007c4e:	f06f 0301 	mvn.w	r3, #1
18007c52:	1a5b      	subs	r3, r3, r1
18007c54:	f04f 33ff 	mov.w	r3, #4294967295
18007c58:	eb63 0300 	sbc.w	r3, r3, r0
18007c5c:	2b00      	cmp	r3, #0
18007c5e:	da08      	bge.n	18007c72 <z_impl_k_timer_start+0x7a>
		duration.ticks = MAX(duration.ticks - 1, 0);
18007c60:	1e4a      	subs	r2, r1, #1
18007c62:	f160 0700 	sbc.w	r7, r0, #0
18007c66:	2f00      	cmp	r7, #0
18007c68:	4690      	mov	r8, r2
18007c6a:	bfbc      	itt	lt
18007c6c:	f04f 0800 	movlt.w	r8, #0
18007c70:	4647      	movlt	r7, r8
	}

	(void)z_abort_timeout(&timer->timeout);
18007c72:	4628      	mov	r0, r5
18007c74:	f003 f83a 	bl	1800acec <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
18007c78:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
18007c7a:	4642      	mov	r2, r8
	timer->status = 0U;
18007c7c:	632b      	str	r3, [r5, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
18007c7e:	4628      	mov	r0, r5
18007c80:	463b      	mov	r3, r7
	timer->period = period;
18007c82:	e9c5 460a 	strd	r4, r6, [r5, #40]	; 0x28
		     duration);
}
18007c86:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
18007c8a:	4902      	ldr	r1, [pc, #8]	; (18007c94 <z_impl_k_timer_start+0x9c>)
18007c8c:	f7ff be68 	b.w	18007960 <z_add_timeout>
}
18007c90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
18007c94:	18007b69 	.word	0x18007b69

18007c98 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
18007c98:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
18007c9c:	461d      	mov	r5, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
18007c9e:	4b29      	ldr	r3, [pc, #164]	; (18007d44 <z_impl_k_poll+0xac>)
{
18007ca0:	4616      	mov	r6, r2
	struct z_poller *poller = &_current->poller;
18007ca2:	689f      	ldr	r7, [r3, #8]

	poller->is_polling = true;
18007ca4:	2301      	movs	r3, #1
18007ca6:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	poller->mode = MODE_POLL;
18007caa:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
18007cae:	ea52 0305 	orrs.w	r3, r2, r5
18007cb2:	bf0c      	ite	eq
18007cb4:	2301      	moveq	r3, #1
18007cb6:	2300      	movne	r3, #0
18007cb8:	f107 0260 	add.w	r2, r7, #96	; 0x60
{
18007cbc:	4680      	mov	r8, r0
	events_registered = register_events(events, num_events, poller,
18007cbe:	f003 f8a6 	bl	1800ae0e <register_events>
18007cc2:	4681      	mov	r9, r0
	__asm__ volatile(
18007cc4:	f04f 0320 	mov.w	r3, #32
18007cc8:	f3ef 8a11 	mrs	sl, BASEPRI
18007ccc:	f383 8812 	msr	BASEPRI_MAX, r3
18007cd0:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
18007cd4:	f897 4060 	ldrb.w	r4, [r7, #96]	; 0x60
18007cd8:	b964      	cbnz	r4, 18007cf4 <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
18007cda:	4601      	mov	r1, r0
18007cdc:	4652      	mov	r2, sl
18007cde:	4640      	mov	r0, r8
18007ce0:	f003 f966 	bl	1800afb0 <clear_event_registrations>
	__asm__ volatile(
18007ce4:	f38a 8811 	msr	BASEPRI, sl
18007ce8:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
18007cec:	4620      	mov	r0, r4
18007cee:	b002      	add	sp, #8
18007cf0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	poller->is_polling = false;
18007cf4:	2300      	movs	r3, #0
18007cf6:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
18007cfa:	ea56 0305 	orrs.w	r3, r6, r5
18007cfe:	d106      	bne.n	18007d0e <z_impl_k_poll+0x76>
18007d00:	f38a 8811 	msr	BASEPRI, sl
18007d04:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
18007d08:	f06f 040a 	mvn.w	r4, #10
18007d0c:	e7ee      	b.n	18007cec <z_impl_k_poll+0x54>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
18007d0e:	4651      	mov	r1, sl
18007d10:	e9cd 6500 	strd	r6, r5, [sp]
18007d14:	4a0c      	ldr	r2, [pc, #48]	; (18007d48 <z_impl_k_poll+0xb0>)
18007d16:	480d      	ldr	r0, [pc, #52]	; (18007d4c <z_impl_k_poll+0xb4>)
18007d18:	f7ff fbe8 	bl	180074ec <z_pend_curr>
18007d1c:	4604      	mov	r4, r0
	__asm__ volatile(
18007d1e:	f04f 0320 	mov.w	r3, #32
18007d22:	f3ef 8511 	mrs	r5, BASEPRI
18007d26:	f383 8812 	msr	BASEPRI_MAX, r3
18007d2a:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
18007d2e:	462a      	mov	r2, r5
18007d30:	4649      	mov	r1, r9
18007d32:	4640      	mov	r0, r8
18007d34:	f003 f93c 	bl	1800afb0 <clear_event_registrations>
	__asm__ volatile(
18007d38:	f385 8811 	msr	BASEPRI, r5
18007d3c:	f3bf 8f6f 	isb	sy
	return swap_rc;
18007d40:	e7d4      	b.n	18007cec <z_impl_k_poll+0x54>
18007d42:	bf00      	nop
18007d44:	30180a20 	.word	0x30180a20
18007d48:	3018006c 	.word	0x3018006c
18007d4c:	30180a88 	.word	0x30180a88

18007d50 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
18007d50:	b538      	push	{r3, r4, r5, lr}
18007d52:	4603      	mov	r3, r0
	__asm__ volatile(
18007d54:	f04f 0220 	mov.w	r2, #32
18007d58:	f3ef 8511 	mrs	r5, BASEPRI
18007d5c:	f382 8812 	msr	BASEPRI_MAX, r2
18007d60:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
18007d64:	60c1      	str	r1, [r0, #12]
	sig->signaled = 1U;
18007d66:	2101      	movs	r1, #1
18007d68:	6081      	str	r1, [r0, #8]
	return list->head == list;
18007d6a:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
18007d6c:	4283      	cmp	r3, r0
18007d6e:	d106      	bne.n	18007d7e <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
18007d70:	f385 8811 	msr	BASEPRI, r5
18007d74:	f3bf 8f6f 	isb	sy
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
18007d78:	2400      	movs	r4, #0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
	return rc;
}
18007d7a:	4620      	mov	r0, r4
18007d7c:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const next = node->next;
18007d7e:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
18007d82:	6013      	str	r3, [r2, #0]
	next->prev = prev;
18007d84:	605a      	str	r2, [r3, #4]
	node->next = NULL;
18007d86:	2300      	movs	r3, #0
	node->prev = NULL;
18007d88:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
18007d8c:	f003 f8b6 	bl	1800aefc <signal_poll_event>
	z_reschedule(&lock, key);
18007d90:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
18007d92:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
18007d94:	4801      	ldr	r0, [pc, #4]	; (18007d9c <z_impl_k_poll_signal_raise+0x4c>)
18007d96:	f7ff fa57 	bl	18007248 <z_reschedule>
	return rc;
18007d9a:	e7ee      	b.n	18007d7a <z_impl_k_poll_signal_raise+0x2a>
18007d9c:	30180a88 	.word	0x30180a88

18007da0 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
18007da0:	4a02      	ldr	r2, [pc, #8]	; (18007dac <boot_banner+0xc>)
18007da2:	4903      	ldr	r1, [pc, #12]	; (18007db0 <boot_banner+0x10>)
18007da4:	4803      	ldr	r0, [pc, #12]	; (18007db4 <boot_banner+0x14>)
18007da6:	f000 b967 	b.w	18008078 <printk>
18007daa:	bf00      	nop
18007dac:	1800ccbe 	.word	0x1800ccbe
18007db0:	1800dde9 	.word	0x1800dde9
18007db4:	1800de04 	.word	0x1800de04

18007db8 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
18007db8:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
18007dba:	4c06      	ldr	r4, [pc, #24]	; (18007dd4 <statics_init+0x1c>)
18007dbc:	4d06      	ldr	r5, [pc, #24]	; (18007dd8 <statics_init+0x20>)
18007dbe:	42ac      	cmp	r4, r5
18007dc0:	d301      	bcc.n	18007dc6 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
18007dc2:	2000      	movs	r0, #0
18007dc4:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
18007dc6:	4620      	mov	r0, r4
18007dc8:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
18007dcc:	f003 f949 	bl	1800b062 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
18007dd0:	3414      	adds	r4, #20
18007dd2:	e7f4      	b.n	18007dbe <statics_init+0x6>
18007dd4:	301800a8 	.word	0x301800a8
18007dd8:	301800a8 	.word	0x301800a8

18007ddc <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
18007ddc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
18007dde:	2400      	movs	r4, #0
18007de0:	4b08      	ldr	r3, [pc, #32]	; (18007e04 <k_sys_work_q_init+0x28>)
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
18007de2:	f44f 6280 	mov.w	r2, #1024	; 0x400
	struct k_work_queue_config cfg = {
18007de6:	9302      	str	r3, [sp, #8]
	k_work_queue_start(&k_sys_work_q,
18007de8:	ab02      	add	r3, sp, #8
18007dea:	9300      	str	r3, [sp, #0]
18007dec:	4906      	ldr	r1, [pc, #24]	; (18007e08 <k_sys_work_q_init+0x2c>)
18007dee:	f04f 33ff 	mov.w	r3, #4294967295
18007df2:	4806      	ldr	r0, [pc, #24]	; (18007e0c <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
18007df4:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
18007df8:	f000 f8f0 	bl	18007fdc <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
18007dfc:	4620      	mov	r0, r4
18007dfe:	b004      	add	sp, #16
18007e00:	bd10      	pop	{r4, pc}
18007e02:	bf00      	nop
18007e04:	1800de2b 	.word	0x1800de2b
18007e08:	30182a98 	.word	0x30182a98
18007e0c:	30180450 	.word	0x30180450

18007e10 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
18007e10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
18007e14:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
18007e16:	f04f 38ff 	mov.w	r8, #4294967295
18007e1a:	f04f 39ff 	mov.w	r9, #4294967295
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
18007e1e:	4e45      	ldr	r6, [pc, #276]	; (18007f34 <work_queue_main+0x124>)
{
18007e20:	b085      	sub	sp, #20
	__asm__ volatile(
18007e22:	f04f 0320 	mov.w	r3, #32
18007e26:	f3ef 8711 	mrs	r7, BASEPRI
18007e2a:	f383 8812 	msr	BASEPRI_MAX, r3
18007e2e:	f3bf 8f6f 	isb	sy
18007e32:	f8d4 50b8 	ldr.w	r5, [r4, #184]	; 0xb8
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
18007e36:	b98d      	cbnz	r5, 18007e5c <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
18007e38:	2102      	movs	r1, #2
18007e3a:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
18007e3e:	f003 f918 	bl	1800b072 <flag_test_and_clear>
18007e42:	2800      	cmp	r0, #0
18007e44:	d135      	bne.n	18007eb2 <work_queue_main+0xa2>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
18007e46:	2300      	movs	r3, #0
18007e48:	4639      	mov	r1, r7
18007e4a:	e9cd 8900 	strd	r8, r9, [sp]
18007e4e:	9302      	str	r3, [sp, #8]
18007e50:	f104 02c0 	add.w	r2, r4, #192	; 0xc0
18007e54:	4838      	ldr	r0, [pc, #224]	; (18007f38 <work_queue_main+0x128>)
18007e56:	f7ff fd0b 	bl	18007870 <z_sched_wait>
			continue;
18007e5a:	e7e2      	b.n	18007e22 <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
18007e5c:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
	return node->next;
18007e60:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
18007e62:	4295      	cmp	r5, r2
	list->head = node;
18007e64:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
18007e68:	d101      	bne.n	18007e6e <work_queue_main+0x5e>
	list->tail = node;
18007e6a:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
	*flagp |= BIT(bit);
18007e6e:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
18007e72:	f043 0302 	orr.w	r3, r3, #2
18007e76:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	*flagp &= ~BIT(bit);
18007e7a:	68eb      	ldr	r3, [r5, #12]
18007e7c:	f023 0304 	bic.w	r3, r3, #4
18007e80:	f043 0301 	orr.w	r3, r3, #1
18007e84:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
18007e86:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
18007e88:	f387 8811 	msr	BASEPRI, r7
18007e8c:	f3bf 8f6f 	isb	sy

		if (work != NULL) {
			bool yield;

			__ASSERT_NO_MSG(handler != NULL);
			handler(work);
18007e90:	4628      	mov	r0, r5
18007e92:	4798      	blx	r3
	__asm__ volatile(
18007e94:	f04f 0320 	mov.w	r3, #32
18007e98:	f3ef 8b11 	mrs	fp, BASEPRI
18007e9c:	f383 8812 	msr	BASEPRI_MAX, r3
18007ea0:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
18007ea4:	68eb      	ldr	r3, [r5, #12]
			 * starving other threads.
			 */
			key = k_spin_lock(&lock);

			flag_clear(&work->flags, K_WORK_RUNNING_BIT);
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
18007ea6:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
18007ea8:	f023 0201 	bic.w	r2, r3, #1
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
18007eac:	d40b      	bmi.n	18007ec6 <work_queue_main+0xb6>
	*flagp &= ~BIT(bit);
18007eae:	60ea      	str	r2, [r5, #12]
18007eb0:	e00e      	b.n	18007ed0 <work_queue_main+0xc0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
18007eb2:	f104 05c8 	add.w	r5, r4, #200	; 0xc8
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
18007eb6:	2200      	movs	r2, #0
18007eb8:	2101      	movs	r1, #1
18007eba:	4628      	mov	r0, r5
18007ebc:	f002 fef8 	bl	1800acb0 <z_sched_wake>
18007ec0:	2800      	cmp	r0, #0
18007ec2:	d1f8      	bne.n	18007eb6 <work_queue_main+0xa6>
18007ec4:	e7bf      	b.n	18007e46 <work_queue_main+0x36>
	return list->head;
18007ec6:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
18007ec8:	f023 0303 	bic.w	r3, r3, #3
18007ecc:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
18007ece:	b970      	cbnz	r0, 18007eee <work_queue_main+0xde>
	*flagp &= ~BIT(bit);
18007ed0:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
18007ed4:	f023 0302 	bic.w	r3, r3, #2
18007ed8:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	__asm__ volatile(
18007edc:	f38b 8811 	msr	BASEPRI, fp
18007ee0:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&lock, key);

			/* Optionally yield to prevent the work queue from
			 * starving other threads.
			 */
			if (yield) {
18007ee4:	05d8      	lsls	r0, r3, #23
18007ee6:	d49c      	bmi.n	18007e22 <work_queue_main+0x12>
	z_impl_k_yield();
18007ee8:	f7ff fbb6 	bl	18007658 <z_impl_k_yield>
}
18007eec:	e799      	b.n	18007e22 <work_queue_main+0x12>
	return node->next;
18007eee:	2700      	movs	r7, #0
	parent->next = child;
18007ef0:	463b      	mov	r3, r7
	return node->next;
18007ef2:	f8d0 a000 	ldr.w	sl, [r0]
		if (wc->work == work) {
18007ef6:	6842      	ldr	r2, [r0, #4]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
18007ef8:	4601      	mov	r1, r0
		if (wc->work == work) {
18007efa:	4295      	cmp	r5, r2
18007efc:	d10c      	bne.n	18007f18 <work_queue_main+0x108>
18007efe:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
18007f00:	b997      	cbnz	r7, 18007f28 <work_queue_main+0x118>
18007f02:	6872      	ldr	r2, [r6, #4]
	list->head = node;
18007f04:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
18007f06:	4282      	cmp	r2, r0
18007f08:	d100      	bne.n	18007f0c <work_queue_main+0xfc>
	list->tail = node;
18007f0a:	6071      	str	r1, [r6, #4]
	parent->next = child;
18007f0c:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
18007f10:	f7ff f90e 	bl	18007130 <z_impl_k_sem_give>
}
18007f14:	4639      	mov	r1, r7
18007f16:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
18007f18:	f1ba 0f00 	cmp.w	sl, #0
18007f1c:	d0d8      	beq.n	18007ed0 <work_queue_main+0xc0>
	return node->next;
18007f1e:	4650      	mov	r0, sl
18007f20:	460f      	mov	r7, r1
18007f22:	f8da a000 	ldr.w	sl, [sl]
18007f26:	e7e6      	b.n	18007ef6 <work_queue_main+0xe6>
	return list->tail;
18007f28:	6872      	ldr	r2, [r6, #4]
	parent->next = child;
18007f2a:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
18007f2c:	4290      	cmp	r0, r2
	list->tail = node;
18007f2e:	bf08      	it	eq
18007f30:	6077      	streq	r7, [r6, #4]
}
18007f32:	e7eb      	b.n	18007f0c <work_queue_main+0xfc>
18007f34:	30180a58 	.word	0x30180a58
18007f38:	30180a88 	.word	0x30180a88

18007f3c <submit_to_queue_locked>:
{
18007f3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
18007f3e:	68c3      	ldr	r3, [r0, #12]
{
18007f40:	4604      	mov	r4, r0
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
18007f42:	079a      	lsls	r2, r3, #30
{
18007f44:	460e      	mov	r6, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
18007f46:	f3c3 0540 	ubfx	r5, r3, #1, #1
18007f4a:	d41f      	bmi.n	18007f8c <submit_to_queue_locked+0x50>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
18007f4c:	075f      	lsls	r7, r3, #29
18007f4e:	d41f      	bmi.n	18007f90 <submit_to_queue_locked+0x54>
		if (*queuep == NULL) {
18007f50:	680a      	ldr	r2, [r1, #0]
18007f52:	b90a      	cbnz	r2, 18007f58 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
18007f54:	6882      	ldr	r2, [r0, #8]
18007f56:	600a      	str	r2, [r1, #0]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
18007f58:	07d8      	lsls	r0, r3, #31
			*queuep = work->queue;
18007f5a:	bf42      	ittt	mi
18007f5c:	68a3      	ldrmi	r3, [r4, #8]
			ret = 2;
18007f5e:	2502      	movmi	r5, #2
			*queuep = work->queue;
18007f60:	6033      	strmi	r3, [r6, #0]
		int rc = queue_submit_locked(*queuep, work);
18007f62:	6837      	ldr	r7, [r6, #0]
		ret = 1;
18007f64:	bf58      	it	pl
18007f66:	2501      	movpl	r5, #1
	if (queue == NULL) {
18007f68:	b37f      	cbz	r7, 18007fca <submit_to_queue_locked+0x8e>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
18007f6a:	4b1b      	ldr	r3, [pc, #108]	; (18007fd8 <submit_to_queue_locked+0x9c>)
18007f6c:	689b      	ldr	r3, [r3, #8]
18007f6e:	42bb      	cmp	r3, r7
18007f70:	d111      	bne.n	18007f96 <submit_to_queue_locked+0x5a>
18007f72:	f002 fd6c 	bl	1800aa4e <k_is_in_isr>
18007f76:	f080 0001 	eor.w	r0, r0, #1
18007f7a:	b2c0      	uxtb	r0, r0
	return (*flagp & BIT(bit)) != 0U;
18007f7c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
18007f80:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
18007f82:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
18007f86:	d523      	bpl.n	18007fd0 <submit_to_queue_locked+0x94>
	} else if (draining && !chained) {
18007f88:	b13a      	cbz	r2, 18007f9a <submit_to_queue_locked+0x5e>
18007f8a:	b940      	cbnz	r0, 18007f9e <submit_to_queue_locked+0x62>
		ret = -EBUSY;
18007f8c:	f06f 050f 	mvn.w	r5, #15
		*queuep = NULL;
18007f90:	2300      	movs	r3, #0
18007f92:	6033      	str	r3, [r6, #0]
	return ret;
18007f94:	e013      	b.n	18007fbe <submit_to_queue_locked+0x82>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
18007f96:	2000      	movs	r0, #0
18007f98:	e7f0      	b.n	18007f7c <submit_to_queue_locked+0x40>
	} else if (plugged && !draining) {
18007f9a:	071b      	lsls	r3, r3, #28
18007f9c:	d4f6      	bmi.n	18007f8c <submit_to_queue_locked+0x50>
	parent->next = child;
18007f9e:	2300      	movs	r3, #0
18007fa0:	6023      	str	r3, [r4, #0]
	return list->tail;
18007fa2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
Z_GENLIST_APPEND(slist, snode)
18007fa6:	b963      	cbnz	r3, 18007fc2 <submit_to_queue_locked+0x86>
	list->head = node;
18007fa8:	e9c7 442e 	strd	r4, r4, [r7, #184]	; 0xb8
		(void)notify_queue_locked(queue);
18007fac:	4638      	mov	r0, r7
18007fae:	f003 f86b 	bl	1800b088 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
18007fb2:	68e3      	ldr	r3, [r4, #12]
18007fb4:	f043 0304 	orr.w	r3, r3, #4
18007fb8:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
18007fba:	6833      	ldr	r3, [r6, #0]
18007fbc:	60a3      	str	r3, [r4, #8]
}
18007fbe:	4628      	mov	r0, r5
18007fc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
18007fc2:	601c      	str	r4, [r3, #0]
	list->tail = node;
18007fc4:	f8c7 40bc 	str.w	r4, [r7, #188]	; 0xbc
}
18007fc8:	e7f0      	b.n	18007fac <submit_to_queue_locked+0x70>
		return -EINVAL;
18007fca:	f06f 0515 	mvn.w	r5, #21
18007fce:	e7df      	b.n	18007f90 <submit_to_queue_locked+0x54>
		ret = -ENODEV;
18007fd0:	f06f 0512 	mvn.w	r5, #18
18007fd4:	e7dc      	b.n	18007f90 <submit_to_queue_locked+0x54>
18007fd6:	bf00      	nop
18007fd8:	30180a20 	.word	0x30180a20

18007fdc <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
18007fdc:	b5f0      	push	{r4, r5, r6, r7, lr}
18007fde:	4604      	mov	r4, r0
	list->head = NULL;
18007fe0:	2000      	movs	r0, #0
18007fe2:	b089      	sub	sp, #36	; 0x24
	list->tail = NULL;
18007fe4:	e9c4 002e 	strd	r0, r0, [r4, #184]	; 0xb8
18007fe8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
	sys_dlist_init(&w->waitq);
18007fea:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
	list->tail = (sys_dnode_t *)list;
18007fee:	e9c4 0030 	strd	r0, r0, [r4, #192]	; 0xc0
18007ff2:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
18007ff6:	e9c4 0032 	strd	r0, r0, [r4, #200]	; 0xc8

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
18007ffa:	b31d      	cbz	r5, 18008044 <k_work_queue_start+0x68>
18007ffc:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
18007ffe:	2800      	cmp	r0, #0
18008000:	f240 1001 	movw	r0, #257	; 0x101
18008004:	bf08      	it	eq
18008006:	2001      	moveq	r0, #1
	*flagp = flags;
18008008:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
1800800c:	2000      	movs	r0, #0
1800800e:	f04f 36ff 	mov.w	r6, #4294967295
18008012:	f04f 37ff 	mov.w	r7, #4294967295
18008016:	e9cd 3003 	strd	r3, r0, [sp, #12]
1800801a:	e9cd 0001 	strd	r0, r0, [sp, #4]
1800801e:	e9cd 6706 	strd	r6, r7, [sp, #24]
18008022:	4620      	mov	r0, r4
18008024:	4b08      	ldr	r3, [pc, #32]	; (18008048 <k_work_queue_start+0x6c>)
18008026:	9400      	str	r4, [sp, #0]
18008028:	f7fe fe98 	bl	18006d5c <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
1800802c:	b125      	cbz	r5, 18008038 <k_work_queue_start+0x5c>
1800802e:	6829      	ldr	r1, [r5, #0]
18008030:	b111      	cbz	r1, 18008038 <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
18008032:	4620      	mov	r0, r4
18008034:	f7fe fde8 	bl	18006c08 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
18008038:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
1800803a:	b009      	add	sp, #36	; 0x24
1800803c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
18008040:	f002 bd0d 	b.w	1800aa5e <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
18008044:	2001      	movs	r0, #1
18008046:	e7df      	b.n	18008008 <k_work_queue_start+0x2c>
18008048:	18007e11 	.word	0x18007e11

1800804c <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
1800804c:	4770      	bx	lr

1800804e <arch_printk_char_out>:
}
1800804e:	2000      	movs	r0, #0
18008050:	4770      	bx	lr

18008052 <str_out>:
{
18008052:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
18008054:	688a      	ldr	r2, [r1, #8]
18008056:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
18008058:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
1800805a:	b114      	cbz	r4, 18008062 <str_out+0x10>
1800805c:	684b      	ldr	r3, [r1, #4]
1800805e:	4293      	cmp	r3, r2
18008060:	dc01      	bgt.n	18008066 <str_out+0x14>
		ctx->count++;
18008062:	608d      	str	r5, [r1, #8]
}
18008064:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
18008066:	3b01      	subs	r3, #1
18008068:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
1800806a:	bf08      	it	eq
1800806c:	2200      	moveq	r2, #0
1800806e:	608d      	str	r5, [r1, #8]
18008070:	bf0c      	ite	eq
18008072:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
18008074:	54a0      	strbne	r0, [r4, r2]
18008076:	e7f5      	b.n	18008064 <str_out+0x12>

18008078 <printk>:
{
18008078:	b40f      	push	{r0, r1, r2, r3}
1800807a:	b507      	push	{r0, r1, r2, lr}
1800807c:	a904      	add	r1, sp, #16
1800807e:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
18008082:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
18008084:	f7f9 fbb6 	bl	180017f4 <vprintk>
}
18008088:	b003      	add	sp, #12
1800808a:	f85d eb04 	ldr.w	lr, [sp], #4
1800808e:	b004      	add	sp, #16
18008090:	4770      	bx	lr

18008092 <snprintk>:
{
18008092:	b40c      	push	{r2, r3}
18008094:	b507      	push	{r0, r1, r2, lr}
18008096:	ab04      	add	r3, sp, #16
18008098:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
1800809c:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
1800809e:	f7f9 fbb7 	bl	18001810 <vsnprintk>
}
180080a2:	b003      	add	sp, #12
180080a4:	f85d eb04 	ldr.w	lr, [sp], #4
180080a8:	b002      	add	sp, #8
180080aa:	4770      	bx	lr

180080ac <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
180080ac:	4604      	mov	r4, r0
180080ae:	b508      	push	{r3, lr}
180080b0:	4608      	mov	r0, r1
180080b2:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
180080b4:	461a      	mov	r2, r3
180080b6:	47a0      	blx	r4
	return z_impl_z_current_get();
180080b8:	f7ff fb6e 	bl	18007798 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
180080bc:	f7fd fab2 	bl	18005624 <z_impl_k_thread_abort>

180080c0 <chunk_field>:
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
180080c0:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
180080c2:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
180080c6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((uint32_t *)cmem)[f];
180080ca:	bf2c      	ite	cs
180080cc:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((uint16_t *)cmem)[f];
180080d0:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
180080d4:	4770      	bx	lr

180080d6 <chunk_set>:
			     enum chunk_fields f, chunkid_t val)
{
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
180080d6:	eb00 01c1 	add.w	r1, r0, r1, lsl #3

	if (big_heap(h)) {
180080da:	6880      	ldr	r0, [r0, #8]
180080dc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
180080e0:	bf2c      	ite	cs
180080e2:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
180080e6:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
180080ea:	4770      	bx	lr

180080ec <chunk_size>:
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
180080ec:	2201      	movs	r2, #1
{
180080ee:	b508      	push	{r3, lr}
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
180080f0:	f7ff ffe6 	bl	180080c0 <chunk_field>
}
180080f4:	40d0      	lsrs	r0, r2
180080f6:	bd08      	pop	{r3, pc}

180080f8 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
180080f8:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
180080fa:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
180080fe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
18008102:	d308      	bcc.n	18008116 <set_chunk_used+0x1e>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
18008104:	684b      	ldr	r3, [r1, #4]
		if (used) {
18008106:	b11a      	cbz	r2, 18008110 <set_chunk_used+0x18>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
18008108:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
1800810c:	604b      	str	r3, [r1, #4]
1800810e:	4770      	bx	lr
18008110:	f023 0301 	bic.w	r3, r3, #1
18008114:	e7fa      	b.n	1800810c <set_chunk_used+0x14>
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
18008116:	884b      	ldrh	r3, [r1, #2]
		if (used) {
18008118:	b11a      	cbz	r2, 18008122 <set_chunk_used+0x2a>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
1800811a:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
1800811e:	804b      	strh	r3, [r1, #2]
		}
	}
}
18008120:	4770      	bx	lr
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
18008122:	f023 0301 	bic.w	r3, r3, #1
18008126:	e7fa      	b.n	1800811e <set_chunk_used+0x26>

18008128 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
18008128:	0053      	lsls	r3, r2, #1
1800812a:	2201      	movs	r2, #1
1800812c:	f7ff bfd3 	b.w	180080d6 <chunk_set>

18008130 <bucket_idx.isra.0>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
18008130:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
18008134:	bf2c      	ite	cs
18008136:	2008      	movcs	r0, #8
18008138:	2004      	movcc	r0, #4
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
1800813a:	3101      	adds	r1, #1
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
1800813c:	3008      	adds	r0, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
1800813e:	eba1 00d0 	sub.w	r0, r1, r0, lsr #3
	return 31 - __builtin_clz(usable_sz);
18008142:	fab0 f080 	clz	r0, r0
}
18008146:	f1c0 001f 	rsb	r0, r0, #31
1800814a:	4770      	bx	lr

1800814c <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
1800814c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
18008150:	460d      	mov	r5, r1
	return big_heap_chunks(h->end_chunk);
18008152:	6886      	ldr	r6, [r0, #8]
18008154:	4604      	mov	r4, r0
	return big_heap(h) && chunk_size(h, c) == 1U;
18008156:	f7ff ffc9 	bl	180080ec <chunk_size>
1800815a:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
1800815e:	4601      	mov	r1, r0
18008160:	d301      	bcc.n	18008166 <free_list_add+0x1a>
	if (!solo_free_header(h, c)) {
18008162:	2801      	cmp	r0, #1
18008164:	d033      	beq.n	180081ce <free_list_add+0x82>
		int bidx = bucket_idx(h, chunk_size(h, c));
18008166:	4630      	mov	r0, r6
18008168:	f7ff ffe2 	bl	18008130 <bucket_idx.isra.0>
	if (b->next == 0U) {
1800816c:	eb04 0280 	add.w	r2, r4, r0, lsl #2
18008170:	6916      	ldr	r6, [r2, #16]
18008172:	b99e      	cbnz	r6, 1800819c <free_list_add+0x50>
		h->avail_buckets |= (1 << bidx);
18008174:	2301      	movs	r3, #1
18008176:	fa03 f000 	lsl.w	r0, r3, r0
1800817a:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, FREE_PREV, prev);
1800817c:	4629      	mov	r1, r5
1800817e:	4303      	orrs	r3, r0
18008180:	60e3      	str	r3, [r4, #12]
18008182:	4620      	mov	r0, r4
		b->next = c;
18008184:	6115      	str	r5, [r2, #16]
18008186:	462b      	mov	r3, r5
18008188:	2202      	movs	r2, #2
1800818a:	f7ff ffa4 	bl	180080d6 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
1800818e:	2203      	movs	r2, #3
18008190:	4629      	mov	r1, r5
	chunk_set(h, c, FREE_PREV, prev);
18008192:	4620      	mov	r0, r4
		free_list_add_bidx(h, c, bidx);
	}
}
18008194:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
18008198:	f7ff bf9d 	b.w	180080d6 <chunk_set>
	return chunk_field(h, c, FREE_PREV);
1800819c:	2202      	movs	r2, #2
1800819e:	4631      	mov	r1, r6
180081a0:	4620      	mov	r0, r4
180081a2:	f7ff ff8d 	bl	180080c0 <chunk_field>
180081a6:	4607      	mov	r7, r0
	chunk_set(h, c, FREE_PREV, prev);
180081a8:	4603      	mov	r3, r0
180081aa:	4629      	mov	r1, r5
180081ac:	4620      	mov	r0, r4
180081ae:	f7ff ff92 	bl	180080d6 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
180081b2:	2203      	movs	r2, #3
180081b4:	4633      	mov	r3, r6
180081b6:	4629      	mov	r1, r5
180081b8:	4620      	mov	r0, r4
180081ba:	f7ff ff8c 	bl	180080d6 <chunk_set>
180081be:	4639      	mov	r1, r7
180081c0:	462b      	mov	r3, r5
180081c2:	4620      	mov	r0, r4
180081c4:	f7ff ff87 	bl	180080d6 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
180081c8:	2202      	movs	r2, #2
180081ca:	4631      	mov	r1, r6
180081cc:	e7e1      	b.n	18008192 <free_list_add+0x46>
180081ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

180081d2 <sys_heap_init>:
	return big_heap_bytes(size) ? 8 : 4;
180081d2:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
180081d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
180081d8:	bf2c      	ite	cs
180081da:	2408      	movcs	r4, #8
180081dc:	2404      	movcc	r4, #4
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
180081de:	2300      	movs	r3, #0
	bytes -= heap_footer_bytes(bytes);
180081e0:	1b14      	subs	r4, r2, r4
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
180081e2:	1dce      	adds	r6, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
180081e4:	440c      	add	r4, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
180081e6:	f026 0607 	bic.w	r6, r6, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
180081ea:	f024 0407 	bic.w	r4, r4, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
180081ee:	1ba4      	subs	r4, r4, r6
180081f0:	08e4      	lsrs	r4, r4, #3
	heap->heap = h;
180081f2:	6006      	str	r6, [r0, #0]
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
180081f4:	4621      	mov	r1, r4
180081f6:	4620      	mov	r0, r4
	h->end_chunk = heap_sz;
180081f8:	60b4      	str	r4, [r6, #8]
	h->avail_buckets = 0;
180081fa:	60f3      	str	r3, [r6, #12]
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
180081fc:	f7ff ff98 	bl	18008130 <bucket_idx.isra.0>
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
18008200:	0085      	lsls	r5, r0, #2
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
18008202:	1c41      	adds	r1, r0, #1
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
18008204:	4618      	mov	r0, r3
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
18008206:	351b      	adds	r5, #27
18008208:	08ed      	lsrs	r5, r5, #3
	for (int i = 0; i < nb_buckets; i++) {
1800820a:	f106 0210 	add.w	r2, r6, #16
1800820e:	428b      	cmp	r3, r1
18008210:	db2e      	blt.n	18008270 <sys_heap_init+0x9e>
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
18008212:	462a      	mov	r2, r5
18008214:	4630      	mov	r0, r6
18008216:	2100      	movs	r1, #0
18008218:	f7ff ff86 	bl	18008128 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
1800821c:	2300      	movs	r3, #0
1800821e:	4630      	mov	r0, r6
18008220:	461a      	mov	r2, r3
18008222:	4619      	mov	r1, r3
18008224:	f7ff ff57 	bl	180080d6 <chunk_set>
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
18008228:	1b67      	subs	r7, r4, r5
	set_chunk_used(h, 0, true);
1800822a:	4619      	mov	r1, r3
1800822c:	4630      	mov	r0, r6
1800822e:	2201      	movs	r2, #1
18008230:	f7ff ff62 	bl	180080f8 <set_chunk_used>
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
18008234:	463a      	mov	r2, r7
18008236:	4629      	mov	r1, r5
18008238:	f7ff ff76 	bl	18008128 <set_chunk_size>
1800823c:	462b      	mov	r3, r5
1800823e:	2200      	movs	r2, #0
18008240:	4629      	mov	r1, r5
18008242:	4630      	mov	r0, r6
18008244:	f7ff ff47 	bl	180080d6 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
18008248:	4621      	mov	r1, r4
1800824a:	4630      	mov	r0, r6
1800824c:	f7ff ff6c 	bl	18008128 <set_chunk_size>
18008250:	463b      	mov	r3, r7
18008252:	4621      	mov	r1, r4
18008254:	4630      	mov	r0, r6
18008256:	2200      	movs	r2, #0
18008258:	f7ff ff3d 	bl	180080d6 <chunk_set>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
1800825c:	4621      	mov	r1, r4
1800825e:	4630      	mov	r0, r6
18008260:	2201      	movs	r2, #1
18008262:	f7ff ff49 	bl	180080f8 <set_chunk_used>

	free_list_add(h, chunk0_size);
18008266:	4629      	mov	r1, r5
}
18008268:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, chunk0_size);
1800826c:	f7ff bf6e 	b.w	1800814c <free_list_add>
		h->buckets[i].next = 0;
18008270:	f842 0b04 	str.w	r0, [r2], #4
	for (int i = 0; i < nb_buckets; i++) {
18008274:	3301      	adds	r3, #1
18008276:	e7ca      	b.n	1800820e <sys_heap_init+0x3c>

18008278 <encode_uint>:
{
18008278:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
1800827c:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
1800827e:	78d3      	ldrb	r3, [r2, #3]
{
18008280:	4680      	mov	r8, r0
	switch (specifier) {
18008282:	2b6f      	cmp	r3, #111	; 0x6f
{
18008284:	460f      	mov	r7, r1
18008286:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
18008288:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
1800828c:	d029      	beq.n	180082e2 <encode_uint+0x6a>
1800828e:	d824      	bhi.n	180082da <encode_uint+0x62>
		return 16;
18008290:	2b58      	cmp	r3, #88	; 0x58
18008292:	bf14      	ite	ne
18008294:	260a      	movne	r6, #10
18008296:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
18008298:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
1800829c:	4632      	mov	r2, r6
1800829e:	2300      	movs	r3, #0
180082a0:	4640      	mov	r0, r8
180082a2:	4639      	mov	r1, r7
180082a4:	f7f9 f844 	bl	18001330 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
180082a8:	2a09      	cmp	r2, #9
180082aa:	b2d4      	uxtb	r4, r2
180082ac:	d81e      	bhi.n	180082ec <encode_uint+0x74>
180082ae:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
180082b0:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
180082b2:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
180082b4:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
180082b8:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
180082bc:	d301      	bcc.n	180082c2 <encode_uint+0x4a>
180082be:	45d1      	cmp	r9, sl
180082c0:	d811      	bhi.n	180082e6 <encode_uint+0x6e>
	if (conv->flag_hash) {
180082c2:	782b      	ldrb	r3, [r5, #0]
180082c4:	069b      	lsls	r3, r3, #26
180082c6:	d505      	bpl.n	180082d4 <encode_uint+0x5c>
		if (radix == 8) {
180082c8:	2e08      	cmp	r6, #8
180082ca:	d115      	bne.n	180082f8 <encode_uint+0x80>
			conv->altform_0 = true;
180082cc:	78ab      	ldrb	r3, [r5, #2]
180082ce:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
180082d2:	70ab      	strb	r3, [r5, #2]
}
180082d4:	4648      	mov	r0, r9
180082d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
180082da:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
180082de:	2b70      	cmp	r3, #112	; 0x70
180082e0:	e7d7      	b.n	18008292 <encode_uint+0x1a>
	switch (specifier) {
180082e2:	2608      	movs	r6, #8
180082e4:	e7d8      	b.n	18008298 <encode_uint+0x20>
		value /= radix;
180082e6:	4680      	mov	r8, r0
180082e8:	460f      	mov	r7, r1
180082ea:	e7d7      	b.n	1800829c <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
180082ec:	f1bb 0f19 	cmp.w	fp, #25
180082f0:	bf94      	ite	ls
180082f2:	3437      	addls	r4, #55	; 0x37
180082f4:	3457      	addhi	r4, #87	; 0x57
180082f6:	e7db      	b.n	180082b0 <encode_uint+0x38>
		} else if (radix == 16) {
180082f8:	2e10      	cmp	r6, #16
180082fa:	d1eb      	bne.n	180082d4 <encode_uint+0x5c>
			conv->altform_0c = true;
180082fc:	78ab      	ldrb	r3, [r5, #2]
180082fe:	f043 0310 	orr.w	r3, r3, #16
18008302:	e7e6      	b.n	180082d2 <encode_uint+0x5a>

18008304 <outs>:
{
18008304:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
18008308:	4607      	mov	r7, r0
1800830a:	4688      	mov	r8, r1
1800830c:	4615      	mov	r5, r2
1800830e:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
18008310:	4614      	mov	r4, r2
18008312:	42b4      	cmp	r4, r6
18008314:	eba4 0005 	sub.w	r0, r4, r5
18008318:	d302      	bcc.n	18008320 <outs+0x1c>
1800831a:	b93e      	cbnz	r6, 1800832c <outs+0x28>
1800831c:	7823      	ldrb	r3, [r4, #0]
1800831e:	b12b      	cbz	r3, 1800832c <outs+0x28>
		int rc = out((int)*sp++, ctx);
18008320:	4641      	mov	r1, r8
18008322:	f814 0b01 	ldrb.w	r0, [r4], #1
18008326:	47b8      	blx	r7
		if (rc < 0) {
18008328:	2800      	cmp	r0, #0
1800832a:	daf2      	bge.n	18008312 <outs+0xe>
}
1800832c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

18008330 <ring_buf_get_rewind_threshold>:
 * rewinding earlier.
 */
uint32_t __weak ring_buf_get_rewind_threshold(void)
{
	return RING_BUFFER_MAX_SIZE;
}
18008330:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
18008334:	4770      	bx	lr

18008336 <ring_buf_put_claim>:
{
	return val >= max ? (val - max) : val;
}

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
18008336:	b5f0      	push	{r4, r5, r6, r7, lr}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
18008338:	6985      	ldr	r5, [r0, #24]
{
1800833a:	4604      	mov	r4, r0
	uint32_t space, trail_size, allocated, tmp_trail_mod;

	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
1800833c:	6886      	ldr	r6, [r0, #8]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
1800833e:	6907      	ldr	r7, [r0, #16]
18008340:	b185      	cbz	r5, 18008364 <ring_buf_put_claim+0x2e>
18008342:	4035      	ands	r5, r6
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
18008344:	6823      	ldr	r3, [r4, #0]
18008346:	443b      	add	r3, r7
18008348:	1b98      	subs	r0, r3, r6
	trail_size = buf->size - tmp_trail_mod;

	/* Limit requested size to available size. */
	size = MIN(size, space);
1800834a:	4290      	cmp	r0, r2
1800834c:	bf28      	it	cs
1800834e:	4610      	movcs	r0, r2
	trail_size = buf->size - tmp_trail_mod;
18008350:	1b7f      	subs	r7, r7, r5

	trail_size = buf->size - (tmp_trail_mod);

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
18008352:	42b8      	cmp	r0, r7
18008354:	bf28      	it	cs
18008356:	4638      	movcs	r0, r7
	*data = &buf->buf.buf8[tmp_trail_mod];
18008358:	6963      	ldr	r3, [r4, #20]

	buf->misc.byte_mode.tmp_tail =
		buf->misc.byte_mode.tmp_tail + allocated;
1800835a:	4406      	add	r6, r0
	*data = &buf->buf.buf8[tmp_trail_mod];
1800835c:	442b      	add	r3, r5
1800835e:	600b      	str	r3, [r1, #0]
	buf->misc.byte_mode.tmp_tail =
18008360:	60a6      	str	r6, [r4, #8]

	return allocated;
}
18008362:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
18008364:	fbb6 f5f7 	udiv	r5, r6, r7
18008368:	fb07 6515 	mls	r5, r7, r5, r6
1800836c:	e7ea      	b.n	18008344 <ring_buf_put_claim+0xe>

1800836e <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
1800836e:	b570      	push	{r4, r5, r6, lr}
18008370:	4605      	mov	r5, r0
18008372:	460c      	mov	r4, r1
	uint32_t rew;
	uint32_t threshold = ring_buf_get_rewind_threshold();
18008374:	f7ff ffdc 	bl	18008330 <ring_buf_get_rewind_threshold>

	if ((buf->tail + size) > (buf->head + buf->size)) {
18008378:	686e      	ldr	r6, [r5, #4]
1800837a:	692a      	ldr	r2, [r5, #16]
1800837c:	682b      	ldr	r3, [r5, #0]
1800837e:	1931      	adds	r1, r6, r4
18008380:	4413      	add	r3, r2
18008382:	4299      	cmp	r1, r3
18008384:	d80c      	bhi.n	180083a0 <ring_buf_put_finish+0x32>
		return -EINVAL;
	}

	/* Check if indexes shall be rewind. */
	if (buf->tail > threshold) {
18008386:	4286      	cmp	r6, r0
	return buf_size * (threshold / buf_size);
18008388:	bf8c      	ite	hi
1800838a:	fbb0 f3f2 	udivhi	r3, r0, r2
		rew = get_rewind_value(buf->size, threshold);
	} else {
		rew = 0;
1800838e:	2300      	movls	r3, #0
	}

	buf->tail += (size - rew);
	buf->misc.byte_mode.tmp_tail = buf->tail;

	return 0;
18008390:	f04f 0000 	mov.w	r0, #0
	return buf_size * (threshold / buf_size);
18008394:	bf88      	it	hi
18008396:	4353      	mulhi	r3, r2
	buf->tail += (size - rew);
18008398:	1ac9      	subs	r1, r1, r3
	buf->misc.byte_mode.tmp_tail = buf->tail;
1800839a:	e9c5 1101 	strd	r1, r1, [r5, #4]
}
1800839e:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
180083a0:	f06f 0015 	mvn.w	r0, #21
180083a4:	e7fb      	b.n	1800839e <ring_buf_put_finish+0x30>

180083a6 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
180083a6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
180083aa:	4680      	mov	r8, r0
180083ac:	460e      	mov	r6, r1
180083ae:	4615      	mov	r5, r2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
180083b0:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
180083b2:	462a      	mov	r2, r5
180083b4:	a901      	add	r1, sp, #4
180083b6:	4640      	mov	r0, r8
180083b8:	f7ff ffbd 	bl	18008336 <ring_buf_put_claim>
180083bc:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
180083be:	4602      	mov	r2, r0
180083c0:	4631      	mov	r1, r6
180083c2:	9801      	ldr	r0, [sp, #4]
180083c4:	f001 fec5 	bl	1800a152 <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
180083c8:	1b2d      	subs	r5, r5, r4
		total_size += partial_size;
180083ca:	4427      	add	r7, r4
		data += partial_size;
180083cc:	4426      	add	r6, r4
	} while (size && partial_size);
180083ce:	d001      	beq.n	180083d4 <ring_buf_put+0x2e>
180083d0:	2c00      	cmp	r4, #0
180083d2:	d1ee      	bne.n	180083b2 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
180083d4:	4639      	mov	r1, r7
180083d6:	4640      	mov	r0, r8
180083d8:	f7ff ffc9 	bl	1800836e <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
180083dc:	4638      	mov	r0, r7
180083de:	b002      	add	sp, #8
180083e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

180083e4 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
180083e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t space, granted_size, trail_size, tmp_head_mod;
	uint32_t tail = buf->tail;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
180083e8:	68c3      	ldr	r3, [r0, #12]
	uint32_t tail = buf->tail;
180083ea:	6846      	ldr	r6, [r0, #4]
{
180083ec:	4604      	mov	r4, r0
	if (tail < buf->misc.byte_mode.tmp_head) {
180083ee:	42b3      	cmp	r3, r6
{
180083f0:	460f      	mov	r7, r1
180083f2:	4690      	mov	r8, r2
	if (tail < buf->misc.byte_mode.tmp_head) {
180083f4:	d906      	bls.n	18008404 <ring_buf_get_claim+0x20>
		/* Locally, increment it to pre-rewind value */
		tail += get_rewind_value(buf->size,
180083f6:	6905      	ldr	r5, [r0, #16]
180083f8:	f7ff ff9a 	bl	18008330 <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
180083fc:	fbb0 f0f5 	udiv	r0, r0, r5
		tail += get_rewind_value(buf->size,
18008400:	fb05 6600 	mla	r6, r5, r0, r6
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
18008404:	69a5      	ldr	r5, [r4, #24]
					 ring_buf_get_rewind_threshold());
	}

	tmp_head_mod = mod(buf, buf->misc.byte_mode.tmp_head);
18008406:	68e1      	ldr	r1, [r4, #12]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
18008408:	6923      	ldr	r3, [r4, #16]
1800840a:	b185      	cbz	r5, 1800842e <ring_buf_get_claim+0x4a>
1800840c:	400d      	ands	r5, r1
	space = tail - buf->misc.byte_mode.tmp_head;
1800840e:	1a70      	subs	r0, r6, r1
	trail_size = buf->size - tmp_head_mod;

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);
18008410:	4540      	cmp	r0, r8
18008412:	bf28      	it	cs
18008414:	4640      	movcs	r0, r8
18008416:	4606      	mov	r6, r0
	trail_size = buf->size - tmp_head_mod;
18008418:	1b58      	subs	r0, r3, r5

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);
1800841a:	42b0      	cmp	r0, r6
1800841c:	bf28      	it	cs
1800841e:	4630      	movcs	r0, r6

	*data = &buf->buf.buf8[tmp_head_mod];
18008420:	6963      	ldr	r3, [r4, #20]
	buf->misc.byte_mode.tmp_head += granted_size;
18008422:	4401      	add	r1, r0
	*data = &buf->buf.buf8[tmp_head_mod];
18008424:	442b      	add	r3, r5
18008426:	603b      	str	r3, [r7, #0]
	buf->misc.byte_mode.tmp_head += granted_size;
18008428:	60e1      	str	r1, [r4, #12]

	return granted_size;
}
1800842a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
1800842e:	fbb1 f5f3 	udiv	r5, r1, r3
18008432:	fb03 1515 	mls	r5, r3, r5, r1
18008436:	e7ea      	b.n	1800840e <ring_buf_get_claim+0x2a>

18008438 <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
18008438:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = buf->tail;
1800843a:	6846      	ldr	r6, [r0, #4]
	uint32_t rew;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
1800843c:	68c3      	ldr	r3, [r0, #12]
{
1800843e:	4605      	mov	r5, r0
	if (tail < buf->misc.byte_mode.tmp_head) {
18008440:	42b3      	cmp	r3, r6
{
18008442:	460c      	mov	r4, r1
	if (tail < buf->misc.byte_mode.tmp_head) {
18008444:	d912      	bls.n	1800846c <ring_buf_get_finish+0x34>
		/* tail was rewinded. Locally, increment it to pre-rewind value */
		rew = get_rewind_value(buf->size,
18008446:	6907      	ldr	r7, [r0, #16]
18008448:	f7ff ff72 	bl	18008330 <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
1800844c:	fbb0 f0f7 	udiv	r0, r0, r7
18008450:	4378      	muls	r0, r7
				       ring_buf_get_rewind_threshold());
		tail += rew;
18008452:	4406      	add	r6, r0
	} else {
		rew = 0;
	}

	if ((buf->head + size) > tail) {
18008454:	6829      	ldr	r1, [r5, #0]
18008456:	4421      	add	r1, r4
18008458:	42b1      	cmp	r1, r6
		return -EINVAL;
	}

	/* Include potential rewinding. */
	buf->head += (size - rew);
1800845a:	bf97      	itett	ls
1800845c:	1a09      	subls	r1, r1, r0
		return -EINVAL;
1800845e:	f06f 0015 	mvnhi.w	r0, #21
	buf->misc.byte_mode.tmp_head = buf->head;

	return 0;
18008462:	2000      	movls	r0, #0
	buf->head += (size - rew);
18008464:	6029      	strls	r1, [r5, #0]
	buf->misc.byte_mode.tmp_head = buf->head;
18008466:	bf98      	it	ls
18008468:	60e9      	strls	r1, [r5, #12]
}
1800846a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		rew = 0;
1800846c:	2000      	movs	r0, #0
1800846e:	e7f1      	b.n	18008454 <ring_buf_get_finish+0x1c>

18008470 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
18008470:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
18008474:	4680      	mov	r8, r0
18008476:	460d      	mov	r5, r1
18008478:	4616      	mov	r6, r2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
1800847a:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
1800847c:	4632      	mov	r2, r6
1800847e:	4640      	mov	r0, r8
18008480:	a901      	add	r1, sp, #4
18008482:	f7ff ffaf 	bl	180083e4 <ring_buf_get_claim>
18008486:	4604      	mov	r4, r0
		if (data) {
18008488:	b12d      	cbz	r5, 18008496 <ring_buf_get+0x26>
			memcpy(data, src, partial_size);
1800848a:	4602      	mov	r2, r0
1800848c:	9901      	ldr	r1, [sp, #4]
1800848e:	4628      	mov	r0, r5
18008490:	f001 fe5f 	bl	1800a152 <memcpy>
			data += partial_size;
18008494:	4425      	add	r5, r4
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
18008496:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
18008498:	4427      	add	r7, r4
	} while (size && partial_size);
1800849a:	d001      	beq.n	180084a0 <ring_buf_get+0x30>
1800849c:	2c00      	cmp	r4, #0
1800849e:	d1ed      	bne.n	1800847c <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
180084a0:	4639      	mov	r1, r7
180084a2:	4640      	mov	r0, r8
180084a4:	f7ff ffc8 	bl	18008438 <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
180084a8:	4638      	mov	r0, r7
180084aa:	b002      	add	sp, #8
180084ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

180084b0 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
180084b0:	070b      	lsls	r3, r1, #28
180084b2:	d504      	bpl.n	180084be <foldcase+0xe>
180084b4:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
180084b8:	2b19      	cmp	r3, #25
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
180084ba:	bf98      	it	ls
180084bc:	3020      	addls	r0, #32
        return tolower(ch);
    return ch;
}
180084be:	4770      	bx	lr

180084c0 <fnmatchx>:
    return ok == negate ? NULL : pattern;
}


static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
180084c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
180084c4:	b087      	sub	sp, #28
180084c6:	468a      	mov	sl, r1
180084c8:	4614      	mov	r4, r2
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
180084ca:	4605      	mov	r5, r0
{
180084cc:	9302      	str	r3, [sp, #8]
    if ((pattern == NULL) || (string == NULL))
180084ce:	b918      	cbnz	r0, 180084d8 <fnmatchx+0x18>
    {
        return FNM_NOMATCH;
180084d0:	2001      	movs	r0, #1
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
180084d2:	b007      	add	sp, #28
180084d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((pattern == NULL) || (string == NULL))
180084d8:	2900      	cmp	r1, #0
180084da:	d0f9      	beq.n	180084d0 <fnmatchx+0x10>
    if (recursion-- == 0)
180084dc:	9b02      	ldr	r3, [sp, #8]
180084de:	2b00      	cmp	r3, #0
180084e0:	f000 811a 	beq.w	18008718 <fnmatchx+0x258>
180084e4:	460a      	mov	r2, r1
            if (*string == '.' && (flags & FNM_PERIOD) &&
180084e6:	f004 0304 	and.w	r3, r4, #4
180084ea:	9304      	str	r3, [sp, #16]
        switch (c = FOLDCASE(*pattern++, flags)) {
180084ec:	46a8      	mov	r8, r5
180084ee:	4621      	mov	r1, r4
180084f0:	f818 0b01 	ldrb.w	r0, [r8], #1
180084f4:	f7ff ffdc 	bl	180084b0 <foldcase>
180084f8:	4603      	mov	r3, r0
180084fa:	b2c0      	uxtb	r0, r0
180084fc:	283f      	cmp	r0, #63	; 0x3f
180084fe:	4606      	mov	r6, r0
            if ((flags & FNM_LEADING_DIR) && *string == '/')
18008500:	7817      	ldrb	r7, [r2, #0]
        switch (c = FOLDCASE(*pattern++, flags)) {
18008502:	d025      	beq.n	18008550 <fnmatchx+0x90>
18008504:	f013 0fc0 	tst.w	r3, #192	; 0xc0
18008508:	d10b      	bne.n	18008522 <fnmatchx+0x62>
1800850a:	b1c8      	cbz	r0, 18008540 <fnmatchx+0x80>
1800850c:	282a      	cmp	r0, #42	; 0x2a
1800850e:	d036      	beq.n	1800857e <fnmatchx+0xbe>
            if (c != FOLDCASE(*string++, flags))
18008510:	4621      	mov	r1, r4
18008512:	4638      	mov	r0, r7
18008514:	f7ff ffcc 	bl	180084b0 <foldcase>
18008518:	4286      	cmp	r6, r0
1800851a:	f102 0201 	add.w	r2, r2, #1
1800851e:	d01e      	beq.n	1800855e <fnmatchx+0x9e>
18008520:	e7d6      	b.n	180084d0 <fnmatchx+0x10>
        switch (c = FOLDCASE(*pattern++, flags)) {
18008522:	285b      	cmp	r0, #91	; 0x5b
18008524:	d07b      	beq.n	1800861e <fnmatchx+0x15e>
18008526:	285c      	cmp	r0, #92	; 0x5c
18008528:	d1f2      	bne.n	18008510 <fnmatchx+0x50>
            if (!(flags & FNM_NOESCAPE)) {
1800852a:	07e3      	lsls	r3, r4, #31
1800852c:	d4f0      	bmi.n	18008510 <fnmatchx+0x50>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
1800852e:	7868      	ldrb	r0, [r5, #1]
18008530:	f7ff ffbe 	bl	180084b0 <foldcase>
18008534:	f010 06ff 	ands.w	r6, r0, #255	; 0xff
18008538:	bf18      	it	ne
1800853a:	f105 0802 	addne.w	r8, r5, #2
1800853e:	e7e7      	b.n	18008510 <fnmatchx+0x50>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
18008540:	06e4      	lsls	r4, r4, #27
18008542:	d501      	bpl.n	18008548 <fnmatchx+0x88>
18008544:	2f2f      	cmp	r7, #47	; 0x2f
18008546:	d0c4      	beq.n	180084d2 <fnmatchx+0x12>
            return *string == EOS ? 0 : FNM_NOMATCH;
18008548:	1e38      	subs	r0, r7, #0
                        0 : FNM_NOMATCH;
1800854a:	bf18      	it	ne
1800854c:	2001      	movne	r0, #1
1800854e:	e7c0      	b.n	180084d2 <fnmatchx+0x12>
            if (*string == EOS)
18008550:	2f00      	cmp	r7, #0
18008552:	d0bd      	beq.n	180084d0 <fnmatchx+0x10>
            if (*string == '/' && (flags & FNM_PATHNAME))
18008554:	2f2f      	cmp	r7, #47	; 0x2f
18008556:	d104      	bne.n	18008562 <fnmatchx+0xa2>
18008558:	07a1      	lsls	r1, r4, #30
1800855a:	d4b9      	bmi.n	180084d0 <fnmatchx+0x10>
            ++string;
1800855c:	3201      	adds	r2, #1
            break;
1800855e:	4645      	mov	r5, r8
18008560:	e7c4      	b.n	180084ec <fnmatchx+0x2c>
            if (*string == '.' && (flags & FNM_PERIOD) &&
18008562:	2f2e      	cmp	r7, #46	; 0x2e
18008564:	d1fa      	bne.n	1800855c <fnmatchx+0x9c>
18008566:	9b04      	ldr	r3, [sp, #16]
18008568:	2b00      	cmp	r3, #0
1800856a:	d0f7      	beq.n	1800855c <fnmatchx+0x9c>
1800856c:	4552      	cmp	r2, sl
1800856e:	d0af      	beq.n	180084d0 <fnmatchx+0x10>
                (string == stringstart ||
18008570:	07a3      	lsls	r3, r4, #30
18008572:	d5f3      	bpl.n	1800855c <fnmatchx+0x9c>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
18008574:	f812 3c01 	ldrb.w	r3, [r2, #-1]
18008578:	2b2f      	cmp	r3, #47	; 0x2f
1800857a:	d1ef      	bne.n	1800855c <fnmatchx+0x9c>
1800857c:	e7a8      	b.n	180084d0 <fnmatchx+0x10>
            c = FOLDCASE(*pattern, flags);
1800857e:	7868      	ldrb	r0, [r5, #1]
                c = FOLDCASE(*++pattern, flags);
18008580:	f7ff ff96 	bl	180084b0 <foldcase>
18008584:	b2c1      	uxtb	r1, r0
            while (c == '*')
18008586:	292a      	cmp	r1, #42	; 0x2a
18008588:	d018      	beq.n	180085bc <fnmatchx+0xfc>
            if (*string == '.' && (flags & FNM_PERIOD) &&
1800858a:	2f2e      	cmp	r7, #46	; 0x2e
1800858c:	d109      	bne.n	180085a2 <fnmatchx+0xe2>
1800858e:	9b04      	ldr	r3, [sp, #16]
18008590:	b13b      	cbz	r3, 180085a2 <fnmatchx+0xe2>
18008592:	4552      	cmp	r2, sl
18008594:	d09c      	beq.n	180084d0 <fnmatchx+0x10>
                (string == stringstart ||
18008596:	07a7      	lsls	r7, r4, #30
18008598:	d503      	bpl.n	180085a2 <fnmatchx+0xe2>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
1800859a:	f812 3c01 	ldrb.w	r3, [r2, #-1]
1800859e:	2b2f      	cmp	r3, #47	; 0x2f
180085a0:	d096      	beq.n	180084d0 <fnmatchx+0x10>
            if (c == EOS) {
180085a2:	b979      	cbnz	r1, 180085c4 <fnmatchx+0x104>
                if (flags & FNM_PATHNAME)
180085a4:	f014 0002 	ands.w	r0, r4, #2
180085a8:	d093      	beq.n	180084d2 <fnmatchx+0x12>
                        0 : FNM_NOMATCH;
180085aa:	06e6      	lsls	r6, r4, #27
180085ac:	f100 80b6 	bmi.w	1800871c <fnmatchx+0x25c>
                        strchr(string, '/') == NULL ?
180085b0:	212f      	movs	r1, #47	; 0x2f
180085b2:	4610      	mov	r0, r2
180085b4:	f001 fd69 	bl	1800a08a <strchr>
                        0 : FNM_NOMATCH;
180085b8:	3800      	subs	r0, #0
180085ba:	e7c6      	b.n	1800854a <fnmatchx+0x8a>
                c = FOLDCASE(*++pattern, flags);
180085bc:	4621      	mov	r1, r4
180085be:	f818 0f01 	ldrb.w	r0, [r8, #1]!
180085c2:	e7dd      	b.n	18008580 <fnmatchx+0xc0>
            } else if (c == '/' && flags & FNM_PATHNAME) {
180085c4:	292f      	cmp	r1, #47	; 0x2f
180085c6:	d021      	beq.n	1800860c <fnmatchx+0x14c>
180085c8:	4616      	mov	r6, r2
    if (recursion-- == 0)
180085ca:	9b02      	ldr	r3, [sp, #8]
                switch ((e = fnmatchx(pattern, string,
180085cc:	f024 0904 	bic.w	r9, r4, #4
    if (recursion-- == 0)
180085d0:	1e5f      	subs	r7, r3, #1
                if (test == '/' && flags & FNM_PATHNAME)
180085d2:	f004 0a02 	and.w	sl, r4, #2
180085d6:	46b3      	mov	fp, r6
            while ((test = FOLDCASE(*string, flags)) != EOS) {
180085d8:	4621      	mov	r1, r4
180085da:	f89b 0000 	ldrb.w	r0, [fp]
180085de:	f7ff ff67 	bl	180084b0 <foldcase>
180085e2:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
180085e6:	f106 0601 	add.w	r6, r6, #1
180085ea:	f43f af71 	beq.w	180084d0 <fnmatchx+0x10>
                switch ((e = fnmatchx(pattern, string,
180085ee:	463b      	mov	r3, r7
180085f0:	464a      	mov	r2, r9
180085f2:	4659      	mov	r1, fp
180085f4:	4640      	mov	r0, r8
180085f6:	f7ff ff63 	bl	180084c0 <fnmatchx>
180085fa:	2801      	cmp	r0, #1
180085fc:	f47f af69 	bne.w	180084d2 <fnmatchx+0x12>
                if (test == '/' && flags & FNM_PATHNAME)
18008600:	2d2f      	cmp	r5, #47	; 0x2f
18008602:	d1e8      	bne.n	180085d6 <fnmatchx+0x116>
18008604:	f1ba 0f00 	cmp.w	sl, #0
18008608:	d0e5      	beq.n	180085d6 <fnmatchx+0x116>
1800860a:	e761      	b.n	180084d0 <fnmatchx+0x10>
            } else if (c == '/' && flags & FNM_PATHNAME) {
1800860c:	07a5      	lsls	r5, r4, #30
1800860e:	d5db      	bpl.n	180085c8 <fnmatchx+0x108>
                if ((string = strchr(string, '/')) == NULL)
18008610:	4610      	mov	r0, r2
18008612:	f001 fd3a 	bl	1800a08a <strchr>
18008616:	4602      	mov	r2, r0
18008618:	2800      	cmp	r0, #0
1800861a:	d1a0      	bne.n	1800855e <fnmatchx+0x9e>
1800861c:	e758      	b.n	180084d0 <fnmatchx+0x10>
            if (*string == EOS)
1800861e:	2f00      	cmp	r7, #0
18008620:	f43f af56 	beq.w	180084d0 <fnmatchx+0x10>
            if (*string == '/' && flags & FNM_PATHNAME)
18008624:	2f2f      	cmp	r7, #47	; 0x2f
18008626:	d102      	bne.n	1800862e <fnmatchx+0x16e>
18008628:	07a0      	lsls	r0, r4, #30
1800862a:	f53f af51 	bmi.w	180084d0 <fnmatchx+0x10>
            if ((r = rangematch(pattern,
1800862e:	4621      	mov	r1, r4
18008630:	4638      	mov	r0, r7
18008632:	f7ff ff3d 	bl	180084b0 <foldcase>
18008636:	9000      	str	r0, [sp, #0]
    if (pattern == NULL)
18008638:	f1b8 0f00 	cmp.w	r8, #0
1800863c:	f43f af48 	beq.w	180084d0 <fnmatchx+0x10>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
18008640:	786b      	ldrb	r3, [r5, #1]
18008642:	2b21      	cmp	r3, #33	; 0x21
18008644:	d001      	beq.n	1800864a <fnmatchx+0x18a>
18008646:	2b5e      	cmp	r3, #94	; 0x5e
18008648:	d126      	bne.n	18008698 <fnmatchx+0x1d8>
        ++pattern;
1800864a:	2301      	movs	r3, #1
1800864c:	3502      	adds	r5, #2
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
1800864e:	9301      	str	r3, [sp, #4]
    need = 1;
18008650:	2301      	movs	r3, #1
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
18008652:	f04f 0b00 	mov.w	fp, #0
        if (c == '\\' && !(flags & FNM_NOESCAPE))
18008656:	ea04 0103 	and.w	r1, r4, r3
1800865a:	9103      	str	r1, [sp, #12]
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
1800865c:	462e      	mov	r6, r5
1800865e:	4621      	mov	r1, r4
18008660:	f816 0b01 	ldrb.w	r0, [r6], #1
18008664:	9305      	str	r3, [sp, #20]
18008666:	f7ff ff23 	bl	180084b0 <foldcase>
1800866a:	fa5f f980 	uxtb.w	r9, r0
1800866e:	f1b9 0f5d 	cmp.w	r9, #93	; 0x5d
18008672:	9b05      	ldr	r3, [sp, #20]
18008674:	d113      	bne.n	1800869e <fnmatchx+0x1de>
18008676:	bb23      	cbnz	r3, 180086c2 <fnmatchx+0x202>
    return ok == negate ? NULL : pattern;
18008678:	9b01      	ldr	r3, [sp, #4]
1800867a:	455b      	cmp	r3, fp
1800867c:	f43f af28 	beq.w	180084d0 <fnmatchx+0x10>
            if ((r = rangematch(pattern,
18008680:	2e00      	cmp	r6, #0
18008682:	f43f af25 	beq.w	180084d0 <fnmatchx+0x10>
            if (r == (void *)-1) {
18008686:	1c71      	adds	r1, r6, #1
18008688:	d103      	bne.n	18008692 <fnmatchx+0x1d2>
                if (*string != '[')
1800868a:	2f5b      	cmp	r7, #91	; 0x5b
1800868c:	f47f af20 	bne.w	180084d0 <fnmatchx+0x10>
18008690:	4646      	mov	r6, r8
            break;
18008692:	46b0      	mov	r8, r6
            ++string;
18008694:	3201      	adds	r2, #1
            break;
18008696:	e762      	b.n	1800855e <fnmatchx+0x9e>
18008698:	4645      	mov	r5, r8
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
1800869a:	2300      	movs	r3, #0
1800869c:	e7d7      	b.n	1800864e <fnmatchx+0x18e>
        if (c == '/')
1800869e:	f1b9 0f2f 	cmp.w	r9, #47	; 0x2f
180086a2:	d0f2      	beq.n	1800868a <fnmatchx+0x1ca>
        if (c == '\\' && !(flags & FNM_NOESCAPE))
180086a4:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
180086a8:	d107      	bne.n	180086ba <fnmatchx+0x1fa>
180086aa:	9b03      	ldr	r3, [sp, #12]
180086ac:	b94b      	cbnz	r3, 180086c2 <fnmatchx+0x202>
            c = FOLDCASE(*pattern++, flags);
180086ae:	7868      	ldrb	r0, [r5, #1]
180086b0:	f7ff fefe 	bl	180084b0 <foldcase>
180086b4:	1cae      	adds	r6, r5, #2
180086b6:	fa5f f980 	uxtb.w	r9, r0
        if (c == EOS)
180086ba:	f1b9 0f00 	cmp.w	r9, #0
180086be:	f43f af07 	beq.w	180084d0 <fnmatchx+0x10>
        if (*pattern == '-' 
180086c2:	7833      	ldrb	r3, [r6, #0]
180086c4:	2b2d      	cmp	r3, #45	; 0x2d
180086c6:	d120      	bne.n	1800870a <fnmatchx+0x24a>
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
180086c8:	4621      	mov	r1, r4
180086ca:	7870      	ldrb	r0, [r6, #1]
180086cc:	f7ff fef0 	bl	180084b0 <foldcase>
180086d0:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
180086d4:	d019      	beq.n	1800870a <fnmatchx+0x24a>
180086d6:	285d      	cmp	r0, #93	; 0x5d
180086d8:	d017      	beq.n	1800870a <fnmatchx+0x24a>
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
180086da:	285c      	cmp	r0, #92	; 0x5c
            pattern += 2;
180086dc:	f106 0502 	add.w	r5, r6, #2
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
180086e0:	d10a      	bne.n	180086f8 <fnmatchx+0x238>
180086e2:	9b03      	ldr	r3, [sp, #12]
180086e4:	b943      	cbnz	r3, 180086f8 <fnmatchx+0x238>
                c2 = FOLDCASE(*pattern++, flags);
180086e6:	78b0      	ldrb	r0, [r6, #2]
180086e8:	f7ff fee2 	bl	180084b0 <foldcase>
            if (c2 == EOS)
180086ec:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
                c2 = FOLDCASE(*pattern++, flags);
180086f0:	f106 0503 	add.w	r5, r6, #3
            if (c2 == EOS)
180086f4:	f43f aeec 	beq.w	180084d0 <fnmatchx+0x10>
            if (c <= test && test <= c2)
180086f8:	9b00      	ldr	r3, [sp, #0]
180086fa:	454b      	cmp	r3, r9
180086fc:	db03      	blt.n	18008706 <fnmatchx+0x246>
                ok = 1;
180086fe:	4283      	cmp	r3, r0
18008700:	bfd8      	it	le
18008702:	f04f 0b01 	movle.w	fp, #1
            ok = 1;
18008706:	2300      	movs	r3, #0
18008708:	e7a8      	b.n	1800865c <fnmatchx+0x19c>
        } else if (c == test)
1800870a:	9b00      	ldr	r3, [sp, #0]
1800870c:	4635      	mov	r5, r6
1800870e:	454b      	cmp	r3, r9
18008710:	bf08      	it	eq
18008712:	f04f 0b01 	moveq.w	fp, #1
18008716:	e7f6      	b.n	18008706 <fnmatchx+0x246>
        return FNM_NORES;
18008718:	2003      	movs	r0, #3
1800871a:	e6da      	b.n	180084d2 <fnmatchx+0x12>
                return 0;
1800871c:	4608      	mov	r0, r1
1800871e:	e6d8      	b.n	180084d2 <fnmatchx+0x12>

18008720 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    return fnmatchx(pattern, string, flags, 64);
18008720:	2340      	movs	r3, #64	; 0x40
18008722:	f7ff becd 	b.w	180084c0 <fnmatchx>

18008726 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
18008726:	4770      	bx	lr

18008728 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
18008728:	2300      	movs	r3, #0
	list->head = NULL;
1800872a:	e9c0 3300 	strd	r3, r3, [r0]
}
1800872e:	4770      	bx	lr

18008730 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
18008730:	6803      	ldr	r3, [r0, #0]
18008732:	b923      	cbnz	r3, 1800873e <log_list_add_tail+0xe>
		list->head = msg;
18008734:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
18008736:	2300      	movs	r3, #0
	list->tail = msg;
18008738:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
1800873a:	600b      	str	r3, [r1, #0]
}
1800873c:	4770      	bx	lr
		list->tail->next = msg;
1800873e:	6843      	ldr	r3, [r0, #4]
18008740:	6019      	str	r1, [r3, #0]
18008742:	e7f8      	b.n	18008736 <log_list_add_tail+0x6>

18008744 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
18008744:	6800      	ldr	r0, [r0, #0]
18008746:	4770      	bx	lr

18008748 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
18008748:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
1800874a:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
1800874c:	b108      	cbz	r0, 18008752 <log_list_head_get+0xa>
		list->head = list->head->next;
1800874e:	6802      	ldr	r2, [r0, #0]
18008750:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
18008752:	4770      	bx	lr

18008754 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
18008754:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
18008756:	f7fa f877 	bl	18002848 <log_msg_chunk_alloc>

	if (msg != NULL) {
1800875a:	b118      	cbz	r0, 18008764 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
1800875c:	2301      	movs	r3, #1
1800875e:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
18008760:	2300      	movs	r3, #0
18008762:	8103      	strh	r3, [r0, #8]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
18008764:	bd08      	pop	{r3, pc}

18008766 <default_get_timestamp>:
18008766:	f7fd bab5 	b.w	18005cd4 <sys_clock_cycle_get_32>

1800876a <dummy_timestamp>:
1800876a:	2000      	movs	r0, #0
1800876c:	4770      	bx	lr

1800876e <z_log_get_s_mask>:
{
1800876e:	b5f0      	push	{r4, r5, r6, r7, lr}
18008770:	4605      	mov	r5, r0
	uint32_t mask = 0U;
18008772:	2000      	movs	r0, #0
				mask |= BIT(arg);
18008774:	2701      	movs	r7, #1
	uint32_t arg = 0U;
18008776:	4603      	mov	r3, r0
	bool arm = false;
18008778:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
1800877a:	f815 4b01 	ldrb.w	r4, [r5], #1
1800877e:	b10c      	cbz	r4, 18008784 <z_log_get_s_mask+0x16>
18008780:	428b      	cmp	r3, r1
18008782:	d300      	bcc.n	18008786 <z_log_get_s_mask+0x18>
}
18008784:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
18008786:	2c25      	cmp	r4, #37	; 0x25
18008788:	d102      	bne.n	18008790 <z_log_get_s_mask+0x22>
			arm = !arm;
1800878a:	f082 0201 	eor.w	r2, r2, #1
1800878e:	e7f4      	b.n	1800877a <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
18008790:	2a00      	cmp	r2, #0
18008792:	d0f2      	beq.n	1800877a <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
18008794:	f044 0620 	orr.w	r6, r4, #32
18008798:	3e61      	subs	r6, #97	; 0x61
1800879a:	2e19      	cmp	r6, #25
1800879c:	d8ed      	bhi.n	1800877a <z_log_get_s_mask+0xc>
			if (curr == 's') {
1800879e:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
180087a0:	bf04      	itt	eq
180087a2:	fa07 f203 	lsleq.w	r2, r7, r3
180087a6:	4310      	orreq	r0, r2
			arg++;
180087a8:	3301      	adds	r3, #1
			arm = false;
180087aa:	2200      	movs	r2, #0
180087ac:	e7e5      	b.n	1800877a <z_log_get_s_mask+0xc>

180087ae <log_0>:
{
180087ae:	b538      	push	{r3, r4, r5, lr}
180087b0:	4605      	mov	r5, r0
180087b2:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
180087b4:	f7ff ffce 	bl	18008754 <z_log_msg_std_alloc>

	if (msg != NULL) {
180087b8:	b128      	cbz	r0, 180087c6 <log_0+0x18>
		msg_finalize(msg, src_level);
180087ba:	4621      	mov	r1, r4
		msg->str = str;
180087bc:	6105      	str	r5, [r0, #16]
}
180087be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
180087c2:	f7f9 bebf 	b.w	18002544 <msg_finalize>
}
180087c6:	bd38      	pop	{r3, r4, r5, pc}

180087c8 <log_1>:
{
180087c8:	b570      	push	{r4, r5, r6, lr}
180087ca:	4606      	mov	r6, r0
180087cc:	460d      	mov	r5, r1
180087ce:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
180087d0:	f7ff ffc0 	bl	18008754 <z_log_msg_std_alloc>

	if (msg != NULL) {
180087d4:	b158      	cbz	r0, 180087ee <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
180087d6:	2101      	movs	r1, #1
180087d8:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
180087da:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
180087dc:	f361 1207 	bfi	r2, r1, #4, #4
180087e0:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
180087e2:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
180087e4:	6145      	str	r5, [r0, #20]
}
180087e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
180087ea:	f7f9 beab 	b.w	18002544 <msg_finalize>
}
180087ee:	bd70      	pop	{r4, r5, r6, pc}

180087f0 <log_2>:
{
180087f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
180087f4:	4680      	mov	r8, r0
180087f6:	460f      	mov	r7, r1
180087f8:	4616      	mov	r6, r2
180087fa:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
180087fc:	f7ff ffaa 	bl	18008754 <z_log_msg_std_alloc>

	if (msg != NULL) {
18008800:	b168      	cbz	r0, 1800881e <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
18008802:	2202      	movs	r2, #2
18008804:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
18008806:	4629      	mov	r1, r5
18008808:	f362 1307 	bfi	r3, r2, #4, #4
1800880c:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
1800880e:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
18008812:	f8c0 8010 	str.w	r8, [r0, #16]
}
18008816:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
1800881a:	f7f9 be93 	b.w	18002544 <msg_finalize>
}
1800881e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

18008822 <log_3>:
{
18008822:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
18008826:	4680      	mov	r8, r0
18008828:	460f      	mov	r7, r1
1800882a:	4616      	mov	r6, r2
1800882c:	461d      	mov	r5, r3
1800882e:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
18008832:	f7ff ff8f 	bl	18008754 <z_log_msg_std_alloc>

	if (msg != NULL) {
18008836:	b170      	cbz	r0, 18008856 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
18008838:	2203      	movs	r2, #3
1800883a:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
1800883c:	4649      	mov	r1, r9
1800883e:	f362 1307 	bfi	r3, r2, #4, #4
18008842:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
18008844:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
18008848:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
1800884c:	61c5      	str	r5, [r0, #28]
}
1800884e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
18008852:	f7f9 be77 	b.w	18002544 <msg_finalize>
}
18008856:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

1800885a <log_backend_disable>:
	backend->cb->active = false;
1800885a:	2100      	movs	r1, #0
1800885c:	6843      	ldr	r3, [r0, #4]
1800885e:	7159      	strb	r1, [r3, #5]
	backend_filter_set(backend, LOG_LEVEL_NONE);
18008860:	f7f9 bf88 	b.w	18002774 <backend_filter_set>

18008864 <log_msg_hexdump_data_op>:
{
18008864:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
18008868:	461c      	mov	r4, r3
	uint32_t available_len = msg->hdr.params.hexdump.length;
1800886a:	8903      	ldrh	r3, [r0, #8]
{
1800886c:	460e      	mov	r6, r1
1800886e:	4611      	mov	r1, r2
	uint32_t available_len = msg->hdr.params.hexdump.length;
18008870:	f3c3 028d 	ubfx	r2, r3, #2, #14
	if (offset >= available_len) {
18008874:	42a2      	cmp	r2, r4
{
18008876:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
1800887a:	d803      	bhi.n	18008884 <log_msg_hexdump_data_op+0x20>
		*length = 0;
1800887c:	2300      	movs	r3, #0
1800887e:	600b      	str	r3, [r1, #0]
}
18008880:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
18008884:	680b      	ldr	r3, [r1, #0]
18008886:	4423      	add	r3, r4
18008888:	4293      	cmp	r3, r2
		*length = available_len - offset;
1800888a:	bf84      	itt	hi
1800888c:	1b13      	subhi	r3, r2, r4
1800888e:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
18008890:	2a0c      	cmp	r2, #12
	req_len = *length;
18008892:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
18008896:	d92a      	bls.n	180088ee <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
18008898:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
1800889a:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
1800889e:	d82d      	bhi.n	180088fc <log_msg_hexdump_data_op+0x98>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
180088a0:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
180088a2:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
180088a4:	454a      	cmp	r2, r9
180088a6:	bf28      	it	cs
180088a8:	464a      	movcs	r2, r9
			(void)memcpy(&head_data[offset], data, cpy_len);
180088aa:	4420      	add	r0, r4
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
180088ac:	4615      	mov	r5, r2
		if (put_op) {
180088ae:	b317      	cbz	r7, 180088f6 <log_msg_hexdump_data_op+0x92>
			(void)memcpy(&head_data[offset], data, cpy_len);
180088b0:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
180088b2:	f001 fc4e 	bl	1800a152 <memcpy>
		req_len -= cpy_len;
180088b6:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
180088ba:	442e      	add	r6, r5
	while ((req_len > 0) && (cont != NULL)) {
180088bc:	f1b9 0f00 	cmp.w	r9, #0
180088c0:	d0de      	beq.n	18008880 <log_msg_hexdump_data_op+0x1c>
180088c2:	f1b8 0f00 	cmp.w	r8, #0
180088c6:	d0db      	beq.n	18008880 <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
180088c8:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
180088cc:	454d      	cmp	r5, r9
180088ce:	bf28      	it	cs
180088d0:	464d      	movcs	r5, r9
			(void)memcpy(&cont->payload.bytes[offset],
180088d2:	1d20      	adds	r0, r4, #4
180088d4:	462a      	mov	r2, r5
180088d6:	4440      	add	r0, r8
		if (put_op) {
180088d8:	b1bf      	cbz	r7, 1800890a <log_msg_hexdump_data_op+0xa6>
			(void)memcpy(&cont->payload.bytes[offset],
180088da:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
180088dc:	f001 fc39 	bl	1800a152 <memcpy>
		offset = 0;
180088e0:	2400      	movs	r4, #0
		cont = cont->next;
180088e2:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
180088e6:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
180088ea:	442e      	add	r6, r5
180088ec:	e7e6      	b.n	180088bc <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
180088ee:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
180088f2:	3014      	adds	r0, #20
	if (offset < chunk_len) {
180088f4:	e7d6      	b.n	180088a4 <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
180088f6:	4601      	mov	r1, r0
180088f8:	4630      	mov	r0, r6
180088fa:	e7da      	b.n	180088b2 <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
180088fc:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
180088fe:	2c1b      	cmp	r4, #27
18008900:	d9dc      	bls.n	180088bc <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
18008902:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
18008906:	3c1c      	subs	r4, #28
18008908:	e7f9      	b.n	180088fe <log_msg_hexdump_data_op+0x9a>
			(void)memcpy(data, &cont->payload.bytes[offset],
1800890a:	4601      	mov	r1, r0
1800890c:	4630      	mov	r0, r6
1800890e:	e7e5      	b.n	180088dc <log_msg_hexdump_data_op+0x78>

18008910 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
18008910:	3004      	adds	r0, #4
18008912:	e8d0 3fef 	ldaex	r3, [r0]
18008916:	3301      	adds	r3, #1
18008918:	e8c0 3fe2 	stlex	r2, r3, [r0]
1800891c:	2a00      	cmp	r2, #0
1800891e:	d1f8      	bne.n	18008912 <log_msg_get+0x2>
}
18008920:	4770      	bx	lr

18008922 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
18008922:	7a40      	ldrb	r0, [r0, #9]
}
18008924:	0900      	lsrs	r0, r0, #4
18008926:	4770      	bx	lr

18008928 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
18008928:	7a43      	ldrb	r3, [r0, #9]
1800892a:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
1800892e:	ea4f 1213 	mov.w	r2, r3, lsr #4
18008932:	d216      	bcs.n	18008962 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
18008934:	2a03      	cmp	r2, #3
18008936:	d803      	bhi.n	18008940 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
18008938:	eb00 0081 	add.w	r0, r0, r1, lsl #2
1800893c:	6940      	ldr	r0, [r0, #20]
1800893e:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
18008940:	2901      	cmp	r1, #1
18008942:	d803      	bhi.n	1800894c <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
18008944:	eb00 0081 	add.w	r0, r0, r1, lsl #2
18008948:	6980      	ldr	r0, [r0, #24]
1800894a:	4770      	bx	lr
	cont = msg->payload.ext.next;
1800894c:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
1800894e:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
18008950:	2906      	cmp	r1, #6
18008952:	d803      	bhi.n	1800895c <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
18008954:	eb03 0181 	add.w	r1, r3, r1, lsl #2
18008958:	6848      	ldr	r0, [r1, #4]
1800895a:	4770      	bx	lr
		cont = cont->next;
1800895c:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
1800895e:	3907      	subs	r1, #7
		cont = cont->next;
18008960:	e7f6      	b.n	18008950 <log_msg_arg_get+0x28>
		return 0;
18008962:	2000      	movs	r0, #0
}
18008964:	4770      	bx	lr

18008966 <log_msg_put>:
{
18008966:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
18008968:	1d02      	adds	r2, r0, #4
1800896a:	e8d2 1fef 	ldaex	r1, [r2]
1800896e:	3901      	subs	r1, #1
18008970:	e8c2 1fec 	stlex	ip, r1, [r2]
18008974:	f1bc 0f00 	cmp.w	ip, #0
18008978:	d1f7      	bne.n	1800896a <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
1800897a:	685b      	ldr	r3, [r3, #4]
1800897c:	b90b      	cbnz	r3, 18008982 <log_msg_put+0x1c>
		msg_free(msg);
1800897e:	f7f9 bf77 	b.w	18002870 <msg_free>
}
18008982:	4770      	bx	lr

18008984 <log_msg_str_get>:
}
18008984:	6900      	ldr	r0, [r0, #16]
18008986:	4770      	bx	lr

18008988 <log_msg_hexdump_data_get>:
{
18008988:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
1800898a:	2400      	movs	r4, #0
1800898c:	9400      	str	r4, [sp, #0]
1800898e:	f7ff ff69 	bl	18008864 <log_msg_hexdump_data_op>
}
18008992:	b002      	add	sp, #8
18008994:	bd10      	pop	{r4, pc}

18008996 <buffer_write>:
{
18008996:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18008998:	4606      	mov	r6, r0
1800899a:	460d      	mov	r5, r1
1800899c:	4614      	mov	r4, r2
1800899e:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
180089a0:	4621      	mov	r1, r4
180089a2:	4628      	mov	r0, r5
180089a4:	463a      	mov	r2, r7
180089a6:	47b0      	blx	r6
	} while (len != 0);
180089a8:	1a24      	subs	r4, r4, r0
		buf += processed;
180089aa:	4405      	add	r5, r0
	} while (len != 0);
180089ac:	d1f8      	bne.n	180089a0 <buffer_write+0xa>
}
180089ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

180089b0 <std_print>:
{
180089b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
180089b4:	b08e      	sub	sp, #56	; 0x38
180089b6:	af0e      	add	r7, sp, #56	; 0x38
180089b8:	4680      	mov	r8, r0
180089ba:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
180089bc:	f7ff ffe2 	bl	18008984 <log_msg_str_get>
180089c0:	4606      	mov	r6, r0
	uint32_t nargs = log_msg_nargs_get(msg);
180089c2:	4640      	mov	r0, r8
180089c4:	f7ff ffad 	bl	18008922 <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
180089c8:	f04f 0900 	mov.w	r9, #0
	uint32_t nargs = log_msg_nargs_get(msg);
180089cc:	4682      	mov	sl, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
180089ce:	0083      	lsls	r3, r0, #2
180089d0:	3307      	adds	r3, #7
180089d2:	f023 0307 	bic.w	r3, r3, #7
180089d6:	ebad 0d03 	sub.w	sp, sp, r3
180089da:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
180089dc:	45d1      	cmp	r9, sl
180089de:	d116      	bne.n	18008a0e <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
180089e0:	4640      	mov	r0, r8
180089e2:	f7ff ff9e 	bl	18008922 <log_msg_nargs_get>
180089e6:	280f      	cmp	r0, #15
180089e8:	d81e      	bhi.n	18008a28 <std_print+0x78>
180089ea:	e8df f010 	tbh	[pc, r0, lsl #1]
180089ee:	0019      	.short	0x0019
180089f0:	00260020 	.word	0x00260020
180089f4:	0036002d 	.word	0x0036002d
180089f8:	004e0041 	.word	0x004e0041
180089fc:	006e005d 	.word	0x006e005d
18008a00:	00960081 	.word	0x00960081
18008a04:	00c600ad 	.word	0x00c600ad
18008a08:	00fe00e1 	.word	0x00fe00e1
18008a0c:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
18008a0e:	4649      	mov	r1, r9
18008a10:	4640      	mov	r0, r8
18008a12:	f7ff ff89 	bl	18008928 <log_msg_arg_get>
18008a16:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
18008a1a:	f109 0901 	add.w	r9, r9, #1
18008a1e:	e7dd      	b.n	180089dc <std_print+0x2c>
		print_formatted(output, str);
18008a20:	4631      	mov	r1, r6
18008a22:	4628      	mov	r0, r5
18008a24:	f7f9 ff70 	bl	18002908 <print_formatted>
}
18008a28:	46bd      	mov	sp, r7
18008a2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
18008a2e:	4631      	mov	r1, r6
18008a30:	4628      	mov	r0, r5
18008a32:	6822      	ldr	r2, [r4, #0]
18008a34:	f7f9 ff68 	bl	18002908 <print_formatted>
		break;
18008a38:	e7f6      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1]);
18008a3a:	4631      	mov	r1, r6
18008a3c:	e9d4 2300 	ldrd	r2, r3, [r4]
18008a40:	4628      	mov	r0, r5
18008a42:	f7f9 ff61 	bl	18002908 <print_formatted>
		break;
18008a46:	e7ef      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2]);
18008a48:	68a3      	ldr	r3, [r4, #8]
18008a4a:	4631      	mov	r1, r6
18008a4c:	9300      	str	r3, [sp, #0]
18008a4e:	4628      	mov	r0, r5
18008a50:	e9d4 2300 	ldrd	r2, r3, [r4]
18008a54:	f7f9 ff58 	bl	18002908 <print_formatted>
		break;
18008a58:	e7e6      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008a5a:	68e3      	ldr	r3, [r4, #12]
18008a5c:	4631      	mov	r1, r6
18008a5e:	9301      	str	r3, [sp, #4]
18008a60:	68a3      	ldr	r3, [r4, #8]
18008a62:	4628      	mov	r0, r5
18008a64:	9300      	str	r3, [sp, #0]
18008a66:	e9d4 2300 	ldrd	r2, r3, [r4]
18008a6a:	f7f9 ff4d 	bl	18002908 <print_formatted>
		break;
18008a6e:	e7db      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008a70:	6923      	ldr	r3, [r4, #16]
18008a72:	4631      	mov	r1, r6
18008a74:	9302      	str	r3, [sp, #8]
18008a76:	68e3      	ldr	r3, [r4, #12]
18008a78:	4628      	mov	r0, r5
18008a7a:	9301      	str	r3, [sp, #4]
18008a7c:	68a3      	ldr	r3, [r4, #8]
18008a7e:	9300      	str	r3, [sp, #0]
18008a80:	e9d4 2300 	ldrd	r2, r3, [r4]
18008a84:	f7f9 ff40 	bl	18002908 <print_formatted>
		break;
18008a88:	e7ce      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008a8a:	6963      	ldr	r3, [r4, #20]
18008a8c:	4631      	mov	r1, r6
18008a8e:	9303      	str	r3, [sp, #12]
18008a90:	6923      	ldr	r3, [r4, #16]
18008a92:	4628      	mov	r0, r5
18008a94:	9302      	str	r3, [sp, #8]
18008a96:	68e3      	ldr	r3, [r4, #12]
18008a98:	9301      	str	r3, [sp, #4]
18008a9a:	68a3      	ldr	r3, [r4, #8]
18008a9c:	9300      	str	r3, [sp, #0]
18008a9e:	e9d4 2300 	ldrd	r2, r3, [r4]
18008aa2:	f7f9 ff31 	bl	18002908 <print_formatted>
		break;
18008aa6:	e7bf      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008aa8:	69a3      	ldr	r3, [r4, #24]
18008aaa:	4631      	mov	r1, r6
18008aac:	9304      	str	r3, [sp, #16]
18008aae:	6963      	ldr	r3, [r4, #20]
18008ab0:	4628      	mov	r0, r5
18008ab2:	9303      	str	r3, [sp, #12]
18008ab4:	6923      	ldr	r3, [r4, #16]
18008ab6:	9302      	str	r3, [sp, #8]
18008ab8:	68e3      	ldr	r3, [r4, #12]
18008aba:	9301      	str	r3, [sp, #4]
18008abc:	68a3      	ldr	r3, [r4, #8]
18008abe:	9300      	str	r3, [sp, #0]
18008ac0:	e9d4 2300 	ldrd	r2, r3, [r4]
18008ac4:	f7f9 ff20 	bl	18002908 <print_formatted>
		break;
18008ac8:	e7ae      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008aca:	69e3      	ldr	r3, [r4, #28]
18008acc:	4631      	mov	r1, r6
18008ace:	9305      	str	r3, [sp, #20]
18008ad0:	69a3      	ldr	r3, [r4, #24]
18008ad2:	4628      	mov	r0, r5
18008ad4:	9304      	str	r3, [sp, #16]
18008ad6:	6963      	ldr	r3, [r4, #20]
18008ad8:	9303      	str	r3, [sp, #12]
18008ada:	6923      	ldr	r3, [r4, #16]
18008adc:	9302      	str	r3, [sp, #8]
18008ade:	68e3      	ldr	r3, [r4, #12]
18008ae0:	9301      	str	r3, [sp, #4]
18008ae2:	68a3      	ldr	r3, [r4, #8]
18008ae4:	9300      	str	r3, [sp, #0]
18008ae6:	e9d4 2300 	ldrd	r2, r3, [r4]
18008aea:	f7f9 ff0d 	bl	18002908 <print_formatted>
		break;
18008aee:	e79b      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008af0:	6a23      	ldr	r3, [r4, #32]
18008af2:	4631      	mov	r1, r6
18008af4:	9306      	str	r3, [sp, #24]
18008af6:	69e3      	ldr	r3, [r4, #28]
18008af8:	4628      	mov	r0, r5
18008afa:	9305      	str	r3, [sp, #20]
18008afc:	69a3      	ldr	r3, [r4, #24]
18008afe:	9304      	str	r3, [sp, #16]
18008b00:	6963      	ldr	r3, [r4, #20]
18008b02:	9303      	str	r3, [sp, #12]
18008b04:	6923      	ldr	r3, [r4, #16]
18008b06:	9302      	str	r3, [sp, #8]
18008b08:	68e3      	ldr	r3, [r4, #12]
18008b0a:	9301      	str	r3, [sp, #4]
18008b0c:	68a3      	ldr	r3, [r4, #8]
18008b0e:	9300      	str	r3, [sp, #0]
18008b10:	e9d4 2300 	ldrd	r2, r3, [r4]
18008b14:	f7f9 fef8 	bl	18002908 <print_formatted>
		break;
18008b18:	e786      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008b1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
18008b1c:	4631      	mov	r1, r6
18008b1e:	9307      	str	r3, [sp, #28]
18008b20:	6a23      	ldr	r3, [r4, #32]
18008b22:	4628      	mov	r0, r5
18008b24:	9306      	str	r3, [sp, #24]
18008b26:	69e3      	ldr	r3, [r4, #28]
18008b28:	9305      	str	r3, [sp, #20]
18008b2a:	69a3      	ldr	r3, [r4, #24]
18008b2c:	9304      	str	r3, [sp, #16]
18008b2e:	6963      	ldr	r3, [r4, #20]
18008b30:	9303      	str	r3, [sp, #12]
18008b32:	6923      	ldr	r3, [r4, #16]
18008b34:	9302      	str	r3, [sp, #8]
18008b36:	68e3      	ldr	r3, [r4, #12]
18008b38:	9301      	str	r3, [sp, #4]
18008b3a:	68a3      	ldr	r3, [r4, #8]
18008b3c:	9300      	str	r3, [sp, #0]
18008b3e:	e9d4 2300 	ldrd	r2, r3, [r4]
18008b42:	f7f9 fee1 	bl	18002908 <print_formatted>
		break;
18008b46:	e76f      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008b48:	6aa3      	ldr	r3, [r4, #40]	; 0x28
18008b4a:	4631      	mov	r1, r6
18008b4c:	9308      	str	r3, [sp, #32]
18008b4e:	6a63      	ldr	r3, [r4, #36]	; 0x24
18008b50:	4628      	mov	r0, r5
18008b52:	9307      	str	r3, [sp, #28]
18008b54:	6a23      	ldr	r3, [r4, #32]
18008b56:	9306      	str	r3, [sp, #24]
18008b58:	69e3      	ldr	r3, [r4, #28]
18008b5a:	9305      	str	r3, [sp, #20]
18008b5c:	69a3      	ldr	r3, [r4, #24]
18008b5e:	9304      	str	r3, [sp, #16]
18008b60:	6963      	ldr	r3, [r4, #20]
18008b62:	9303      	str	r3, [sp, #12]
18008b64:	6923      	ldr	r3, [r4, #16]
18008b66:	9302      	str	r3, [sp, #8]
18008b68:	68e3      	ldr	r3, [r4, #12]
18008b6a:	9301      	str	r3, [sp, #4]
18008b6c:	68a3      	ldr	r3, [r4, #8]
18008b6e:	9300      	str	r3, [sp, #0]
18008b70:	e9d4 2300 	ldrd	r2, r3, [r4]
18008b74:	f7f9 fec8 	bl	18002908 <print_formatted>
		break;
18008b78:	e756      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008b7a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
18008b7c:	4631      	mov	r1, r6
18008b7e:	9309      	str	r3, [sp, #36]	; 0x24
18008b80:	6aa3      	ldr	r3, [r4, #40]	; 0x28
18008b82:	4628      	mov	r0, r5
18008b84:	9308      	str	r3, [sp, #32]
18008b86:	6a63      	ldr	r3, [r4, #36]	; 0x24
18008b88:	9307      	str	r3, [sp, #28]
18008b8a:	6a23      	ldr	r3, [r4, #32]
18008b8c:	9306      	str	r3, [sp, #24]
18008b8e:	69e3      	ldr	r3, [r4, #28]
18008b90:	9305      	str	r3, [sp, #20]
18008b92:	69a3      	ldr	r3, [r4, #24]
18008b94:	9304      	str	r3, [sp, #16]
18008b96:	6963      	ldr	r3, [r4, #20]
18008b98:	9303      	str	r3, [sp, #12]
18008b9a:	6923      	ldr	r3, [r4, #16]
18008b9c:	9302      	str	r3, [sp, #8]
18008b9e:	68e3      	ldr	r3, [r4, #12]
18008ba0:	9301      	str	r3, [sp, #4]
18008ba2:	68a3      	ldr	r3, [r4, #8]
18008ba4:	9300      	str	r3, [sp, #0]
18008ba6:	e9d4 2300 	ldrd	r2, r3, [r4]
18008baa:	f7f9 fead 	bl	18002908 <print_formatted>
		break;
18008bae:	e73b      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008bb0:	6b23      	ldr	r3, [r4, #48]	; 0x30
18008bb2:	4631      	mov	r1, r6
18008bb4:	930a      	str	r3, [sp, #40]	; 0x28
18008bb6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
18008bb8:	4628      	mov	r0, r5
18008bba:	9309      	str	r3, [sp, #36]	; 0x24
18008bbc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
18008bbe:	9308      	str	r3, [sp, #32]
18008bc0:	6a63      	ldr	r3, [r4, #36]	; 0x24
18008bc2:	9307      	str	r3, [sp, #28]
18008bc4:	6a23      	ldr	r3, [r4, #32]
18008bc6:	9306      	str	r3, [sp, #24]
18008bc8:	69e3      	ldr	r3, [r4, #28]
18008bca:	9305      	str	r3, [sp, #20]
18008bcc:	69a3      	ldr	r3, [r4, #24]
18008bce:	9304      	str	r3, [sp, #16]
18008bd0:	6963      	ldr	r3, [r4, #20]
18008bd2:	9303      	str	r3, [sp, #12]
18008bd4:	6923      	ldr	r3, [r4, #16]
18008bd6:	9302      	str	r3, [sp, #8]
18008bd8:	68e3      	ldr	r3, [r4, #12]
18008bda:	9301      	str	r3, [sp, #4]
18008bdc:	68a3      	ldr	r3, [r4, #8]
18008bde:	9300      	str	r3, [sp, #0]
18008be0:	e9d4 2300 	ldrd	r2, r3, [r4]
18008be4:	f7f9 fe90 	bl	18002908 <print_formatted>
		break;
18008be8:	e71e      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008bea:	6b63      	ldr	r3, [r4, #52]	; 0x34
18008bec:	4631      	mov	r1, r6
18008bee:	930b      	str	r3, [sp, #44]	; 0x2c
18008bf0:	6b23      	ldr	r3, [r4, #48]	; 0x30
18008bf2:	4628      	mov	r0, r5
18008bf4:	930a      	str	r3, [sp, #40]	; 0x28
18008bf6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
18008bf8:	9309      	str	r3, [sp, #36]	; 0x24
18008bfa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
18008bfc:	9308      	str	r3, [sp, #32]
18008bfe:	6a63      	ldr	r3, [r4, #36]	; 0x24
18008c00:	9307      	str	r3, [sp, #28]
18008c02:	6a23      	ldr	r3, [r4, #32]
18008c04:	9306      	str	r3, [sp, #24]
18008c06:	69e3      	ldr	r3, [r4, #28]
18008c08:	9305      	str	r3, [sp, #20]
18008c0a:	69a3      	ldr	r3, [r4, #24]
18008c0c:	9304      	str	r3, [sp, #16]
18008c0e:	6963      	ldr	r3, [r4, #20]
18008c10:	9303      	str	r3, [sp, #12]
18008c12:	6923      	ldr	r3, [r4, #16]
18008c14:	9302      	str	r3, [sp, #8]
18008c16:	68e3      	ldr	r3, [r4, #12]
18008c18:	9301      	str	r3, [sp, #4]
18008c1a:	68a3      	ldr	r3, [r4, #8]
18008c1c:	9300      	str	r3, [sp, #0]
18008c1e:	e9d4 2300 	ldrd	r2, r3, [r4]
18008c22:	f7f9 fe71 	bl	18002908 <print_formatted>
		break;
18008c26:	e6ff      	b.n	18008a28 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
18008c28:	6ba3      	ldr	r3, [r4, #56]	; 0x38
18008c2a:	4631      	mov	r1, r6
18008c2c:	930c      	str	r3, [sp, #48]	; 0x30
18008c2e:	6b63      	ldr	r3, [r4, #52]	; 0x34
18008c30:	4628      	mov	r0, r5
18008c32:	930b      	str	r3, [sp, #44]	; 0x2c
18008c34:	6b23      	ldr	r3, [r4, #48]	; 0x30
18008c36:	930a      	str	r3, [sp, #40]	; 0x28
18008c38:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
18008c3a:	9309      	str	r3, [sp, #36]	; 0x24
18008c3c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
18008c3e:	9308      	str	r3, [sp, #32]
18008c40:	6a63      	ldr	r3, [r4, #36]	; 0x24
18008c42:	9307      	str	r3, [sp, #28]
18008c44:	6a23      	ldr	r3, [r4, #32]
18008c46:	9306      	str	r3, [sp, #24]
18008c48:	69e3      	ldr	r3, [r4, #28]
18008c4a:	9305      	str	r3, [sp, #20]
18008c4c:	69a3      	ldr	r3, [r4, #24]
18008c4e:	9304      	str	r3, [sp, #16]
18008c50:	6963      	ldr	r3, [r4, #20]
18008c52:	9303      	str	r3, [sp, #12]
18008c54:	6923      	ldr	r3, [r4, #16]
18008c56:	9302      	str	r3, [sp, #8]
18008c58:	68e3      	ldr	r3, [r4, #12]
18008c5a:	9301      	str	r3, [sp, #4]
18008c5c:	68a3      	ldr	r3, [r4, #8]
18008c5e:	9300      	str	r3, [sp, #0]
18008c60:	e9d4 2300 	ldrd	r2, r3, [r4]
18008c64:	f7f9 fe50 	bl	18002908 <print_formatted>
}
18008c68:	e6de      	b.n	18008a28 <std_print+0x78>

18008c6a <log_output_flush>:
		     output->control_block->offset,
18008c6a:	6842      	ldr	r2, [r0, #4]
{
18008c6c:	b510      	push	{r4, lr}
	buffer_write(output->func, output->buf,
18008c6e:	e9d2 2300 	ldrd	r2, r3, [r2]
{
18008c72:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
18008c74:	6881      	ldr	r1, [r0, #8]
18008c76:	6800      	ldr	r0, [r0, #0]
18008c78:	f7ff fe8d 	bl	18008996 <buffer_write>
	output->control_block->offset = 0;
18008c7c:	2200      	movs	r2, #0
18008c7e:	6863      	ldr	r3, [r4, #4]
18008c80:	601a      	str	r2, [r3, #0]
}
18008c82:	bd10      	pop	{r4, pc}

18008c84 <out_func>:
{
18008c84:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
18008c86:	684b      	ldr	r3, [r1, #4]
{
18008c88:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
18008c8a:	681a      	ldr	r2, [r3, #0]
18008c8c:	68cb      	ldr	r3, [r1, #12]
{
18008c8e:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
18008c90:	429a      	cmp	r2, r3
18008c92:	d102      	bne.n	18008c9a <out_func+0x16>
		log_output_flush(out_ctx);
18008c94:	4608      	mov	r0, r1
18008c96:	f7ff ffe8 	bl	18008c6a <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
18008c9a:	6863      	ldr	r3, [r4, #4]
18008c9c:	e8d3 2fef 	ldaex	r2, [r3]
18008ca0:	1c51      	adds	r1, r2, #1
18008ca2:	e8c3 1fe0 	stlex	r0, r1, [r3]
18008ca6:	2800      	cmp	r0, #0
18008ca8:	d1f8      	bne.n	18008c9c <out_func+0x18>
	out_ctx->buf[idx] = (uint8_t)c;
18008caa:	68a3      	ldr	r3, [r4, #8]
}
18008cac:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
18008cae:	549d      	strb	r5, [r3, r2]
}
18008cb0:	bd38      	pop	{r3, r4, r5, pc}

18008cb2 <log_halt>:
18008cb2:	2000      	movs	r0, #0
18008cb4:	684b      	ldr	r3, [r1, #4]
18008cb6:	7158      	strb	r0, [r3, #5]
}
18008cb8:	4770      	bx	lr

18008cba <log_go>:
	backend->cb->active = true;
18008cba:	2201      	movs	r2, #1
18008cbc:	684b      	ldr	r3, [r1, #4]
}
18008cbe:	2000      	movs	r0, #0
18008cc0:	715a      	strb	r2, [r3, #5]
18008cc2:	4770      	bx	lr

18008cc4 <cmd_log_self_status>:
{
18008cc4:	b570      	push	{r4, r5, r6, lr}
18008cc6:	4604      	mov	r4, r0
18008cc8:	460d      	mov	r5, r1
18008cca:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
18008ccc:	f7fa f94e 	bl	18002f6c <shell_state_precheck>
18008cd0:	b130      	cbz	r0, 18008ce0 <cmd_log_self_status+0x1c>
	log_status(shell, shell->log_backend->backend, argc, argv);
18008cd2:	69e1      	ldr	r1, [r4, #28]
18008cd4:	4633      	mov	r3, r6
18008cd6:	462a      	mov	r2, r5
18008cd8:	4620      	mov	r0, r4
18008cda:	6809      	ldr	r1, [r1, #0]
18008cdc:	f7fa f87e 	bl	18002ddc <log_status>
}
18008ce0:	2000      	movs	r0, #0
18008ce2:	bd70      	pop	{r4, r5, r6, pc}

18008ce4 <cmd_log_self_enable>:
{
18008ce4:	b570      	push	{r4, r5, r6, lr}
18008ce6:	4604      	mov	r4, r0
18008ce8:	460d      	mov	r5, r1
18008cea:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
18008cec:	f7fa f93e 	bl	18002f6c <shell_state_precheck>
18008cf0:	b140      	cbz	r0, 18008d04 <cmd_log_self_enable+0x20>
	return log_enable(shell, shell->log_backend->backend, argc, argv);
18008cf2:	69e1      	ldr	r1, [r4, #28]
18008cf4:	4633      	mov	r3, r6
18008cf6:	462a      	mov	r2, r5
18008cf8:	4620      	mov	r0, r4
}
18008cfa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return log_enable(shell, shell->log_backend->backend, argc, argv);
18008cfe:	6809      	ldr	r1, [r1, #0]
18008d00:	f7fa b9ac 	b.w	1800305c <log_enable>
}
18008d04:	bd70      	pop	{r4, r5, r6, pc}

18008d06 <log_disable>:
{
18008d06:	b513      	push	{r0, r1, r4, lr}
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
18008d08:	2400      	movs	r4, #0
18008d0a:	3304      	adds	r3, #4
18008d0c:	9400      	str	r4, [sp, #0]
18008d0e:	3a01      	subs	r2, #1
18008d10:	f7fa f93c 	bl	18002f8c <filters_set>
}
18008d14:	4620      	mov	r0, r4
18008d16:	b002      	add	sp, #8
18008d18:	bd10      	pop	{r4, pc}

18008d1a <cmd_log_self_disable>:
{
18008d1a:	b570      	push	{r4, r5, r6, lr}
18008d1c:	4604      	mov	r4, r0
18008d1e:	460d      	mov	r5, r1
18008d20:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
18008d22:	f7fa f923 	bl	18002f6c <shell_state_precheck>
18008d26:	b140      	cbz	r0, 18008d3a <cmd_log_self_disable+0x20>
	return log_disable(shell, shell->log_backend->backend, argc, argv);
18008d28:	69e1      	ldr	r1, [r4, #28]
18008d2a:	4633      	mov	r3, r6
18008d2c:	462a      	mov	r2, r5
18008d2e:	4620      	mov	r0, r4
}
18008d30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return log_disable(shell, shell->log_backend->backend, argc, argv);
18008d34:	6809      	ldr	r1, [r1, #0]
18008d36:	f7ff bfe6 	b.w	18008d06 <log_disable>
}
18008d3a:	bd70      	pop	{r4, r5, r6, pc}

18008d3c <cmd_log_self_go>:
{
18008d3c:	b510      	push	{r4, lr}
18008d3e:	4604      	mov	r4, r0
	if (!shell_state_precheck(shell)) {
18008d40:	f7fa f914 	bl	18002f6c <shell_state_precheck>
18008d44:	b120      	cbz	r0, 18008d50 <cmd_log_self_go+0x14>
18008d46:	2201      	movs	r2, #1
	return log_go(shell, shell->log_backend->backend, argc, argv);
18008d48:	69e3      	ldr	r3, [r4, #28]
	log_backend_activate(backend, backend->cb->ctx);
18008d4a:	681b      	ldr	r3, [r3, #0]
18008d4c:	685b      	ldr	r3, [r3, #4]
18008d4e:	715a      	strb	r2, [r3, #5]
}
18008d50:	2000      	movs	r0, #0
18008d52:	bd10      	pop	{r4, pc}

18008d54 <cmd_log_self_halt>:
{
18008d54:	b510      	push	{r4, lr}
18008d56:	4604      	mov	r4, r0
	if (!shell_state_precheck(shell)) {
18008d58:	f7fa f908 	bl	18002f6c <shell_state_precheck>
18008d5c:	b120      	cbz	r0, 18008d68 <cmd_log_self_halt+0x14>
	backend->cb->active = false;
18008d5e:	2200      	movs	r2, #0
	return log_halt(shell, shell->log_backend->backend, argc, argv);
18008d60:	69e3      	ldr	r3, [r4, #28]
18008d62:	681b      	ldr	r3, [r3, #0]
18008d64:	685b      	ldr	r3, [r3, #4]
18008d66:	715a      	strb	r2, [r3, #5]
}
18008d68:	2000      	movs	r0, #0
18008d6a:	bd10      	pop	{r4, pc}

18008d6c <cmd_kernel_reboot_warm>:
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
#if (CONFIG_KERNEL_SHELL_REBOOT_DELAY > 0)
	k_sleep(K_MSEC(CONFIG_KERNEL_SHELL_REBOOT_DELAY));
#endif
	sys_reboot(SYS_REBOOT_WARM);
18008d6c:	2000      	movs	r0, #0
{
18008d6e:	b508      	push	{r3, lr}
	sys_reboot(SYS_REBOOT_WARM);
18008d70:	f7f9 f924 	bl	18001fbc <sys_reboot>

18008d74 <cmd_kernel_reboot_cold>:
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
#if (CONFIG_KERNEL_SHELL_REBOOT_DELAY > 0)
	k_sleep(K_MSEC(CONFIG_KERNEL_SHELL_REBOOT_DELAY));
#endif
	sys_reboot(SYS_REBOOT_COLD);
18008d74:	2001      	movs	r0, #1
{
18008d76:	b508      	push	{r3, lr}
	sys_reboot(SYS_REBOOT_COLD);
18008d78:	f7f9 f920 	bl	18001fbc <sys_reboot>

18008d7c <enable>:
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
18008d7c:	6843      	ldr	r3, [r0, #4]
}
18008d7e:	2000      	movs	r0, #0
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
18008d80:	681b      	ldr	r3, [r3, #0]
18008d82:	7419      	strb	r1, [r3, #16]
}
18008d84:	4770      	bx	lr

18008d86 <write>:
{
18008d86:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
18008d8a:	4615      	mov	r5, r2
18008d8c:	461e      	mov	r6, r3
18008d8e:	460c      	mov	r4, r1
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
18008d90:	f8d0 8004 	ldr.w	r8, [r0, #4]
		for (size_t i = 0; i < length; i++) {
18008d94:	188f      	adds	r7, r1, r2
18008d96:	42bc      	cmp	r4, r7
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
18008d98:	f8d8 2000 	ldr.w	r2, [r8]
		for (size_t i = 0; i < length; i++) {
18008d9c:	d107      	bne.n	18008dae <write+0x28>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
18008d9e:	e9d2 3101 	ldrd	r3, r1, [r2, #4]
18008da2:	2001      	movs	r0, #1
		*cnt = length;
18008da4:	6035      	str	r5, [r6, #0]
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
18008da6:	4798      	blx	r3
}
18008da8:	2000      	movs	r0, #0
18008daa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
18008dae:	6810      	ldr	r0, [r2, #0]
18008db0:	f814 1b01 	ldrb.w	r1, [r4], #1
18008db4:	6883      	ldr	r3, [r0, #8]
18008db6:	685b      	ldr	r3, [r3, #4]
18008db8:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
18008dba:	e7ec      	b.n	18008d96 <write+0x10>

18008dbc <read>:
{
18008dbc:	b510      	push	{r4, lr}
18008dbe:	461c      	mov	r4, r3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
18008dc0:	6843      	ldr	r3, [r0, #4]
18008dc2:	68d8      	ldr	r0, [r3, #12]
18008dc4:	f7ff fb54 	bl	18008470 <ring_buf_get>
18008dc8:	6020      	str	r0, [r4, #0]
}
18008dca:	2000      	movs	r0, #0
18008dcc:	bd10      	pop	{r4, pc}

18008dce <uninit>:
{
18008dce:	b508      	push	{r3, lr}
		k_timer_stop(sh_uart->timer);
18008dd0:	6843      	ldr	r3, [r0, #4]
18008dd2:	6858      	ldr	r0, [r3, #4]
	z_impl_k_timer_stop(timer);
18008dd4:	f001 ffcc 	bl	1800ad70 <z_impl_k_timer_stop>
}
18008dd8:	2000      	movs	r0, #0
18008dda:	bd08      	pop	{r3, pc}

18008ddc <atomic_or>:
 * @param value Value to OR.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
18008ddc:	4603      	mov	r3, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
}
18008dde:	e8d3 0fef 	ldaex	r0, [r3]
18008de2:	ea40 0201 	orr.w	r2, r0, r1
18008de6:	e8c3 2fec 	stlex	ip, r2, [r3]
18008dea:	f1bc 0f00 	cmp.w	ip, #0
18008dee:	d1f6      	bne.n	18008dde <atomic_or+0x2>
18008df0:	4770      	bx	lr

18008df2 <atomic_and>:
 * @param value Value to AND.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
18008df2:	4603      	mov	r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
}
18008df4:	e8d3 0fef 	ldaex	r0, [r3]
18008df8:	ea00 0201 	and.w	r2, r0, r1
18008dfc:	e8c3 2fec 	stlex	ip, r2, [r3]
18008e00:	f1bc 0f00 	cmp.w	ip, #0
18008e04:	d1f6      	bne.n	18008df4 <atomic_and+0x2>
18008e06:	4770      	bx	lr

18008e08 <shell_signal_handle>:
{
18008e08:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
18008e0a:	6885      	ldr	r5, [r0, #8]
18008e0c:	0109      	lsls	r1, r1, #4
18008e0e:	f501 711a 	add.w	r1, r1, #616	; 0x268
{
18008e12:	4604      	mov	r4, r0
18008e14:	4616      	mov	r6, r2
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
18008e16:	440d      	add	r5, r1
		arch_syscall_invoke3(*(uintptr_t *)&sig, *(uintptr_t *)&signaled, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(sig, signaled, result);
18008e18:	4669      	mov	r1, sp
18008e1a:	4628      	mov	r0, r5
18008e1c:	aa01      	add	r2, sp, #4
18008e1e:	f002 f91b 	bl	1800b058 <z_impl_k_poll_signal_check>
	if (set) {
18008e22:	9b00      	ldr	r3, [sp, #0]
18008e24:	b123      	cbz	r3, 18008e30 <shell_signal_handle+0x28>
	z_impl_k_poll_signal_reset(sig);
18008e26:	4628      	mov	r0, r5
18008e28:	f002 f913 	bl	1800b052 <z_impl_k_poll_signal_reset>
		handler(shell);
18008e2c:	4620      	mov	r0, r4
18008e2e:	47b0      	blx	r6
}
18008e30:	b002      	add	sp, #8
18008e32:	bd70      	pop	{r4, r5, r6, pc}

18008e34 <z_shell_strlen>:
{
18008e34:	b508      	push	{r3, lr}
	return str == NULL ? 0U : (uint16_t)strlen(str);
18008e36:	b110      	cbz	r0, 18008e3e <z_shell_strlen+0xa>
18008e38:	f001 f935 	bl	1800a0a6 <strlen>
18008e3c:	b280      	uxth	r0, r0
}
18008e3e:	bd08      	pop	{r3, pc}

18008e40 <z_shell_raw_fprintf>:
{
18008e40:	b40e      	push	{r1, r2, r3}
18008e42:	b503      	push	{r0, r1, lr}
18008e44:	aa03      	add	r2, sp, #12
18008e46:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
18008e4a:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
18008e4c:	f7fb fa8a 	bl	18004364 <z_shell_fprintf_fmt>
}
18008e50:	b002      	add	sp, #8
18008e52:	f85d eb04 	ldr.w	lr, [sp], #4
18008e56:	b003      	add	sp, #12
18008e58:	4770      	bx	lr

18008e5a <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
18008e5a:	f7fe b8ad 	b.w	18006fb8 <z_impl_k_mutex_lock>

18008e5e <transport_evt_handler>:
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
18008e5e:	688b      	ldr	r3, [r1, #8]
18008e60:	b920      	cbnz	r0, 18008e6c <transport_evt_handler+0xe>
18008e62:	f503 701a 	add.w	r0, r3, #616	; 0x268
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
18008e66:	2100      	movs	r1, #0
18008e68:	f7fe bf72 	b.w	18007d50 <z_impl_k_poll_signal_raise>
18008e6c:	f503 7026 	add.w	r0, r3, #664	; 0x298
18008e70:	e7f9      	b.n	18008e66 <transport_evt_handler+0x8>

18008e72 <kill_handler>:
{
18008e72:	b538      	push	{r3, r4, r5, lr}
	return sh->ctx->ctx.flags.processing == 1;
18008e74:	6883      	ldr	r3, [r0, #8]
18008e76:	4604      	mov	r4, r0
18008e78:	f8d3 3264 	ldr.w	r3, [r3, #612]	; 0x264
	if (z_flag_processing_get(shell)) {
18008e7c:	07db      	lsls	r3, r3, #31
18008e7e:	d41d      	bmi.n	18008ebc <kill_handler+0x4a>
		z_shell_log_backend_disable(shell->log_backend);
18008e80:	69c0      	ldr	r0, [r0, #28]
18008e82:	f000 fd45 	bl	18009910 <z_shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
18008e86:	6860      	ldr	r0, [r4, #4]
18008e88:	6803      	ldr	r3, [r0, #0]
18008e8a:	685b      	ldr	r3, [r3, #4]
18008e8c:	4798      	blx	r3
	if (err != 0) {
18008e8e:	4605      	mov	r5, r0
18008e90:	b920      	cbnz	r0, 18008e9c <kill_handler+0x2a>
	z_shell_history_purge(shell->history);
18008e92:	68e0      	ldr	r0, [r4, #12]
18008e94:	f000 fed4 	bl	18009c40 <z_shell_history_purge>
	shell->ctx->state = state;
18008e98:	68a3      	ldr	r3, [r4, #8]
18008e9a:	711d      	strb	r5, [r3, #4]
	if (shell->ctx->uninit_cb) {
18008e9c:	68a3      	ldr	r3, [r4, #8]
18008e9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
18008ea0:	b113      	cbz	r3, 18008ea8 <kill_handler+0x36>
		shell->ctx->uninit_cb(shell, err);
18008ea2:	4629      	mov	r1, r5
18008ea4:	4620      	mov	r0, r4
18008ea6:	4798      	blx	r3
	shell->ctx->tid = NULL;
18008ea8:	2200      	movs	r2, #0
18008eaa:	68a3      	ldr	r3, [r4, #8]
18008eac:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	return z_impl_z_current_get();
18008eb0:	f7fe fc72 	bl	18007798 <z_impl_z_current_get>
}
18008eb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_thread_abort(thread);
18008eb8:	f7fc bbb4 	b.w	18005624 <z_impl_k_thread_abort>
		return -EBUSY;
18008ebc:	f06f 050f 	mvn.w	r5, #15
18008ec0:	e7ec      	b.n	18008e9c <kill_handler+0x2a>

18008ec2 <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, history_exit, val, ret);
18008ec2:	f500 7019 	add.w	r0, r0, #612	; 0x264
18008ec6:	b111      	cbz	r1, 18008ece <z_flag_history_exit_set.isra.0+0xc>
18008ec8:	2104      	movs	r1, #4
18008eca:	f7ff bf87 	b.w	18008ddc <atomic_or>
18008ece:	f06f 0104 	mvn.w	r1, #4
18008ed2:	f7ff bf8e 	b.w	18008df2 <atomic_and>

18008ed6 <z_flag_insert_mode_set.isra.0>:
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
18008ed6:	b508      	push	{r3, lr}
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
18008ed8:	f500 7018 	add.w	r0, r0, #608	; 0x260
18008edc:	b129      	cbz	r1, 18008eea <z_flag_insert_mode_set.isra.0+0x14>
18008ede:	2101      	movs	r1, #1
18008ee0:	f7ff ff7c 	bl	18008ddc <atomic_or>
}
18008ee4:	f000 0001 	and.w	r0, r0, #1
18008ee8:	bd08      	pop	{r3, pc}
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
18008eea:	f06f 0101 	mvn.w	r1, #1
18008eee:	f7ff ff80 	bl	18008df2 <atomic_and>
18008ef2:	e7f7      	b.n	18008ee4 <z_flag_insert_mode_set.isra.0+0xe>

18008ef4 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
18008ef4:	f7fe b8d8 	b.w	180070a8 <z_impl_k_mutex_unlock>

18008ef8 <shell_log_process>:
	int signaled = 0;
18008ef8:	2300      	movs	r3, #0
{
18008efa:	b573      	push	{r0, r1, r4, r5, r6, lr}
18008efc:	4604      	mov	r4, r0
	int signaled = 0;
18008efe:	9300      	str	r3, [sp, #0]
			z_shell_cmd_line_erase(shell);
18008f00:	4620      	mov	r0, r4
18008f02:	f000 fb60 	bl	180095c6 <z_shell_cmd_line_erase>
			processed = z_shell_log_backend_process(
18008f06:	69e0      	ldr	r0, [r4, #28]
18008f08:	f000 fd0b 	bl	18009922 <z_shell_log_backend_process>
18008f0c:	4605      	mov	r5, r0
		z_shell_print_prompt_and_cmd(shell);
18008f0e:	4620      	mov	r0, r4
		struct k_poll_signal *signal =
18008f10:	68a6      	ldr	r6, [r4, #8]
		z_shell_print_prompt_and_cmd(shell);
18008f12:	f7fb fbb1 	bl	18004678 <z_shell_print_prompt_and_cmd>
		if (shell->ctx->cmd_buff_len) {
18008f16:	68a3      	ldr	r3, [r4, #8]
		struct k_poll_signal *signal =
18008f18:	f506 761a 	add.w	r6, r6, #616	; 0x268
		if (shell->ctx->cmd_buff_len) {
18008f1c:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
18008f1e:	b11b      	cbz	r3, 18008f28 <shell_log_process+0x30>
	return z_impl_k_sleep(timeout);
18008f20:	2096      	movs	r0, #150	; 0x96
18008f22:	2100      	movs	r1, #0
18008f24:	f7fe fc20 	bl	18007768 <z_impl_k_sleep>
	z_impl_k_poll_signal_check(sig, signaled, result);
18008f28:	4669      	mov	r1, sp
18008f2a:	4630      	mov	r0, r6
18008f2c:	aa01      	add	r2, sp, #4
18008f2e:	f002 f893 	bl	1800b058 <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
18008f32:	b115      	cbz	r5, 18008f3a <shell_log_process+0x42>
18008f34:	9b00      	ldr	r3, [sp, #0]
18008f36:	2b00      	cmp	r3, #0
18008f38:	d0e2      	beq.n	18008f00 <shell_log_process+0x8>
}
18008f3a:	b002      	add	sp, #8
18008f3c:	bd70      	pop	{r4, r5, r6, pc}

18008f3e <shell_vfprintf>:
{
18008f3e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18008f40:	4604      	mov	r4, r0
	return shell->ctx->state;
18008f42:	6880      	ldr	r0, [r0, #8]
{
18008f44:	461f      	mov	r7, r3
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
18008f46:	7903      	ldrb	r3, [r0, #4]
{
18008f48:	460d      	mov	r5, r1
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
18008f4a:	2b02      	cmp	r3, #2
{
18008f4c:	4616      	mov	r6, r2
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
18008f4e:	d007      	beq.n	18008f60 <shell_vfprintf+0x22>
}
18008f50:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
18008f54:	f44f 5180 	mov.w	r1, #4096	; 0x1000
18008f58:	f500 7019 	add.w	r0, r0, #612	; 0x264
18008f5c:	f7ff bf3e 	b.w	18008ddc <atomic_or>
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
18008f60:	f04f 32ff 	mov.w	r2, #4294967295
18008f64:	f04f 33ff 	mov.w	r3, #4294967295
18008f68:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
18008f6c:	f7ff ff75 	bl	18008e5a <k_mutex_lock.constprop.0.isra.0>
	return sh->ctx->ctx.flags.cmd_ctx == 1;
18008f70:	68a3      	ldr	r3, [r4, #8]
18008f72:	f8d3 2264 	ldr.w	r2, [r3, #612]	; 0x264
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
18008f76:	0511      	lsls	r1, r2, #20
18008f78:	d404      	bmi.n	18008f84 <shell_vfprintf+0x46>
18008f7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
18008f7c:	b913      	cbnz	r3, 18008f84 <shell_vfprintf+0x46>
		z_shell_cmd_line_erase(sh);
18008f7e:	4620      	mov	r0, r4
18008f80:	f000 fb21 	bl	180095c6 <z_shell_cmd_line_erase>
	z_shell_vfprintf(sh, color, fmt, args);
18008f84:	463b      	mov	r3, r7
18008f86:	4632      	mov	r2, r6
18008f88:	4629      	mov	r1, r5
18008f8a:	4620      	mov	r0, r4
18008f8c:	f000 fb78 	bl	18009680 <z_shell_vfprintf>
18008f90:	68a3      	ldr	r3, [r4, #8]
18008f92:	f8d3 2264 	ldr.w	r2, [r3, #612]	; 0x264
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
18008f96:	0512      	lsls	r2, r2, #20
18008f98:	d404      	bmi.n	18008fa4 <shell_vfprintf+0x66>
18008f9a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
18008f9c:	b913      	cbnz	r3, 18008fa4 <shell_vfprintf+0x66>
		z_shell_print_prompt_and_cmd(sh);
18008f9e:	4620      	mov	r0, r4
18008fa0:	f7fb fb6a 	bl	18004678 <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
18008fa4:	6960      	ldr	r0, [r4, #20]
18008fa6:	f000 f817 	bl	18008fd8 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&sh->ctx->wr_mtx);
18008faa:	68a0      	ldr	r0, [r4, #8]
}
18008fac:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	k_mutex_unlock(&sh->ctx->wr_mtx);
18008fb0:	f500 703e 	add.w	r0, r0, #760	; 0x2f8
18008fb4:	f7ff bf9e 	b.w	18008ef4 <k_mutex_unlock.isra.0>

18008fb8 <shell_fprintf>:
{
18008fb8:	b40c      	push	{r2, r3}
18008fba:	b507      	push	{r0, r1, r2, lr}
18008fbc:	ab04      	add	r3, sp, #16
18008fbe:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
18008fc2:	9301      	str	r3, [sp, #4]
	shell_vfprintf(shell, color, fmt, args);
18008fc4:	f7ff ffbb 	bl	18008f3e <shell_vfprintf>
}
18008fc8:	b003      	add	sp, #12
18008fca:	f85d eb04 	ldr.w	lr, [sp], #4
18008fce:	b002      	add	sp, #8
18008fd0:	4770      	bx	lr

18008fd2 <shell_set_bypass>:
	sh->ctx->bypass = bypass;
18008fd2:	6883      	ldr	r3, [r0, #8]
18008fd4:	6399      	str	r1, [r3, #56]	; 0x38
}
18008fd6:	4770      	bx	lr

18008fd8 <z_shell_fprintf_buffer_flush>:


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
18008fd8:	6902      	ldr	r2, [r0, #16]
{
18008fda:	b510      	push	{r4, lr}
18008fdc:	4604      	mov	r4, r0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
18008fde:	6883      	ldr	r3, [r0, #8]
18008fe0:	6812      	ldr	r2, [r2, #0]
18008fe2:	6801      	ldr	r1, [r0, #0]
18008fe4:	68c0      	ldr	r0, [r0, #12]
18008fe6:	4798      	blx	r3
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
18008fe8:	2200      	movs	r2, #0
18008fea:	6923      	ldr	r3, [r4, #16]
18008fec:	601a      	str	r2, [r3, #0]
}
18008fee:	bd10      	pop	{r4, pc}

18008ff0 <out_func>:
{
18008ff0:	b538      	push	{r3, r4, r5, lr}
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
18008ff2:	68cb      	ldr	r3, [r1, #12]
{
18008ff4:	4605      	mov	r5, r0
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
18008ff6:	7c1b      	ldrb	r3, [r3, #16]
{
18008ff8:	460c      	mov	r4, r1
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
18008ffa:	2b02      	cmp	r3, #2
18008ffc:	d104      	bne.n	18009008 <out_func+0x18>
18008ffe:	280a      	cmp	r0, #10
18009000:	d102      	bne.n	18009008 <out_func+0x18>
		(void)out_func('\r', ctx);
18009002:	200d      	movs	r0, #13
18009004:	f7ff fff4 	bl	18008ff0 <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
18009008:	6923      	ldr	r3, [r4, #16]
1800900a:	6822      	ldr	r2, [r4, #0]
1800900c:	681b      	ldr	r3, [r3, #0]
1800900e:	54d5      	strb	r5, [r2, r3]
	sh_fprintf->ctrl_blk->buffer_cnt++;
18009010:	6922      	ldr	r2, [r4, #16]
18009012:	6813      	ldr	r3, [r2, #0]
18009014:	3301      	adds	r3, #1
18009016:	6013      	str	r3, [r2, #0]
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
18009018:	6862      	ldr	r2, [r4, #4]
1800901a:	4293      	cmp	r3, r2
1800901c:	d102      	bne.n	18009024 <out_func+0x34>
		z_shell_fprintf_buffer_flush(sh_fprintf);
1800901e:	4620      	mov	r0, r4
18009020:	f7ff ffda 	bl	18008fd8 <z_shell_fprintf_buffer_flush>
}
18009024:	2000      	movs	r0, #0
18009026:	bd38      	pop	{r3, r4, r5, pc}

18009028 <isspace>:
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
18009028:	2820      	cmp	r0, #32
1800902a:	d005      	beq.n	18009038 <isspace+0x10>
1800902c:	3809      	subs	r0, #9
1800902e:	2804      	cmp	r0, #4
18009030:	bf8c      	ite	hi
18009032:	2000      	movhi	r0, #0
18009034:	2001      	movls	r0, #1
18009036:	4770      	bx	lr
18009038:	2001      	movs	r0, #1
}
1800903a:	4770      	bx	lr

1800903c <z_shell_strlen>:
{
1800903c:	b508      	push	{r3, lr}
	return str == NULL ? 0U : (uint16_t)strlen(str);
1800903e:	b110      	cbz	r0, 18009046 <z_shell_strlen+0xa>
18009040:	f001 f831 	bl	1800a0a6 <strlen>
18009044:	b280      	uxth	r0, r0
}
18009046:	bd08      	pop	{r3, pc}

18009048 <z_column_span_with_buffer_offsets_get>:
{
18009048:	b510      	push	{r4, lr}
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
1800904a:	7b03      	ldrb	r3, [r0, #12]
1800904c:	8940      	ldrh	r0, [r0, #10]
1800904e:	441a      	add	r2, r3
18009050:	4419      	add	r1, r3
18009052:	fbb2 f4f0 	udiv	r4, r2, r0
18009056:	fbb1 f3f0 	udiv	r3, r1, r0
1800905a:	fb00 2214 	mls	r2, r0, r4, r2
1800905e:	fb00 1013 	mls	r0, r0, r3, r1
}
18009062:	1a10      	subs	r0, r2, r0
18009064:	bd10      	pop	{r4, pc}

18009066 <z_row_span_with_buffer_offsets_get>:
{
18009066:	b510      	push	{r4, lr}
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
18009068:	7b04      	ldrb	r4, [r0, #12]
1800906a:	8943      	ldrh	r3, [r0, #10]
1800906c:	4421      	add	r1, r4
1800906e:	1910      	adds	r0, r2, r4
18009070:	fbb0 f0f3 	udiv	r0, r0, r3
18009074:	fbb1 f1f3 	udiv	r1, r1, r3
}
18009078:	1a40      	subs	r0, r0, r1
1800907a:	bd10      	pop	{r4, pc}

1800907c <z_shell_multiline_data_calc>:
{
1800907c:	b530      	push	{r4, r5, lr}
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
1800907e:	7b05      	ldrb	r5, [r0, #12]
18009080:	8943      	ldrh	r3, [r0, #10]
18009082:	4429      	add	r1, r5
18009084:	fbb1 f4f3 	udiv	r4, r1, r3
18009088:	fb03 1114 	mls	r1, r3, r4, r1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
1800908c:	442a      	add	r2, r5
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
1800908e:	3101      	adds	r1, #1
18009090:	8001      	strh	r1, [r0, #0]
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
18009092:	fbb2 f1f3 	udiv	r1, r2, r3
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
18009096:	fb03 2211 	mls	r2, r3, r1, r2
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
1800909a:	3401      	adds	r4, #1
1800909c:	8084      	strh	r4, [r0, #4]
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
1800909e:	3201      	adds	r2, #1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
180090a0:	1c4c      	adds	r4, r1, #1
180090a2:	80c4      	strh	r4, [r0, #6]
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
180090a4:	8042      	strh	r2, [r0, #2]
}
180090a6:	bd30      	pop	{r4, r5, pc}

180090a8 <z_shell_make_argv>:
{
180090a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	*argc = 0;
180090ac:	2500      	movs	r5, #0
{
180090ae:	4606      	mov	r6, r0
180090b0:	460f      	mov	r7, r1
180090b2:	4614      	mov	r4, r2
180090b4:	4698      	mov	r8, r3
	*argc = 0;
180090b6:	6005      	str	r5, [r0, #0]
		c = *cmd;
180090b8:	7820      	ldrb	r0, [r4, #0]
		if (c == '\0') {
180090ba:	2800      	cmp	r0, #0
180090bc:	f000 80b5 	beq.w	1800922a <z_shell_make_argv+0x182>
		if (isspace((int) c)) {
180090c0:	f7ff ffb2 	bl	18009028 <isspace>
180090c4:	b118      	cbz	r0, 180090ce <z_shell_make_argv+0x26>
			*cmd++ = '\0';
180090c6:	2300      	movs	r3, #0
180090c8:	f804 3b01 	strb.w	r3, [r4], #1
			continue;
180090cc:	e7f4      	b.n	180090b8 <z_shell_make_argv+0x10>
		argv[(*argc)++] = cmd;
180090ce:	6832      	ldr	r2, [r6, #0]
180090d0:	1c53      	adds	r3, r2, #1
		if (*argc == max_argc) {
180090d2:	4543      	cmp	r3, r8
		argv[(*argc)++] = cmd;
180090d4:	6033      	str	r3, [r6, #0]
180090d6:	f847 4022 	str.w	r4, [r7, r2, lsl #2]
		if (*argc == max_argc) {
180090da:	f000 80a6 	beq.w	1800922a <z_shell_make_argv+0x182>
	char quote = 0;
180090de:	4605      	mov	r5, r0
		c = *cmd;
180090e0:	f894 9000 	ldrb.w	r9, [r4]
		if (c == '\0') {
180090e4:	f1b9 0f00 	cmp.w	r9, #0
180090e8:	d0e6      	beq.n	180090b8 <z_shell_make_argv+0x10>
		if (!quote) {
180090ea:	2d00      	cmp	r5, #0
180090ec:	f040 8089 	bne.w	18009202 <z_shell_make_argv+0x15a>
			switch (c) {
180090f0:	f1b9 0f27 	cmp.w	r9, #39	; 0x27
180090f4:	d006      	beq.n	18009104 <z_shell_make_argv+0x5c>
180090f6:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
180090fa:	f000 808a 	beq.w	18009212 <z_shell_make_argv+0x16a>
180090fe:	f1b9 0f22 	cmp.w	r9, #34	; 0x22
18009102:	d176      	bne.n	180091f2 <z_shell_make_argv+0x14a>
						z_shell_strlen(cmd));
18009104:	4620      	mov	r0, r4
18009106:	f7ff ff99 	bl	1800903c <z_shell_strlen>
				memmove(cmd, cmd + 1,
1800910a:	1c61      	adds	r1, r4, #1
						z_shell_strlen(cmd));
1800910c:	4602      	mov	r2, r0
				memmove(cmd, cmd + 1,
1800910e:	4620      	mov	r0, r4
18009110:	f001 f807 	bl	1800a122 <memmove>
				continue;
18009114:	464d      	mov	r5, r9
18009116:	e7e3      	b.n	180090e0 <z_shell_make_argv+0x38>
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
18009118:	4620      	mov	r0, r4
1800911a:	f7ff ff8f 	bl	1800903c <z_shell_strlen>
1800911e:	1c61      	adds	r1, r4, #1
18009120:	4602      	mov	r2, r0
18009122:	4620      	mov	r0, r4
18009124:	f000 fffd 	bl	1800a122 <memmove>
			quote = 0;
18009128:	2500      	movs	r5, #0
			continue;
1800912a:	e7d9      	b.n	180090e0 <z_shell_make_argv+0x38>
			if (t == '0') {
1800912c:	2930      	cmp	r1, #48	; 0x30
1800912e:	d125      	bne.n	1800917c <z_shell_make_argv+0xd4>
18009130:	2302      	movs	r3, #2
				uint8_t v = 0U;
18009132:	f04f 0a00 	mov.w	sl, #0
					t = *(cmd + i);
18009136:	5ce1      	ldrb	r1, [r4, r3]
18009138:	fa5f f983 	uxtb.w	r9, r3
					if (t >= '0' && t <= '7') {
1800913c:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
18009140:	b2d0      	uxtb	r0, r2
18009142:	2807      	cmp	r0, #7
18009144:	d817      	bhi.n	18009176 <z_shell_make_argv+0xce>
				for (i = 2U; i < (2 + 3); i++) {
18009146:	3301      	adds	r3, #1
						v = (v << 3) | (t - '0');
18009148:	ea42 0aca 	orr.w	sl, r2, sl, lsl #3
				for (i = 2U; i < (2 + 3); i++) {
1800914c:	2b05      	cmp	r3, #5
						v = (v << 3) | (t - '0');
1800914e:	fa5f fa8a 	uxtb.w	sl, sl
				for (i = 2U; i < (2 + 3); i++) {
18009152:	d1f0      	bne.n	18009136 <z_shell_make_argv+0x8e>
18009154:	4699      	mov	r9, r3
						z_shell_strlen(cmd) - (i - 2));
18009156:	4620      	mov	r0, r4
18009158:	f7ff ff70 	bl	1800903c <z_shell_strlen>
					memmove(cmd, cmd + (i - 1),
1800915c:	f109 3bff 	add.w	fp, r9, #4294967295
18009160:	44a3      	add	fp, r4
						z_shell_strlen(cmd) - (i - 2));
18009162:	1c82      	adds	r2, r0, #2
					memmove(cmd, cmd + (i - 1),
18009164:	4659      	mov	r1, fp
18009166:	4620      	mov	r0, r4
18009168:	eba2 0209 	sub.w	r2, r2, r9
1800916c:	f000 ffd9 	bl	1800a122 <memmove>
					*cmd++ = v;
18009170:	f804 ab01 	strb.w	sl, [r4], #1
					continue;
18009174:	e7b4      	b.n	180090e0 <z_shell_make_argv+0x38>
				if (i > 2) {
18009176:	f1b9 0f02 	cmp.w	r9, #2
1800917a:	d1ec      	bne.n	18009156 <z_shell_make_argv+0xae>
			if (t == 'x') {
1800917c:	2978      	cmp	r1, #120	; 0x78
1800917e:	d13e      	bne.n	180091fe <z_shell_make_argv+0x156>
18009180:	2302      	movs	r3, #2
				uint8_t v = 0U;
18009182:	f04f 0900 	mov.w	r9, #0
					t = *(cmd + i);
18009186:	5ce2      	ldrb	r2, [r4, r3]
18009188:	b2d8      	uxtb	r0, r3
					if (t >= '0' && t <= '9') {
1800918a:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
1800918e:	fa5f fc81 	uxtb.w	ip, r1
18009192:	f1bc 0f09 	cmp.w	ip, #9
18009196:	d819      	bhi.n	180091cc <z_shell_make_argv+0x124>
						v = (v << 4) | (t - '0');
18009198:	ea41 1209 	orr.w	r2, r1, r9, lsl #4
				for (i = 2U; i < (2 + 2); i++) {
1800919c:	2b03      	cmp	r3, #3
						v = (v << 4) | (t - 'A' + 10);
1800919e:	fa5f f982 	uxtb.w	r9, r2
				for (i = 2U; i < (2 + 2); i++) {
180091a2:	d111      	bne.n	180091c8 <z_shell_make_argv+0x120>
180091a4:	f04f 0b04 	mov.w	fp, #4
						z_shell_strlen(cmd) - (i - 2));
180091a8:	4620      	mov	r0, r4
180091aa:	f7ff ff47 	bl	1800903c <z_shell_strlen>
					memmove(cmd, cmd + (i - 1),
180091ae:	f10b 3aff 	add.w	sl, fp, #4294967295
180091b2:	44a2      	add	sl, r4
						z_shell_strlen(cmd) - (i - 2));
180091b4:	1c82      	adds	r2, r0, #2
					memmove(cmd, cmd + (i - 1),
180091b6:	4651      	mov	r1, sl
180091b8:	4620      	mov	r0, r4
180091ba:	eba2 020b 	sub.w	r2, r2, fp
180091be:	f000 ffb0 	bl	1800a122 <memmove>
					*cmd++ = v;
180091c2:	f804 9b01 	strb.w	r9, [r4], #1
					continue;
180091c6:	e78b      	b.n	180090e0 <z_shell_make_argv+0x38>
180091c8:	2303      	movs	r3, #3
180091ca:	e7dc      	b.n	18009186 <z_shell_make_argv+0xde>
					} else if ((t >= 'a') &&
180091cc:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
180091d0:	2905      	cmp	r1, #5
180091d2:	d803      	bhi.n	180091dc <z_shell_make_argv+0x134>
						v = (v << 4) | (t - 'a' + 10);
180091d4:	3a57      	subs	r2, #87	; 0x57
						v = (v << 4) | (t - 'A' + 10);
180091d6:	ea42 1209 	orr.w	r2, r2, r9, lsl #4
180091da:	e7df      	b.n	1800919c <z_shell_make_argv+0xf4>
					} else if ((t >= 'A') && (t <= 'F')) {
180091dc:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
180091e0:	2905      	cmp	r1, #5
180091e2:	d801      	bhi.n	180091e8 <z_shell_make_argv+0x140>
						v = (v << 4) | (t - 'A' + 10);
180091e4:	3a37      	subs	r2, #55	; 0x37
180091e6:	e7f6      	b.n	180091d6 <z_shell_make_argv+0x12e>
				if (i > 2) {
180091e8:	2802      	cmp	r0, #2
180091ea:	d008      	beq.n	180091fe <z_shell_make_argv+0x156>
180091ec:	f04f 0b03 	mov.w	fp, #3
180091f0:	e7da      	b.n	180091a8 <z_shell_make_argv+0x100>
		if (!quote && isspace((int) c)) {
180091f2:	4648      	mov	r0, r9
180091f4:	f7ff ff18 	bl	18009028 <isspace>
180091f8:	2800      	cmp	r0, #0
180091fa:	f47f af5d 	bne.w	180090b8 <z_shell_make_argv+0x10>
		cmd += 1;
180091fe:	3401      	adds	r4, #1
18009200:	e76e      	b.n	180090e0 <z_shell_make_argv+0x38>
		if (quote == c) {
18009202:	45a9      	cmp	r9, r5
18009204:	d088      	beq.n	18009118 <z_shell_make_argv+0x70>
		if (quote && c == '\\') {
18009206:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
1800920a:	d1f8      	bne.n	180091fe <z_shell_make_argv+0x156>
			char t = *(cmd + 1);
1800920c:	7861      	ldrb	r1, [r4, #1]
			if (t == quote) {
1800920e:	428d      	cmp	r5, r1
18009210:	d18c      	bne.n	1800912c <z_shell_make_argv+0x84>
						z_shell_strlen(cmd));
18009212:	4620      	mov	r0, r4
18009214:	f7ff ff12 	bl	1800903c <z_shell_strlen>
				memmove(cmd, cmd + 1,
18009218:	f104 0901 	add.w	r9, r4, #1
						z_shell_strlen(cmd));
1800921c:	4602      	mov	r2, r0
				memmove(cmd, cmd + 1,
1800921e:	4649      	mov	r1, r9
18009220:	4620      	mov	r0, r4
18009222:	f000 ff7e 	bl	1800a122 <memmove>
				cmd += 1;
18009226:	464c      	mov	r4, r9
				continue;
18009228:	e75a      	b.n	180090e0 <z_shell_make_argv+0x38>
}
1800922a:	4628      	mov	r0, r5
1800922c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

18009230 <z_shell_pattern_remove>:
{
18009230:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18009232:	460e      	mov	r6, r1
	char *pattern_addr = strstr(buff, pattern);
18009234:	4611      	mov	r1, r2
{
18009236:	4615      	mov	r5, r2
18009238:	4607      	mov	r7, r0
	char *pattern_addr = strstr(buff, pattern);
1800923a:	f000 feea 	bl	1800a012 <strstr>
1800923e:	4604      	mov	r4, r0
	uint16_t pattern_len = z_shell_strlen(pattern);
18009240:	4628      	mov	r0, r5
18009242:	f7ff fefb 	bl	1800903c <z_shell_strlen>
18009246:	4605      	mov	r5, r0
	if (!pattern_addr) {
18009248:	b1c4      	cbz	r4, 1800927c <z_shell_pattern_remove+0x4c>
	if (pattern_addr > buff) {
1800924a:	42a7      	cmp	r7, r4
1800924c:	d207      	bcs.n	1800925e <z_shell_pattern_remove+0x2e>
		if (*(pattern_addr - 1) == ' ') {
1800924e:	f814 3c01 	ldrb.w	r3, [r4, #-1]
18009252:	2b20      	cmp	r3, #32
			pattern_len++; /* space needs to be removed as well */
18009254:	bf02      	ittt	eq
18009256:	3501      	addeq	r5, #1
18009258:	b2ad      	uxtheq	r5, r5
			pattern_addr--; /* set pointer to space */
1800925a:	f104 34ff 	addeq.w	r4, r4, #4294967295
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
1800925e:	4620      	mov	r0, r4
18009260:	f7ff feec 	bl	1800903c <z_shell_strlen>
	*buff_len -= pattern_len;
18009264:	8833      	ldrh	r3, [r6, #0]
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
18009266:	1b42      	subs	r2, r0, r5
	*buff_len -= pattern_len;
18009268:	1b5b      	subs	r3, r3, r5
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
1800926a:	3201      	adds	r2, #1
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
1800926c:	4620      	mov	r0, r4
	*buff_len -= pattern_len;
1800926e:	8033      	strh	r3, [r6, #0]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
18009270:	1961      	adds	r1, r4, r5
18009272:	b292      	uxth	r2, r2
}
18009274:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
18009278:	f000 bf53 	b.w	1800a122 <memmove>
}
1800927c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

1800927e <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
1800927e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
18009282:	4688      	mov	r8, r1
18009284:	4617      	mov	r7, r2
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
18009286:	4604      	mov	r4, r0
{
18009288:	b086      	sub	sp, #24
	if (parent) {
1800928a:	b128      	cbz	r0, 18009298 <z_shell_find_cmd+0x1a>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
1800928c:	4601      	mov	r1, r0
1800928e:	2214      	movs	r2, #20
18009290:	a801      	add	r0, sp, #4
18009292:	f000 ff5e 	bl	1800a152 <memcpy>
		parent = &parent_cpy;
18009296:	ac01      	add	r4, sp, #4
18009298:	2600      	movs	r6, #0
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
1800929a:	4631      	mov	r1, r6
1800929c:	463a      	mov	r2, r7
1800929e:	4620      	mov	r0, r4
180092a0:	f7fb f874 	bl	1800438c <z_shell_cmd_get>
180092a4:	3601      	adds	r6, #1
180092a6:	4605      	mov	r5, r0
180092a8:	b128      	cbz	r0, 180092b6 <z_shell_find_cmd+0x38>
		if (strcmp(cmd_str, entry->syntax) == 0) {
180092aa:	4640      	mov	r0, r8
180092ac:	6829      	ldr	r1, [r5, #0]
180092ae:	f000 ff0a 	bl	1800a0c6 <strcmp>
180092b2:	2800      	cmp	r0, #0
180092b4:	d1f1      	bne.n	1800929a <z_shell_find_cmd+0x1c>
			return entry;
		}
	}

	return NULL;
}
180092b6:	4628      	mov	r0, r5
180092b8:	b006      	add	sp, #24
180092ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

180092be <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
180092be:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
180092c2:	461c      	mov	r4, r3
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;
180092c4:	2300      	movs	r3, #0
{
180092c6:	460f      	mov	r7, r1
180092c8:	4616      	mov	r6, r2
180092ca:	f8dd 8020 	ldr.w	r8, [sp, #32]
180092ce:	f89d 9024 	ldrb.w	r9, [sp, #36]	; 0x24
	*match_arg = Z_SHELL_CMD_ROOT_LVL;
180092d2:	6023      	str	r3, [r4, #0]

	while (*match_arg < argc) {
180092d4:	6823      	ldr	r3, [r4, #0]

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
				(*match_arg)++;
				continue;
180092d6:	4605      	mov	r5, r0
	while (*match_arg < argc) {
180092d8:	42bb      	cmp	r3, r7
180092da:	d21b      	bcs.n	18009314 <z_shell_get_last_command+0x56>
			if (z_shell_has_wildcard(argv[*match_arg])) {
180092dc:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
180092e0:	f000 fd2c 	bl	18009d3c <z_shell_has_wildcard>
180092e4:	6823      	ldr	r3, [r4, #0]
180092e6:	4682      	mov	sl, r0
180092e8:	b118      	cbz	r0, 180092f2 <z_shell_get_last_command+0x34>
				(*match_arg)++;
180092ea:	3301      	adds	r3, #1
				continue;
180092ec:	4628      	mov	r0, r5
				(*match_arg)++;
180092ee:	6023      	str	r3, [r4, #0]
				continue;
180092f0:	e7f0      	b.n	180092d4 <z_shell_get_last_command+0x16>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
180092f2:	4642      	mov	r2, r8
180092f4:	4628      	mov	r0, r5
180092f6:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
180092fa:	f7ff ffc0 	bl	1800927e <z_shell_find_cmd>
		if (entry) {
180092fe:	b148      	cbz	r0, 18009314 <z_shell_get_last_command+0x56>
			(*match_arg)++;
18009300:	6823      	ldr	r3, [r4, #0]
18009302:	1c5a      	adds	r2, r3, #1
18009304:	6022      	str	r2, [r4, #0]
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
18009306:	f1b9 0f00 	cmp.w	r9, #0
1800930a:	d0e3      	beq.n	180092d4 <z_shell_get_last_command+0x16>
1800930c:	4580      	cmp	r8, r0
1800930e:	d1e1      	bne.n	180092d4 <z_shell_get_last_command+0x16>
			(*match_arg)--;
			return NULL;
18009310:	4655      	mov	r5, sl
			(*match_arg)--;
18009312:	6023      	str	r3, [r4, #0]
		}
	}

	return entry;
}
18009314:	4628      	mov	r0, r5
18009316:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

1800931a <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
1800931a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
1800931e:	4606      	mov	r6, r0
	uint16_t len = z_shell_strlen(str);
18009320:	f7ff fe8c 	bl	1800903c <z_shell_strlen>
18009324:	4605      	mov	r5, r0
	uint16_t shift = 0U;

	if (!str) {
18009326:	bb56      	cbnz	r6, 1800937e <z_shell_spaces_trim+0x64>

				break;
			}
		}
	}
}
18009328:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (shift > 0) {
1800932c:	b14c      	cbz	r4, 18009342 <z_shell_spaces_trim+0x28>
						len - j + 1);
1800932e:	1c6a      	adds	r2, r5, #1
18009330:	b29b      	uxth	r3, r3
					memmove(&str[i + 1],
18009332:	3701      	adds	r7, #1
18009334:	1ad2      	subs	r2, r2, r3
18009336:	19f0      	adds	r0, r6, r7
					len -= shift;
18009338:	1b2d      	subs	r5, r5, r4
					memmove(&str[i + 1],
1800933a:	f000 fef2 	bl	1800a122 <memmove>
					shift = 0U;
1800933e:	464c      	mov	r4, r9
					len -= shift;
18009340:	b2ad      	uxth	r5, r5
	for (uint16_t i = 0; i < len - 1; i++) {
18009342:	f108 0801 	add.w	r8, r8, #1
18009346:	fa1f f388 	uxth.w	r3, r8
1800934a:	1e6a      	subs	r2, r5, #1
1800934c:	4293      	cmp	r3, r2
1800934e:	461f      	mov	r7, r3
18009350:	daea      	bge.n	18009328 <z_shell_spaces_trim+0xe>
		if (isspace((int)str[i])) {
18009352:	5df0      	ldrb	r0, [r6, r7]
18009354:	f7ff fe68 	bl	18009028 <isspace>
18009358:	2800      	cmp	r0, #0
1800935a:	d0f2      	beq.n	18009342 <z_shell_spaces_trim+0x28>
			for (uint16_t j = i + 1; j < len; j++) {
1800935c:	3301      	adds	r3, #1
1800935e:	b29b      	uxth	r3, r3
18009360:	b29a      	uxth	r2, r3
18009362:	4295      	cmp	r5, r2
18009364:	d9ed      	bls.n	18009342 <z_shell_spaces_trim+0x28>
				if (isspace((int)str[j])) {
18009366:	5cf0      	ldrb	r0, [r6, r3]
18009368:	f7ff fe5e 	bl	18009028 <isspace>
1800936c:	18f1      	adds	r1, r6, r3
1800936e:	4681      	mov	r9, r0
18009370:	1c5a      	adds	r2, r3, #1
18009372:	2800      	cmp	r0, #0
18009374:	d0da      	beq.n	1800932c <z_shell_spaces_trim+0x12>
					shift++;
18009376:	3401      	adds	r4, #1
18009378:	4613      	mov	r3, r2
1800937a:	b2a4      	uxth	r4, r4
			for (uint16_t j = i + 1; j < len; j++) {
1800937c:	e7f0      	b.n	18009360 <z_shell_spaces_trim+0x46>
1800937e:	f04f 0800 	mov.w	r8, #0
	uint16_t shift = 0U;
18009382:	4644      	mov	r4, r8
18009384:	e7df      	b.n	18009346 <z_shell_spaces_trim+0x2c>

18009386 <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *shell)
{
18009386:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
18009388:	6884      	ldr	r4, [r0, #8]
{
1800938a:	4605      	mov	r5, r0
	if (buff[0] == '\0') {
1800938c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
18009390:	b953      	cbnz	r3, 180093a8 <z_shell_cmd_trim+0x22>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
18009392:	68ab      	ldr	r3, [r5, #8]
18009394:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
18009396:	87da      	strh	r2, [r3, #62]	; 0x3e
}
18009398:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		*buff_len -= 1U;
1800939a:	3a01      	subs	r2, #1
1800939c:	b292      	uxth	r2, r2
1800939e:	87a2      	strh	r2, [r4, #60]	; 0x3c
		if (*buff_len == 0U) {
180093a0:	b922      	cbnz	r2, 180093ac <z_shell_cmd_trim+0x26>
			buff[0] = '\0';
180093a2:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
			return;
180093a6:	e7f4      	b.n	18009392 <z_shell_cmd_trim+0xc>
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
180093a8:	f104 0642 	add.w	r6, r4, #66	; 0x42
	while (isspace((int) buff[*buff_len - 1U])) {
180093ac:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
180093ae:	18b3      	adds	r3, r6, r2
180093b0:	f813 0c01 	ldrb.w	r0, [r3, #-1]
180093b4:	f7ff fe38 	bl	18009028 <isspace>
180093b8:	4603      	mov	r3, r0
180093ba:	2800      	cmp	r0, #0
180093bc:	d1ed      	bne.n	1800939a <z_shell_cmd_trim+0x14>
	buff[*buff_len] = '\0';
180093be:	54b0      	strb	r0, [r6, r2]
	while (isspace((int) buff[i++])) {
180093c0:	b29f      	uxth	r7, r3
180093c2:	5df0      	ldrb	r0, [r6, r7]
180093c4:	f7ff fe30 	bl	18009028 <isspace>
180093c8:	fa16 f183 	uxtah	r1, r6, r3
180093cc:	3301      	adds	r3, #1
180093ce:	2800      	cmp	r0, #0
180093d0:	d1f6      	bne.n	180093c0 <z_shell_cmd_trim+0x3a>
	if (--i > 0) {
180093d2:	2f00      	cmp	r7, #0
180093d4:	d0dd      	beq.n	18009392 <z_shell_cmd_trim+0xc>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
180093d6:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
180093d8:	4630      	mov	r0, r6
180093da:	3301      	adds	r3, #1
180093dc:	1bda      	subs	r2, r3, r7
180093de:	f000 fea0 	bl	1800a122 <memmove>
		*buff_len = *buff_len - i;
180093e2:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
180093e4:	1bdb      	subs	r3, r3, r7
180093e6:	87a3      	strh	r3, [r4, #60]	; 0x3c
180093e8:	e7d3      	b.n	18009392 <z_shell_cmd_trim+0xc>

180093ea <z_shell_raw_fprintf>:
{
180093ea:	b40e      	push	{r1, r2, r3}
180093ec:	b503      	push	{r0, r1, lr}
180093ee:	aa03      	add	r2, sp, #12
180093f0:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
180093f4:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
180093f6:	f7fa ffb5 	bl	18004364 <z_shell_fprintf_fmt>
}
180093fa:	b002      	add	sp, #8
180093fc:	f85d eb04 	ldr.w	lr, [sp], #4
18009400:	b003      	add	sp, #12
18009402:	4770      	bx	lr

18009404 <full_line_cmd>:
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
18009404:	6882      	ldr	r2, [r0, #8]
{
18009406:	b538      	push	{r3, r4, r5, lr}
18009408:	4604      	mov	r4, r0
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
1800940a:	6810      	ldr	r0, [r2, #0]
1800940c:	8f95      	ldrh	r5, [r2, #60]	; 0x3c
	return str == NULL ? 0U : (uint16_t)strlen(str);
1800940e:	b110      	cbz	r0, 18009416 <full_line_cmd+0x12>
18009410:	f000 fe49 	bl	1800a0a6 <strlen>
18009414:	b280      	uxth	r0, r0
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
18009416:	68a2      	ldr	r2, [r4, #8]
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
18009418:	1943      	adds	r3, r0, r5
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
1800941a:	8d50      	ldrh	r0, [r2, #42]	; 0x2a
1800941c:	fbb3 f2f0 	udiv	r2, r3, r0
18009420:	fb00 3012 	mls	r0, r0, r2, r3
}
18009424:	fab0 f080 	clz	r0, r0
18009428:	0940      	lsrs	r0, r0, #5
1800942a:	bd38      	pop	{r3, r4, r5, pc}

1800942c <z_shell_cursor_in_empty_line>:
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
1800942c:	6882      	ldr	r2, [r0, #8]
{
1800942e:	b538      	push	{r3, r4, r5, lr}
18009430:	4604      	mov	r4, r0
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
18009432:	6810      	ldr	r0, [r2, #0]
18009434:	8fd5      	ldrh	r5, [r2, #62]	; 0x3e
18009436:	b110      	cbz	r0, 1800943e <z_shell_cursor_in_empty_line+0x12>
18009438:	f000 fe35 	bl	1800a0a6 <strlen>
1800943c:	b280      	uxth	r0, r0
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
1800943e:	68a2      	ldr	r2, [r4, #8]
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
18009440:	1943      	adds	r3, r0, r5
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
18009442:	8d50      	ldrh	r0, [r2, #42]	; 0x2a
18009444:	fbb3 f2f0 	udiv	r2, r3, r0
18009448:	fb00 3012 	mls	r0, r0, r2, r3
}
1800944c:	fab0 f080 	clz	r0, r0
18009450:	0940      	lsrs	r0, r0, #5
18009452:	bd38      	pop	{r3, r4, r5, pc}

18009454 <z_shell_op_cond_next_line>:
{
18009454:	b510      	push	{r4, lr}
18009456:	4604      	mov	r4, r0
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
18009458:	f7ff ffe8 	bl	1800942c <z_shell_cursor_in_empty_line>
1800945c:	b120      	cbz	r0, 18009468 <z_shell_op_cond_next_line+0x14>
		z_cursor_next_line_move(shell);
1800945e:	6960      	ldr	r0, [r4, #20]
}
18009460:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_cursor_next_line_move(shell);
18009464:	f7fa bfc4 	b.w	180043f0 <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
18009468:	4620      	mov	r0, r4
1800946a:	f7ff ffcb 	bl	18009404 <full_line_cmd>
1800946e:	2800      	cmp	r0, #0
18009470:	d1f5      	bne.n	1800945e <z_shell_op_cond_next_line+0xa>
}
18009472:	bd10      	pop	{r4, pc}

18009474 <z_shell_op_cursor_position_synchronize>:
{
18009474:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18009476:	4605      	mov	r5, r0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
18009478:	6884      	ldr	r4, [r0, #8]
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
1800947a:	f104 0020 	add.w	r0, r4, #32
1800947e:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
18009480:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
18009482:	f7ff fdfb 	bl	1800907c <z_shell_multiline_data_calc>
	if (full_line_cmd(shell)) {
18009486:	4628      	mov	r0, r5
	last_line = (cons->cur_y == cons->cur_y_end);
18009488:	8ca7      	ldrh	r7, [r4, #36]	; 0x24
1800948a:	8ce6      	ldrh	r6, [r4, #38]	; 0x26
	if (full_line_cmd(shell)) {
1800948c:	f7ff ffba 	bl	18009404 <full_line_cmd>
18009490:	b110      	cbz	r0, 18009498 <z_shell_op_cursor_position_synchronize+0x24>
		z_cursor_next_line_move(shell);
18009492:	6968      	ldr	r0, [r5, #20]
18009494:	f7fa ffac 	bl	180043f0 <z_cursor_next_line_move.isra.0>
	if (last_line) {
18009498:	42b7      	cmp	r7, r6
1800949a:	d107      	bne.n	180094ac <z_shell_op_cursor_position_synchronize+0x38>
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
1800949c:	8c21      	ldrh	r1, [r4, #32]
							       cons->cur_x_end);
1800949e:	8c63      	ldrh	r3, [r4, #34]	; 0x22
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
180094a0:	4628      	mov	r0, r5
180094a2:	1ac9      	subs	r1, r1, r3
}
180094a4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
180094a8:	f7fa bfbe 	b.w	18004428 <z_shell_op_cursor_horiz_move>
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
180094ac:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
180094ae:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
180094b0:	4628      	mov	r0, r5
180094b2:	1ac9      	subs	r1, r1, r3
180094b4:	f7fa ffa2 	bl	180043fc <z_shell_op_cursor_vert_move>
180094b8:	e7f0      	b.n	1800949c <z_shell_op_cursor_position_synchronize+0x28>

180094ba <z_shell_op_cursor_move>:
{
180094ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
180094bc:	4604      	mov	r4, r0
180094be:	460d      	mov	r5, r1
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
180094c0:	6880      	ldr	r0, [r0, #8]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
180094c2:	8fc1      	ldrh	r1, [r0, #62]	; 0x3e
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
180094c4:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
180094c6:	3020      	adds	r0, #32
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
180094c8:	440d      	add	r5, r1
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
180094ca:	f7ff fdd7 	bl	1800907c <z_shell_multiline_data_calc>
						&shell->ctx->vt100_ctx.cons,
180094ce:	68a0      	ldr	r0, [r4, #8]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
180094d0:	b2ad      	uxth	r5, r5
	row_span = z_row_span_with_buffer_offsets_get(
180094d2:	8fc1      	ldrh	r1, [r0, #62]	; 0x3e
180094d4:	462a      	mov	r2, r5
180094d6:	3020      	adds	r0, #32
180094d8:	f7ff fdc5 	bl	18009066 <z_row_span_with_buffer_offsets_get>
180094dc:	4607      	mov	r7, r0
						&shell->ctx->vt100_ctx.cons,
180094de:	68a0      	ldr	r0, [r4, #8]
	col_span = z_column_span_with_buffer_offsets_get(
180094e0:	462a      	mov	r2, r5
180094e2:	8fc1      	ldrh	r1, [r0, #62]	; 0x3e
180094e4:	3020      	adds	r0, #32
180094e6:	f7ff fdaf 	bl	18009048 <z_column_span_with_buffer_offsets_get>
180094ea:	4606      	mov	r6, r0
	z_shell_op_cursor_vert_move(shell, -row_span);
180094ec:	4279      	negs	r1, r7
180094ee:	4620      	mov	r0, r4
180094f0:	f7fa ff84 	bl	180043fc <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, col_span);
180094f4:	4631      	mov	r1, r6
180094f6:	4620      	mov	r0, r4
180094f8:	f7fa ff96 	bl	18004428 <z_shell_op_cursor_horiz_move>
	shell->ctx->cmd_buff_pos = new_pos;
180094fc:	68a3      	ldr	r3, [r4, #8]
180094fe:	87dd      	strh	r5, [r3, #62]	; 0x3e
}
18009500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

18009502 <z_shell_op_cursor_word_move>:
{
18009502:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (val < 0) {
18009506:	1e0c      	subs	r4, r1, #0
{
18009508:	4606      	mov	r6, r0
	if (val < 0) {
1800950a:	da33      	bge.n	18009574 <z_shell_op_cursor_word_move+0x72>
		sign = -1;
1800950c:	f04f 35ff 	mov.w	r5, #4294967295
		val = -val;
18009510:	4264      	negs	r4, r4
18009512:	b224      	sxth	r4, r4
		sign = -1;
18009514:	b2a4      	uxth	r4, r4
18009516:	b2af      	uxth	r7, r5
18009518:	e024      	b.n	18009564 <z_shell_op_cursor_word_move+0x62>
		shift = shift_calc(shell->ctx->cmd_buff,
1800951a:	68b3      	ldr	r3, [r6, #8]
	bool found = false;
1800951c:	2000      	movs	r0, #0
		shift = shift_calc(shell->ctx->cmd_buff,
1800951e:	f8b3 e03e 	ldrh.w	lr, [r3, #62]	; 0x3e
18009522:	f8b3 903c 	ldrh.w	r9, [r3, #60]	; 0x3c
18009526:	f103 0842 	add.w	r8, r3, #66	; 0x42
1800952a:	4673      	mov	r3, lr
		idx = pos + ret * sign;
1800952c:	eba3 010e 	sub.w	r1, r3, lr
18009530:	b209      	sxth	r1, r1
		if (((idx == 0U) && (sign < 0)) ||
18009532:	b90b      	cbnz	r3, 18009538 <z_shell_op_cursor_word_move+0x36>
18009534:	1c6a      	adds	r2, r5, #1
18009536:	d010      	beq.n	1800955a <z_shell_op_cursor_word_move+0x58>
18009538:	4599      	cmp	r9, r3
1800953a:	d101      	bne.n	18009540 <z_shell_op_cursor_word_move+0x3e>
		    ((idx == len) && (sign > 0))) {
1800953c:	2d01      	cmp	r5, #1
1800953e:	d00c      	beq.n	1800955a <z_shell_op_cursor_word_move+0x58>
		if (isalnum((int)str[idx]) != 0) {
18009540:	f818 2003 	ldrb.w	r2, [r8, r3]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
18009544:	f042 0c20 	orr.w	ip, r2, #32
18009548:	f1ac 0c61 	sub.w	ip, ip, #97	; 0x61
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
1800954c:	f1bc 0f19 	cmp.w	ip, #25
18009550:	d90c      	bls.n	1800956c <z_shell_op_cursor_word_move+0x6a>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
18009552:	3a30      	subs	r2, #48	; 0x30
	return (int)(isalpha(chr) || isdigit(chr));
18009554:	2a09      	cmp	r2, #9
18009556:	d909      	bls.n	1800956c <z_shell_op_cursor_word_move+0x6a>
			if (found) {
18009558:	b148      	cbz	r0, 1800956e <z_shell_op_cursor_word_move+0x6c>
		z_shell_op_cursor_move(shell, sign * shift);
1800955a:	4630      	mov	r0, r6
1800955c:	f7ff ffad 	bl	180094ba <z_shell_op_cursor_move>
18009560:	3c01      	subs	r4, #1
18009562:	b2a4      	uxth	r4, r4
	while (val--) {
18009564:	2c00      	cmp	r4, #0
18009566:	d1d8      	bne.n	1800951a <z_shell_op_cursor_word_move+0x18>
}
18009568:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			found = true;
1800956c:	2001      	movs	r0, #1
	while (1) {
1800956e:	443b      	add	r3, r7
18009570:	b29b      	uxth	r3, r3
		idx = pos + ret * sign;
18009572:	e7db      	b.n	1800952c <z_shell_op_cursor_word_move+0x2a>
		sign = 1;
18009574:	2501      	movs	r5, #1
18009576:	e7cd      	b.n	18009514 <z_shell_op_cursor_word_move+0x12>

18009578 <z_shell_op_cursor_home_move>:
	z_shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
18009578:	6883      	ldr	r3, [r0, #8]
1800957a:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
1800957c:	4249      	negs	r1, r1
1800957e:	b209      	sxth	r1, r1
18009580:	f7ff bf9b 	b.w	180094ba <z_shell_op_cursor_move>

18009584 <z_shell_op_cursor_end_move>:
	z_shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
18009584:	6883      	ldr	r3, [r0, #8]
18009586:	8f99      	ldrh	r1, [r3, #60]	; 0x3c
18009588:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
1800958a:	1ac9      	subs	r1, r1, r3
1800958c:	b209      	sxth	r1, r1
1800958e:	f7ff bf94 	b.w	180094ba <z_shell_op_cursor_move>

18009592 <z_shell_op_left_arrow>:
	if (shell->ctx->cmd_buff_pos > 0) {
18009592:	6883      	ldr	r3, [r0, #8]
18009594:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
18009596:	b11b      	cbz	r3, 180095a0 <z_shell_op_left_arrow+0xe>
		z_shell_op_cursor_move(shell, -1);
18009598:	f04f 31ff 	mov.w	r1, #4294967295
1800959c:	f7ff bf8d 	b.w	180094ba <z_shell_op_cursor_move>
}
180095a0:	4770      	bx	lr

180095a2 <z_shell_op_right_arrow>:
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
180095a2:	6883      	ldr	r3, [r0, #8]
180095a4:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
180095a6:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
180095a8:	429a      	cmp	r2, r3
180095aa:	d202      	bcs.n	180095b2 <z_shell_op_right_arrow+0x10>
		z_shell_op_cursor_move(shell, 1);
180095ac:	2101      	movs	r1, #1
180095ae:	f7ff bf84 	b.w	180094ba <z_shell_op_cursor_move>
}
180095b2:	4770      	bx	lr

180095b4 <z_shell_op_delete_from_cursor>:
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
180095b4:	6883      	ldr	r3, [r0, #8]
180095b6:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
180095b8:	879a      	strh	r2, [r3, #60]	; 0x3c
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
180095ba:	4413      	add	r3, r2
180095bc:	2200      	movs	r2, #0
180095be:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
	z_clear_eos(shell);
180095c2:	f7fa bf09 	b.w	180043d8 <z_clear_eos>

180095c6 <z_shell_cmd_line_erase>:
{
180095c6:	b510      	push	{r4, lr}
180095c8:	4604      	mov	r4, r0
	z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
180095ca:	6880      	ldr	r0, [r0, #8]
180095cc:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
180095ce:	8fc1      	ldrh	r1, [r0, #62]	; 0x3e
180095d0:	3020      	adds	r0, #32
180095d2:	f7ff fd53 	bl	1800907c <z_shell_multiline_data_calc>
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
180095d6:	68a3      	ldr	r3, [r4, #8]
	z_shell_op_cursor_horiz_move(shell,
180095d8:	4620      	mov	r0, r4
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
180095da:	8c19      	ldrh	r1, [r3, #32]
	z_shell_op_cursor_horiz_move(shell,
180095dc:	f1c1 0101 	rsb	r1, r1, #1
180095e0:	f7fa ff22 	bl	18004428 <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
180095e4:	68a3      	ldr	r3, [r4, #8]
180095e6:	4620      	mov	r0, r4
180095e8:	8c99      	ldrh	r1, [r3, #36]	; 0x24
180095ea:	3901      	subs	r1, #1
180095ec:	f7fa ff06 	bl	180043fc <z_shell_op_cursor_vert_move>
	z_clear_eos(shell);
180095f0:	4620      	mov	r0, r4
}
180095f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_clear_eos(shell);
180095f6:	f7fa beef 	b.w	180043d8 <z_clear_eos>

180095fa <z_shell_write>:
{
180095fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
180095fe:	4605      	mov	r5, r0
18009600:	460f      	mov	r7, r1
18009602:	4614      	mov	r4, r2
	size_t offset = 0;
18009604:	2600      	movs	r6, #0
{
18009606:	b086      	sub	sp, #24
	while (length) {
18009608:	b914      	cbnz	r4, 18009610 <z_shell_write+0x16>
}
1800960a:	b006      	add	sp, #24
1800960c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		int err = shell->iface->api->write(shell->iface,
18009610:	6868      	ldr	r0, [r5, #4]
18009612:	4622      	mov	r2, r4
18009614:	6803      	ldr	r3, [r0, #0]
18009616:	19b9      	adds	r1, r7, r6
18009618:	f8d3 800c 	ldr.w	r8, [r3, #12]
1800961c:	466b      	mov	r3, sp
1800961e:	47c0      	blx	r8
		offset += tmp_cnt;
18009620:	9a00      	ldr	r2, [sp, #0]
18009622:	4416      	add	r6, r2
		length -= tmp_cnt;
18009624:	1aa4      	subs	r4, r4, r2
		if (tmp_cnt == 0 &&
18009626:	2a00      	cmp	r2, #0
18009628:	d1ee      	bne.n	18009608 <z_shell_write+0xe>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
1800962a:	68ab      	ldr	r3, [r5, #8]
1800962c:	7919      	ldrb	r1, [r3, #4]
		if (tmp_cnt == 0 &&
1800962e:	2903      	cmp	r1, #3
18009630:	d0ea      	beq.n	18009608 <z_shell_write+0xe>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
18009632:	2902      	cmp	r1, #2
18009634:	d813      	bhi.n	1800965e <z_shell_write+0x64>
		k_poll_event_init(&event,
18009636:	2101      	movs	r1, #1
18009638:	f503 7326 	add.w	r3, r3, #664	; 0x298
1800963c:	a801      	add	r0, sp, #4
1800963e:	f001 fce6 	bl	1800b00e <k_poll_event_init>
	return z_impl_k_poll(events, num_events, timeout);
18009642:	f04f 32ff 	mov.w	r2, #4294967295
18009646:	f04f 33ff 	mov.w	r3, #4294967295
1800964a:	2101      	movs	r1, #1
1800964c:	a801      	add	r0, sp, #4
1800964e:	f7fe fb23 	bl	18007c98 <z_impl_k_poll>
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
18009652:	68a8      	ldr	r0, [r5, #8]
18009654:	f500 7026 	add.w	r0, r0, #664	; 0x298
	z_impl_k_poll_signal_reset(sig);
18009658:	f001 fcfb 	bl	1800b052 <z_impl_k_poll_signal_reset>
1800965c:	e7d4      	b.n	18009608 <z_shell_write+0xe>
	return sh->ctx->ctx.flags.tx_rdy == 1;
1800965e:	f8d3 2264 	ldr.w	r2, [r3, #612]	; 0x264
		while (!z_flag_tx_rdy_get(shell)) {
18009662:	0792      	lsls	r2, r2, #30
18009664:	d5fb      	bpl.n	1800965e <z_shell_write+0x64>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
18009666:	f503 7319 	add.w	r3, r3, #612	; 0x264
1800966a:	e8d3 2fef 	ldaex	r2, [r3]
1800966e:	f022 0202 	bic.w	r2, r2, #2
18009672:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009676:	2900      	cmp	r1, #0
18009678:	d0c6      	beq.n	18009608 <z_shell_write+0xe>
1800967a:	e7f6      	b.n	1800966a <z_shell_write+0x70>

1800967c <z_shell_print_stream>:
	z_shell_write((const struct shell *) user_ctx, data, len);
1800967c:	f7ff bfbd 	b.w	180095fa <z_shell_write>

18009680 <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
18009680:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
18009682:	460f      	mov	r7, r1
	return sh->ctx->cfg.flags.use_colors == 1;
18009684:	6881      	ldr	r1, [r0, #8]
18009686:	461e      	mov	r6, r3
18009688:	f8d1 3260 	ldr.w	r3, [r1, #608]	; 0x260
1800968c:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
1800968e:	06db      	lsls	r3, r3, #27
{
18009690:	4615      	mov	r5, r2
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
18009692:	d517      	bpl.n	180096c4 <z_shell_vfprintf+0x44>
	    z_flag_use_colors_get(shell)	  &&
18009694:	f891 302e 	ldrb.w	r3, [r1, #46]	; 0x2e
18009698:	42bb      	cmp	r3, r7
1800969a:	d013      	beq.n	180096c4 <z_shell_vfprintf+0x44>
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *sh,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
1800969c:	2202      	movs	r2, #2
1800969e:	312e      	adds	r1, #46	; 0x2e
180096a0:	a801      	add	r0, sp, #4
180096a2:	f000 fd56 	bl	1800a152 <memcpy>
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(shell, &col);
		z_shell_vt100_color_set(shell, color);
180096a6:	4639      	mov	r1, r7
180096a8:	4620      	mov	r0, r4
180096aa:	f7fa fedb 	bl	18004464 <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
180096ae:	4632      	mov	r2, r6
180096b0:	4629      	mov	r1, r5
180096b2:	6960      	ldr	r0, [r4, #20]
180096b4:	f7fa fe56 	bl	18004364 <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(shell, &col);
180096b8:	4620      	mov	r0, r4
180096ba:	a901      	add	r1, sp, #4
180096bc:	f7fa fef2 	bl	180044a4 <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
	}
}
180096c0:	b003      	add	sp, #12
180096c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
180096c4:	4632      	mov	r2, r6
180096c6:	4629      	mov	r1, r5
180096c8:	6960      	ldr	r0, [r4, #20]
}
180096ca:	b003      	add	sp, #12
180096cc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
180096d0:	f7fa be48 	b.w	18004364 <z_shell_fprintf_fmt>

180096d4 <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *sh,
		     enum shell_vt100_color color,
		     const char *fmt, ...)
{
180096d4:	b40c      	push	{r2, r3}
180096d6:	b507      	push	{r0, r1, r2, lr}
180096d8:	ab04      	add	r3, sp, #16
180096da:	f853 2b04 	ldr.w	r2, [r3], #4
	__ASSERT(z_flag_panic_mode_get(sh) || !k_is_in_isr(),
		 "Thread context required.");

	va_list args;

	va_start(args, fmt);
180096de:	9301      	str	r3, [sp, #4]
	z_shell_vfprintf(sh, color, fmt, args);
180096e0:	f7ff ffce 	bl	18009680 <z_shell_vfprintf>
	va_end(args);
}
180096e4:	b003      	add	sp, #12
180096e6:	f85d eb04 	ldr.w	lr, [sp], #4
180096ea:	b002      	add	sp, #8
180096ec:	4770      	bx	lr

180096ee <data_insert>:
{
180096ee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
180096f2:	6886      	ldr	r6, [r0, #8]
{
180096f4:	4607      	mov	r7, r0
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
180096f6:	8fb5      	ldrh	r5, [r6, #60]	; 0x3c
{
180096f8:	4688      	mov	r8, r1
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
180096fa:	18ab      	adds	r3, r5, r2
180096fc:	2bff      	cmp	r3, #255	; 0xff
{
180096fe:	4614      	mov	r4, r2
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
18009700:	dc1e      	bgt.n	18009740 <data_insert+0x52>
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
18009702:	8ff3      	ldrh	r3, [r6, #62]	; 0x3e
18009704:	1aed      	subs	r5, r5, r3
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
18009706:	3342      	adds	r3, #66	; 0x42
18009708:	441e      	add	r6, r3
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
1800970a:	b2ad      	uxth	r5, r5
	memmove(curr_pos + len, curr_pos, after);
1800970c:	462a      	mov	r2, r5
1800970e:	4631      	mov	r1, r6
18009710:	1930      	adds	r0, r6, r4
18009712:	f000 fd06 	bl	1800a122 <memmove>
	memcpy(curr_pos, data, len);
18009716:	4622      	mov	r2, r4
18009718:	4641      	mov	r1, r8
1800971a:	4630      	mov	r0, r6
1800971c:	f000 fd19 	bl	1800a152 <memcpy>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
18009720:	2200      	movs	r2, #0
	shell->ctx->cmd_buff_len += len;
18009722:	68b9      	ldr	r1, [r7, #8]
18009724:	8f8b      	ldrh	r3, [r1, #60]	; 0x3c
18009726:	4423      	add	r3, r4
18009728:	b29b      	uxth	r3, r3
1800972a:	878b      	strh	r3, [r1, #60]	; 0x3c
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
1800972c:	440b      	add	r3, r1
1800972e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
	return sh->ctx->cfg.flags.echo == 1;
18009732:	f8d1 3260 	ldr.w	r3, [r1, #608]	; 0x260
	if (!z_flag_echo_get(shell)) {
18009736:	079b      	lsls	r3, r3, #30
18009738:	d404      	bmi.n	18009744 <data_insert+0x56>
		shell->ctx->cmd_buff_pos += len;
1800973a:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
1800973c:	4414      	add	r4, r2
1800973e:	87cc      	strh	r4, [r1, #62]	; 0x3e
}
18009740:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	reprint_from_cursor(shell, after, false);
18009744:	4629      	mov	r1, r5
18009746:	4638      	mov	r0, r7
}
18009748:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	reprint_from_cursor(shell, after, false);
1800974c:	f7fa bf24 	b.w	18004598 <reprint_from_cursor>

18009750 <z_shell_op_completion_insert>:
	data_insert(shell, compl, compl_len);
18009750:	f7ff bfcd 	b.w	180096ee <data_insert>

18009754 <z_shell_op_char_delete>:
{
18009754:	b538      	push	{r3, r4, r5, lr}
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
18009756:	6883      	ldr	r3, [r0, #8]
{
18009758:	4605      	mov	r5, r0
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
1800975a:	8f9c      	ldrh	r4, [r3, #60]	; 0x3c
1800975c:	8fd8      	ldrh	r0, [r3, #62]	; 0x3e
1800975e:	1a24      	subs	r4, r4, r0
18009760:	b2a4      	uxth	r4, r4
	if (diff == 0U) {
18009762:	b18c      	cbz	r4, 18009788 <z_shell_op_char_delete+0x34>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
18009764:	3042      	adds	r0, #66	; 0x42
18009766:	4418      	add	r0, r3
	memmove(str, str + 1, diff);
18009768:	4622      	mov	r2, r4
1800976a:	1c41      	adds	r1, r0, #1
1800976c:	f000 fcd9 	bl	1800a122 <memmove>
	--shell->ctx->cmd_buff_len;
18009770:	68aa      	ldr	r2, [r5, #8]
	reprint_from_cursor(shell, --diff, true);
18009772:	1e61      	subs	r1, r4, #1
	--shell->ctx->cmd_buff_len;
18009774:	8f93      	ldrh	r3, [r2, #60]	; 0x3c
	reprint_from_cursor(shell, --diff, true);
18009776:	4628      	mov	r0, r5
	--shell->ctx->cmd_buff_len;
18009778:	3b01      	subs	r3, #1
1800977a:	8793      	strh	r3, [r2, #60]	; 0x3c
	reprint_from_cursor(shell, --diff, true);
1800977c:	b289      	uxth	r1, r1
1800977e:	2201      	movs	r2, #1
}
18009780:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	reprint_from_cursor(shell, --diff, true);
18009784:	f7fa bf08 	b.w	18004598 <reprint_from_cursor>
}
18009788:	bd38      	pop	{r3, r4, r5, pc}

1800978a <z_shell_op_char_backspace>:
	if ((shell->ctx->cmd_buff_len == 0) ||
1800978a:	6883      	ldr	r3, [r0, #8]
{
1800978c:	b510      	push	{r4, lr}
	if ((shell->ctx->cmd_buff_len == 0) ||
1800978e:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
{
18009790:	4604      	mov	r4, r0
	if ((shell->ctx->cmd_buff_len == 0) ||
18009792:	b152      	cbz	r2, 180097aa <z_shell_op_char_backspace+0x20>
18009794:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
18009796:	b143      	cbz	r3, 180097aa <z_shell_op_char_backspace+0x20>
	z_shell_op_cursor_move(shell, -1);
18009798:	f04f 31ff 	mov.w	r1, #4294967295
1800979c:	f7ff fe8d 	bl	180094ba <z_shell_op_cursor_move>
	z_shell_op_char_delete(shell);
180097a0:	4620      	mov	r0, r4
}
180097a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_shell_op_char_delete(shell);
180097a6:	f7ff bfd5 	b.w	18009754 <z_shell_op_char_delete>
}
180097aa:	bd10      	pop	{r4, pc}

180097ac <msg_from_fifo.isra.0>:
{
	z_shell_print_stream(ctx, data, length);
	return length;
}

static struct log_msg *msg_from_fifo(const struct shell_log_backend *backend)
180097ac:	b507      	push	{r0, r1, r2, lr}
	return z_impl_k_msgq_get(msgq, data, timeout);
180097ae:	2200      	movs	r2, #0
180097b0:	2300      	movs	r3, #0
180097b2:	4669      	mov	r1, sp
180097b4:	f7fd fba6 	bl	18006f04 <z_impl_k_msgq_get>
	struct shell_log_backend_msg msg;
	int err;

	err = k_msgq_get(backend->msgq, &msg, K_NO_WAIT);

	return (err == 0) ? msg.msg : NULL;
180097b8:	b918      	cbnz	r0, 180097c2 <msg_from_fifo.isra.0+0x16>
180097ba:	9800      	ldr	r0, [sp, #0]
}
180097bc:	b003      	add	sp, #12
180097be:	f85d fb04 	ldr.w	pc, [sp], #4
	return (err == 0) ? msg.msg : NULL;
180097c2:	2000      	movs	r0, #0
180097c4:	e7fa      	b.n	180097bc <msg_from_fifo.isra.0+0x10>

180097c6 <put>:

	return true;
}

static void put(const struct log_backend *const backend, struct log_msg *msg)
{
180097c6:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
180097ca:	6843      	ldr	r3, [r0, #4]
	bool colors = IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
			z_flag_use_colors_get(shell);
	struct k_poll_signal *signal;

	log_msg_get(msg);
180097cc:	4608      	mov	r0, r1
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
180097ce:	681c      	ldr	r4, [r3, #0]
{
180097d0:	460d      	mov	r5, r1
	return sh->ctx->cfg.flags.use_colors == 1;
180097d2:	68a3      	ldr	r3, [r4, #8]
180097d4:	f8d3 6260 	ldr.w	r6, [r3, #608]	; 0x260
	log_msg_get(msg);
180097d8:	f7ff f89a 	bl	18008910 <log_msg_get>

	switch (shell->log_backend->control_block->state) {
180097dc:	69e3      	ldr	r3, [r4, #28]
180097de:	f3c6 1600 	ubfx	r6, r6, #4, #1
180097e2:	68db      	ldr	r3, [r3, #12]
180097e4:	791b      	ldrb	r3, [r3, #4]
180097e6:	2b01      	cmp	r3, #1
180097e8:	d007      	beq.n	180097fa <put+0x34>
180097ea:	2b03      	cmp	r3, #3
180097ec:	d04b      	beq.n	18009886 <put+0xc0>

	case SHELL_LOG_BACKEND_DISABLED:
		__fallthrough;
	default:
		/* Discard message. */
		log_msg_put(msg);
180097ee:	4628      	mov	r0, r5
	}
}
180097f0:	b004      	add	sp, #16
180097f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		log_msg_put(msg);
180097f6:	f7ff b8b6 	b.w	18008966 <log_msg_put>
	struct shell_log_backend_msg t_msg = {
180097fa:	9500      	str	r5, [sp, #0]
	return z_impl_k_uptime_ticks();
180097fc:	f001 faaa 	bl	1800ad54 <z_impl_k_uptime_ticks>
18009800:	220a      	movs	r2, #10
18009802:	2300      	movs	r3, #0
18009804:	f7f7 fd94 	bl	18001330 <__aeabi_uldivmod>
			return t * ((uint64_t)to_hz / from_hz);
18009808:	260a      	movs	r6, #10
	return (uint32_t)k_uptime_get();
1800980a:	9001      	str	r0, [sp, #4]
		err = k_msgq_put(shell->log_backend->msgq, &t_msg,
1800980c:	69e3      	ldr	r3, [r4, #28]
1800980e:	6858      	ldr	r0, [r3, #4]
18009810:	691b      	ldr	r3, [r3, #16]
18009812:	fba3 2306 	umull	r2, r3, r3, r6
	return z_impl_k_msgq_put(msgq, data, timeout);
18009816:	4669      	mov	r1, sp
18009818:	f7fd fb1c 	bl	18006e54 <z_impl_k_msgq_put>
		switch (err) {
1800981c:	f110 0f23 	cmn.w	r0, #35	; 0x23
18009820:	d00a      	beq.n	18009838 <put+0x72>
18009822:	300b      	adds	r0, #11
18009824:	d008      	beq.n	18009838 <put+0x72>
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
18009826:	68a0      	ldr	r0, [r4, #8]
18009828:	f500 701e 	add.w	r0, r0, #632	; 0x278
	return z_impl_k_poll_signal_raise(sig, result);
1800982c:	2100      	movs	r1, #0
}
1800982e:	b004      	add	sp, #16
18009830:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
18009834:	f7fe ba8c 	b.w	18007d50 <z_impl_k_poll_signal_raise>
	struct k_msgq *msgq = shell->log_backend->msgq;
18009838:	69e3      	ldr	r3, [r4, #28]
1800983a:	685f      	ldr	r7, [r3, #4]
	uint32_t timeout = shell->log_backend->timeout;
1800983c:	f8d3 8010 	ldr.w	r8, [r3, #16]
	return z_impl_k_uptime_ticks();
18009840:	f001 fa88 	bl	1800ad54 <z_impl_k_uptime_ticks>
			return t / ((uint64_t)from_hz / to_hz);
18009844:	220a      	movs	r2, #10
18009846:	2300      	movs	r3, #0
18009848:	f7f7 fd72 	bl	18001330 <__aeabi_uldivmod>
1800984c:	4605      	mov	r5, r0
	return z_impl_k_msgq_peek(msgq, data);
1800984e:	4638      	mov	r0, r7
18009850:	a902      	add	r1, sp, #8
18009852:	f001 f920 	bl	1800aa96 <z_impl_k_msgq_peek>
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
18009856:	2800      	cmp	r0, #0
18009858:	d1d8      	bne.n	1800980c <put+0x46>
1800985a:	9b03      	ldr	r3, [sp, #12]
1800985c:	1aeb      	subs	r3, r5, r3
1800985e:	4598      	cmp	r8, r3
18009860:	d2d4      	bcs.n	1800980c <put+0x46>
	return z_impl_k_msgq_get(msgq, data, timeout);
18009862:	2300      	movs	r3, #0
18009864:	2200      	movs	r2, #0
18009866:	a902      	add	r1, sp, #8
18009868:	4638      	mov	r0, r7
1800986a:	f7fd fb4b 	bl	18006f04 <z_impl_k_msgq_get>
			log_msg_put(msg.msg);
1800986e:	9802      	ldr	r0, [sp, #8]
18009870:	f7ff f879 	bl	18008966 <log_msg_put>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
18009874:	69a3      	ldr	r3, [r4, #24]
18009876:	e8d3 2fef 	ldaex	r2, [r3]
1800987a:	3201      	adds	r2, #1
1800987c:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009880:	2900      	cmp	r1, #0
18009882:	d0e4      	beq.n	1800984e <put+0x88>
18009884:	e7f7      	b.n	18009876 <put+0xb0>
		z_shell_cmd_line_erase(shell);
18009886:	4620      	mov	r0, r4
18009888:	f7ff fe9d 	bl	180095c6 <z_shell_cmd_line_erase>
		msg_process(shell->log_backend->log_output, msg, colors);
1800988c:	69e3      	ldr	r3, [r4, #28]
		flags |= LOG_OUTPUT_FLAG_COLORS;
1800988e:	2e00      	cmp	r6, #0
	log_output_msg_process(log_output, msg, flags);
18009890:	bf0c      	ite	eq
18009892:	220e      	moveq	r2, #14
18009894:	220f      	movne	r2, #15
18009896:	4629      	mov	r1, r5
18009898:	6898      	ldr	r0, [r3, #8]
1800989a:	f7f9 f965 	bl	18002b68 <log_output_msg_process>
	log_msg_put(msg);
1800989e:	e7a6      	b.n	180097ee <put+0x28>

180098a0 <dropped>:
	}
}

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
180098a0:	6843      	ldr	r3, [r0, #4]
180098a2:	681b      	ldr	r3, [r3, #0]
180098a4:	e9d3 3206 	ldrd	r3, r2, [r3, #24]
180098a8:	e8d3 0fef 	ldaex	r0, [r3]
180098ac:	4408      	add	r0, r1
180098ae:	e8c3 0fec 	stlex	ip, r0, [r3]
180098b2:	f1bc 0f00 	cmp.w	ip, #0
180098b6:	d1f7      	bne.n	180098a8 <dropped+0x8>
180098b8:	68d3      	ldr	r3, [r2, #12]
180098ba:	e8d3 2fef 	ldaex	r2, [r3]
180098be:	440a      	add	r2, r1
180098c0:	e8c3 2fe0 	stlex	r0, r2, [r3]
180098c4:	2800      	cmp	r0, #0
180098c6:	d1f8      	bne.n	180098ba <dropped+0x1a>
	const struct shell_log_backend *log_backend = shell->log_backend;

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
180098c8:	4770      	bx	lr

180098ca <z_shell_log_backend_output_func>:
{
180098ca:	4613      	mov	r3, r2
180098cc:	b510      	push	{r4, lr}
180098ce:	460c      	mov	r4, r1
	z_shell_print_stream(ctx, data, length);
180098d0:	460a      	mov	r2, r1
180098d2:	4601      	mov	r1, r0
180098d4:	4618      	mov	r0, r3
180098d6:	f7ff fed1 	bl	1800967c <z_shell_print_stream>
}
180098da:	4620      	mov	r0, r4
180098dc:	bd10      	pop	{r4, pc}

180098de <z_shell_log_backend_enable>:
{
180098de:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
180098e0:	4604      	mov	r4, r0
180098e2:	460e      	mov	r6, r1
180098e4:	4617      	mov	r7, r2
		while ((msg = msg_from_fifo(backend)) != NULL) {
180098e6:	6860      	ldr	r0, [r4, #4]
180098e8:	f7ff ff60 	bl	180097ac <msg_from_fifo.isra.0>
180098ec:	4605      	mov	r5, r0
180098ee:	b960      	cbnz	r0, 1800990a <z_shell_log_backend_enable+0x2c>
		log_backend_enable(backend->backend, ctx, init_log_level);
180098f0:	463a      	mov	r2, r7
180098f2:	4631      	mov	r1, r6
180098f4:	6820      	ldr	r0, [r4, #0]
180098f6:	f7f8 ff55 	bl	180027a4 <log_backend_enable>
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
180098fa:	2201      	movs	r2, #1
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *output,
				      void *ctx)
{
	output->control_block->ctx = ctx;
180098fc:	68a3      	ldr	r3, [r4, #8]
180098fe:	685b      	ldr	r3, [r3, #4]
18009900:	605e      	str	r6, [r3, #4]
		backend->control_block->dropped_cnt = 0;
18009902:	68e3      	ldr	r3, [r4, #12]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
18009904:	711a      	strb	r2, [r3, #4]
		backend->control_block->dropped_cnt = 0;
18009906:	601d      	str	r5, [r3, #0]
}
18009908:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			log_msg_put(msg);
1800990a:	f7ff f82c 	bl	18008966 <log_msg_put>
1800990e:	e7ea      	b.n	180098e6 <z_shell_log_backend_enable+0x8>

18009910 <z_shell_log_backend_disable>:
{
18009910:	b510      	push	{r4, lr}
18009912:	4604      	mov	r4, r0
	log_backend_disable(backend->backend);
18009914:	6800      	ldr	r0, [r0, #0]
18009916:	f7fe ffa0 	bl	1800885a <log_backend_disable>
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
1800991a:	2202      	movs	r2, #2
1800991c:	68e3      	ldr	r3, [r4, #12]
1800991e:	711a      	strb	r2, [r3, #4]
}
18009920:	bd10      	pop	{r4, pc}

18009922 <z_shell_log_backend_process>:
{
18009922:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
18009924:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
18009926:	2200      	movs	r2, #0
			(const struct shell *)backend->backend->cb->ctx;
18009928:	6803      	ldr	r3, [r0, #0]
	const struct shell *shell =
1800992a:	685b      	ldr	r3, [r3, #4]
1800992c:	681e      	ldr	r6, [r3, #0]
1800992e:	68b3      	ldr	r3, [r6, #8]
18009930:	f8d3 5260 	ldr.w	r5, [r3, #608]	; 0x260
18009934:	68c3      	ldr	r3, [r0, #12]
18009936:	f3c5 1500 	ubfx	r5, r5, #4, #1
1800993a:	e8d3 7fef 	ldaex	r7, [r3]
1800993e:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009942:	2900      	cmp	r1, #0
18009944:	d1f9      	bne.n	1800993a <z_shell_log_backend_process+0x18>
	if (dropped) {
18009946:	b19f      	cbz	r7, 18009970 <z_shell_log_backend_process+0x4e>
		if (colors) {
18009948:	b14d      	cbz	r5, 1800995e <z_shell_log_backend_process+0x3c>
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
1800994a:	68b1      	ldr	r1, [r6, #8]
1800994c:	2202      	movs	r2, #2
1800994e:	312e      	adds	r1, #46	; 0x2e
18009950:	a801      	add	r0, sp, #4
18009952:	f000 fbfe 	bl	1800a152 <memcpy>
			z_shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
18009956:	2101      	movs	r1, #1
18009958:	4630      	mov	r0, r6
1800995a:	f7fa fd83 	bl	18004464 <z_shell_vt100_color_set>
		log_output_dropped_process(backend->log_output, dropped);
1800995e:	4639      	mov	r1, r7
18009960:	68a0      	ldr	r0, [r4, #8]
18009962:	f7f9 f97d 	bl	18002c60 <log_output_dropped_process>
		if (colors) {
18009966:	b11d      	cbz	r5, 18009970 <z_shell_log_backend_process+0x4e>
			z_shell_vt100_colors_restore(shell, &col);
18009968:	4630      	mov	r0, r6
1800996a:	a901      	add	r1, sp, #4
1800996c:	f7fa fd9a 	bl	180044a4 <z_shell_vt100_colors_restore>
	struct log_msg *msg = msg_from_fifo(backend);
18009970:	6860      	ldr	r0, [r4, #4]
18009972:	f7ff ff1b 	bl	180097ac <msg_from_fifo.isra.0>
	if (!msg) {
18009976:	4604      	mov	r4, r0
18009978:	b168      	cbz	r0, 18009996 <z_shell_log_backend_process+0x74>
	msg_process(shell->log_backend->log_output, msg, colors);
1800997a:	69f3      	ldr	r3, [r6, #28]
		flags |= LOG_OUTPUT_FLAG_COLORS;
1800997c:	2d00      	cmp	r5, #0
	log_output_msg_process(log_output, msg, flags);
1800997e:	4601      	mov	r1, r0
18009980:	bf08      	it	eq
18009982:	220e      	moveq	r2, #14
18009984:	6898      	ldr	r0, [r3, #8]
18009986:	bf18      	it	ne
18009988:	220f      	movne	r2, #15
1800998a:	f7f9 f8ed 	bl	18002b68 <log_output_msg_process>
	log_msg_put(msg);
1800998e:	4620      	mov	r0, r4
18009990:	f7fe ffe9 	bl	18008966 <log_msg_put>
	return true;
18009994:	2001      	movs	r0, #1
}
18009996:	b003      	add	sp, #12
18009998:	bdf0      	pop	{r4, r5, r6, r7, pc}

1800999a <panic>:
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
1800999a:	6843      	ldr	r3, [r0, #4]
{
1800999c:	b510      	push	{r4, lr}
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
1800999e:	681c      	ldr	r4, [r3, #0]
	err = shell->iface->api->enable(shell->iface, true);
180099a0:	2101      	movs	r1, #1
180099a2:	6860      	ldr	r0, [r4, #4]
180099a4:	6803      	ldr	r3, [r0, #0]
180099a6:	689b      	ldr	r3, [r3, #8]
180099a8:	4798      	blx	r3
	if (err == 0) {
180099aa:	bb28      	cbnz	r0, 180099f8 <panic+0x5e>
		shell->log_backend->control_block->state =
180099ac:	2203      	movs	r2, #3
180099ae:	69e3      	ldr	r3, [r4, #28]
180099b0:	68db      	ldr	r3, [r3, #12]
180099b2:	711a      	strb	r2, [r3, #4]
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
180099b4:	68a3      	ldr	r3, [r4, #8]
180099b6:	f503 7319 	add.w	r3, r3, #612	; 0x264
180099ba:	e8d3 2fef 	ldaex	r2, [r3]
180099be:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
180099c2:	e8c3 2fe1 	stlex	r1, r2, [r3]
180099c6:	2900      	cmp	r1, #0
180099c8:	d1f7      	bne.n	180099ba <panic+0x20>
		z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
180099ca:	68a0      	ldr	r0, [r4, #8]
180099cc:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
180099ce:	8fc1      	ldrh	r1, [r0, #62]	; 0x3e
180099d0:	3020      	adds	r0, #32
180099d2:	f7ff fb53 	bl	1800907c <z_shell_multiline_data_calc>
		z_shell_op_cursor_vert_move(shell, -1);
180099d6:	f04f 31ff 	mov.w	r1, #4294967295
180099da:	4620      	mov	r0, r4
180099dc:	f7fa fd0e 	bl	180043fc <z_shell_op_cursor_vert_move>
					   -shell->ctx->vt100_ctx.cons.cur_x);
180099e0:	68a3      	ldr	r3, [r4, #8]
		z_shell_op_cursor_horiz_move(shell,
180099e2:	4620      	mov	r0, r4
					   -shell->ctx->vt100_ctx.cons.cur_x);
180099e4:	8c19      	ldrh	r1, [r3, #32]
		z_shell_op_cursor_horiz_move(shell,
180099e6:	4249      	negs	r1, r1
180099e8:	f7fa fd1e 	bl	18004428 <z_shell_op_cursor_horiz_move>
			while (z_shell_log_backend_process(
180099ec:	69e0      	ldr	r0, [r4, #28]
180099ee:	f7ff ff98 	bl	18009922 <z_shell_log_backend_process>
180099f2:	2800      	cmp	r0, #0
180099f4:	d1fa      	bne.n	180099ec <panic+0x52>
}
180099f6:	bd10      	pop	{r4, pc}
		z_shell_log_backend_disable(shell->log_backend);
180099f8:	69e0      	ldr	r0, [r4, #28]
}
180099fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_log_backend_disable(shell->log_backend);
180099fe:	f7ff bf87 	b.w	18009910 <z_shell_log_backend_disable>

18009a02 <z_shell_raw_fprintf>:
{
18009a02:	b40e      	push	{r1, r2, r3}
18009a04:	b503      	push	{r0, r1, lr}
18009a06:	aa03      	add	r2, sp, #12
18009a08:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
18009a0c:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
18009a0e:	f7fa fca9 	bl	18004364 <z_shell_fprintf_fmt>
}
18009a12:	b002      	add	sp, #8
18009a14:	f85d eb04 	ldr.w	lr, [sp], #4
18009a18:	b003      	add	sp, #12
18009a1a:	4770      	bx	lr

18009a1c <formatted_text_print.constprop.0>:
static void formatted_text_print(const struct shell *shell, const char *str,
18009a1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
18009a20:	4604      	mov	r4, r0
18009a22:	4690      	mov	r8, r2
	if (str == NULL) {
18009a24:	460e      	mov	r6, r1
18009a26:	2900      	cmp	r1, #0
18009a28:	d069      	beq.n	18009afe <formatted_text_print.constprop.0+0xe2>
18009a2a:	2500      	movs	r5, #0
	while (isspace((int) *(str + offset))) {
18009a2c:	5d73      	ldrb	r3, [r6, r5]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
18009a2e:	2b20      	cmp	r3, #32
18009a30:	d023      	beq.n	18009a7a <formatted_text_print.constprop.0+0x5e>
18009a32:	3b09      	subs	r3, #9
18009a34:	2b04      	cmp	r3, #4
18009a36:	d920      	bls.n	18009a7a <formatted_text_print.constprop.0+0x5e>
18009a38:	4630      	mov	r0, r6
18009a3a:	f000 fb34 	bl	1800a0a6 <strlen>
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
18009a3e:	68a3      	ldr	r3, [r4, #8]
		length = z_shell_strlen(str) - offset;
18009a40:	b280      	uxth	r0, r0
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
18009a42:	8d59      	ldrh	r1, [r3, #42]	; 0x2a
		length = z_shell_strlen(str) - offset;
18009a44:	1b40      	subs	r0, r0, r5
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
18009a46:	eba1 0308 	sub.w	r3, r1, r8
		if (length <=
18009a4a:	4298      	cmp	r0, r3
18009a4c:	eb06 0905 	add.w	r9, r6, r5
18009a50:	d915      	bls.n	18009a7e <formatted_text_print.constprop.0+0x62>
18009a52:	4648      	mov	r0, r9
		size_t idx = 0;
18009a54:	2700      	movs	r7, #0
			if (isspace((int) (*(str + offset + idx)))) {
18009a56:	f810 2b01 	ldrb.w	r2, [r0], #1
18009a5a:	2a20      	cmp	r2, #32
18009a5c:	d006      	beq.n	18009a6c <formatted_text_print.constprop.0+0x50>
18009a5e:	f1a2 0c09 	sub.w	ip, r2, #9
18009a62:	f1bc 0f04 	cmp.w	ip, #4
18009a66:	d802      	bhi.n	18009a6e <formatted_text_print.constprop.0+0x52>
				if (*(str + offset + idx) == '\n') {
18009a68:	2a0a      	cmp	r2, #10
18009a6a:	d02f      	beq.n	18009acc <formatted_text_print.constprop.0+0xb0>
18009a6c:	463b      	mov	r3, r7
			if ((idx + terminal_offset) >=
18009a6e:	eb08 0207 	add.w	r2, r8, r7
18009a72:	4291      	cmp	r1, r2
18009a74:	d929      	bls.n	18009aca <formatted_text_print.constprop.0+0xae>
			++idx;
18009a76:	3701      	adds	r7, #1
			if (isspace((int) (*(str + offset + idx)))) {
18009a78:	e7ed      	b.n	18009a56 <formatted_text_print.constprop.0+0x3a>
		++offset;
18009a7a:	3501      	adds	r5, #1
18009a7c:	e7d6      	b.n	18009a2c <formatted_text_print.constprop.0+0x10>
18009a7e:	464b      	mov	r3, r9
			for (idx = 0; idx < length; idx++) {
18009a80:	2700      	movs	r7, #0
18009a82:	42b8      	cmp	r0, r7
18009a84:	d016      	beq.n	18009ab4 <formatted_text_print.constprop.0+0x98>
				if (*(str + offset + idx) == '\n') {
18009a86:	f813 2b01 	ldrb.w	r2, [r3], #1
18009a8a:	eb05 0a07 	add.w	sl, r5, r7
18009a8e:	2a0a      	cmp	r2, #10
18009a90:	d119      	bne.n	18009ac6 <formatted_text_print.constprop.0+0xaa>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
18009a92:	6960      	ldr	r0, [r4, #20]
18009a94:	f7ff faa0 	bl	18008fd8 <z_shell_fprintf_buffer_flush>
					z_shell_write(shell, str + offset, idx);
18009a98:	4649      	mov	r1, r9
18009a9a:	463a      	mov	r2, r7
18009a9c:	4620      	mov	r0, r4
18009a9e:	f7ff fdac 	bl	180095fa <z_shell_write>
					z_cursor_next_line_move(shell);
18009aa2:	6960      	ldr	r0, [r4, #20]
18009aa4:	f7fa fe00 	bl	180046a8 <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(shell,
18009aa8:	4641      	mov	r1, r8
18009aaa:	4620      	mov	r0, r4
					offset += idx + 1;
18009aac:	f10a 0501 	add.w	r5, sl, #1
					z_shell_op_cursor_horiz_move(shell,
18009ab0:	f7fa fcba 	bl	18004428 <z_shell_op_cursor_horiz_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, str + offset);
18009ab4:	6960      	ldr	r0, [r4, #20]
18009ab6:	1971      	adds	r1, r6, r5
18009ab8:	f7ff ffa3 	bl	18009a02 <z_shell_raw_fprintf>
	z_cursor_next_line_move(shell);
18009abc:	6960      	ldr	r0, [r4, #20]
}
18009abe:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_cursor_next_line_move(shell);
18009ac2:	f7fa bdf1 	b.w	180046a8 <z_cursor_next_line_move.isra.0>
			for (idx = 0; idx < length; idx++) {
18009ac6:	3701      	adds	r7, #1
18009ac8:	e7db      	b.n	18009a82 <formatted_text_print.constprop.0+0x66>
18009aca:	461f      	mov	r7, r3
18009acc:	6960      	ldr	r0, [r4, #20]
18009ace:	f7ff fa83 	bl	18008fd8 <z_shell_fprintf_buffer_flush>
		z_shell_write(shell, str + offset, length);
18009ad2:	463a      	mov	r2, r7
18009ad4:	4649      	mov	r1, r9
18009ad6:	4620      	mov	r0, r4
18009ad8:	f7ff fd8f 	bl	180095fa <z_shell_write>
		offset += length;
18009adc:	443d      	add	r5, r7
		while (isspace((int) (*(str + offset)))) {
18009ade:	5d73      	ldrb	r3, [r6, r5]
18009ae0:	2b20      	cmp	r3, #32
18009ae2:	d00a      	beq.n	18009afa <formatted_text_print.constprop.0+0xde>
18009ae4:	3b09      	subs	r3, #9
18009ae6:	2b04      	cmp	r3, #4
18009ae8:	d907      	bls.n	18009afa <formatted_text_print.constprop.0+0xde>
		z_cursor_next_line_move(shell);
18009aea:	6960      	ldr	r0, [r4, #20]
18009aec:	f7fa fddc 	bl	180046a8 <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
18009af0:	4641      	mov	r1, r8
18009af2:	4620      	mov	r0, r4
18009af4:	f7fa fc98 	bl	18004428 <z_shell_op_cursor_horiz_move>
	while (true) {
18009af8:	e79e      	b.n	18009a38 <formatted_text_print.constprop.0+0x1c>
			++offset;
18009afa:	3501      	adds	r5, #1
18009afc:	e7ef      	b.n	18009ade <formatted_text_print.constprop.0+0xc2>
}
18009afe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

18009b02 <cmd_shell_stats_reset>:
	shell->stats->log_lost_cnt = 0;
18009b02:	6983      	ldr	r3, [r0, #24]
18009b04:	2000      	movs	r0, #0
18009b06:	6018      	str	r0, [r3, #0]
}
18009b08:	4770      	bx	lr

18009b0a <z_shell_raw_fprintf>:
{
18009b0a:	b40e      	push	{r1, r2, r3}
18009b0c:	b503      	push	{r0, r1, lr}
18009b0e:	aa03      	add	r2, sp, #12
18009b10:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
18009b14:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
18009b16:	f7fa fc25 	bl	18004364 <z_shell_fprintf_fmt>
}
18009b1a:	b002      	add	sp, #8
18009b1c:	f85d eb04 	ldr.w	lr, [sp], #4
18009b20:	b003      	add	sp, #12
18009b22:	4770      	bx	lr

18009b24 <cmd_bacskpace_mode_backspace>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
18009b24:	6883      	ldr	r3, [r0, #8]
18009b26:	f503 7318 	add.w	r3, r3, #608	; 0x260
18009b2a:	e8d3 2fef 	ldaex	r2, [r3]
18009b2e:	f022 0208 	bic.w	r2, r2, #8
18009b32:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009b36:	2900      	cmp	r1, #0
18009b38:	d1f7      	bne.n	18009b2a <cmd_bacskpace_mode_backspace+0x6>
}
18009b3a:	2000      	movs	r0, #0
18009b3c:	4770      	bx	lr

18009b3e <cmd_bacskpace_mode_delete>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
18009b3e:	6883      	ldr	r3, [r0, #8]
18009b40:	f503 7318 	add.w	r3, r3, #608	; 0x260
18009b44:	e8d3 2fef 	ldaex	r2, [r3]
18009b48:	f042 0208 	orr.w	r2, r2, #8
18009b4c:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009b50:	2900      	cmp	r1, #0
18009b52:	d1f7      	bne.n	18009b44 <cmd_bacskpace_mode_delete+0x6>
}
18009b54:	2000      	movs	r0, #0
18009b56:	4770      	bx	lr

18009b58 <cmd_echo_off>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
18009b58:	6883      	ldr	r3, [r0, #8]
18009b5a:	f503 7318 	add.w	r3, r3, #608	; 0x260
18009b5e:	e8d3 2fef 	ldaex	r2, [r3]
18009b62:	f022 0202 	bic.w	r2, r2, #2
18009b66:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009b6a:	2900      	cmp	r1, #0
18009b6c:	d1f7      	bne.n	18009b5e <cmd_echo_off+0x6>
}
18009b6e:	2000      	movs	r0, #0
18009b70:	4770      	bx	lr

18009b72 <cmd_colors_off>:
18009b72:	6883      	ldr	r3, [r0, #8]
18009b74:	f503 7318 	add.w	r3, r3, #608	; 0x260
18009b78:	e8d3 2fef 	ldaex	r2, [r3]
18009b7c:	f022 0210 	bic.w	r2, r2, #16
18009b80:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009b84:	2900      	cmp	r1, #0
18009b86:	d1f7      	bne.n	18009b78 <cmd_colors_off+0x6>
}
18009b88:	2000      	movs	r0, #0
18009b8a:	4770      	bx	lr

18009b8c <cmd_colors_on>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
18009b8c:	6883      	ldr	r3, [r0, #8]
18009b8e:	f503 7318 	add.w	r3, r3, #608	; 0x260
18009b92:	e8d3 2fef 	ldaex	r2, [r3]
18009b96:	f042 0210 	orr.w	r2, r2, #16
18009b9a:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009b9e:	2900      	cmp	r1, #0
18009ba0:	d1f7      	bne.n	18009b92 <cmd_colors_on+0x6>
}
18009ba2:	2000      	movs	r0, #0
18009ba4:	4770      	bx	lr

18009ba6 <cmd_echo_on>:
18009ba6:	6883      	ldr	r3, [r0, #8]
18009ba8:	f503 7318 	add.w	r3, r3, #608	; 0x260
18009bac:	e8d3 2fef 	ldaex	r2, [r3]
18009bb0:	f042 0202 	orr.w	r2, r2, #2
18009bb4:	e8c3 2fe1 	stlex	r1, r2, [r3]
18009bb8:	2900      	cmp	r1, #0
18009bba:	d1f7      	bne.n	18009bac <cmd_echo_on+0x6>
}
18009bbc:	2000      	movs	r0, #0
18009bbe:	4770      	bx	lr

18009bc0 <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
18009bc0:	b508      	push	{r3, lr}
	return sys_dlist_is_empty(list) ? NULL : list->tail;
18009bc2:	6883      	ldr	r3, [r0, #8]

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get_finish(history->ring_buf, total_len);
18009bc4:	6800      	ldr	r0, [r0, #0]
	sys_dnode_t *const next = node->next;
18009bc6:	e9d3 2100 	ldrd	r2, r1, [r3]
	prev->next = next;
18009bca:	600a      	str	r2, [r1, #0]
	next->prev = prev;
18009bcc:	6051      	str	r1, [r2, #4]
	node->next = NULL;
18009bce:	2200      	movs	r2, #0
			h_item->len + h_item->padding;
18009bd0:	8919      	ldrh	r1, [r3, #8]
	node->prev = NULL;
18009bd2:	e9c3 2200 	strd	r2, r2, [r3]
18009bd6:	895b      	ldrh	r3, [r3, #10]
18009bd8:	4419      	add	r1, r3
	ring_buf_get_finish(history->ring_buf, total_len);
18009bda:	310c      	adds	r1, #12
18009bdc:	f7fe fc2c 	bl	18008438 <ring_buf_get_finish>

	return true;
}
18009be0:	2001      	movs	r0, #1
18009be2:	bd08      	pop	{r3, pc}

18009be4 <z_shell_history_mode_exit>:
	history->current = NULL;
18009be4:	2300      	movs	r3, #0
18009be6:	60c3      	str	r3, [r0, #12]
}
18009be8:	4770      	bx	lr

18009bea <z_shell_history_get>:
{
18009bea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
18009bec:	461f      	mov	r7, r3
	return list->head == list;
18009bee:	4603      	mov	r3, r0
18009bf0:	f853 4f04 	ldr.w	r4, [r3, #4]!
18009bf4:	4616      	mov	r6, r2
	if (sys_dlist_is_empty(&history->list)) {
18009bf6:	429c      	cmp	r4, r3
18009bf8:	d102      	bne.n	18009c00 <z_shell_history_get+0x16>
		*len = 0U;
18009bfa:	2000      	movs	r0, #0
18009bfc:	8038      	strh	r0, [r7, #0]
}
18009bfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (history->current == NULL) {
18009c00:	68c5      	ldr	r5, [r0, #12]
	if (!up) { /* button down */
18009c02:	b9b1      	cbnz	r1, 18009c32 <z_shell_history_get+0x48>
		if (history->current == NULL) {
18009c04:	2d00      	cmp	r5, #0
18009c06:	d0f8      	beq.n	18009bfa <z_shell_history_get+0x10>
	return (node == list->head) ? NULL : node->prev;
18009c08:	42ac      	cmp	r4, r5
18009c0a:	d102      	bne.n	18009c12 <z_shell_history_get+0x28>
	history->current = l_item;
18009c0c:	2300      	movs	r3, #0
18009c0e:	60c3      	str	r3, [r0, #12]
	if (l_item) {
18009c10:	e7f3      	b.n	18009bfa <z_shell_history_get+0x10>
18009c12:	686c      	ldr	r4, [r5, #4]
	history->current = l_item;
18009c14:	60c4      	str	r4, [r0, #12]
	if (l_item) {
18009c16:	2c00      	cmp	r4, #0
18009c18:	d0ef      	beq.n	18009bfa <z_shell_history_get+0x10>
		memcpy(dst, h_item->data, h_item->len);
18009c1a:	8922      	ldrh	r2, [r4, #8]
18009c1c:	4630      	mov	r0, r6
18009c1e:	f104 010c 	add.w	r1, r4, #12
18009c22:	f000 fa96 	bl	1800a152 <memcpy>
		dst[*len] = '\0';
18009c26:	2200      	movs	r2, #0
		*len = h_item->len;
18009c28:	8923      	ldrh	r3, [r4, #8]
		return true;
18009c2a:	2001      	movs	r0, #1
		*len = h_item->len;
18009c2c:	803b      	strh	r3, [r7, #0]
		dst[*len] = '\0';
18009c2e:	54f2      	strb	r2, [r6, r3]
		return true;
18009c30:	e7e5      	b.n	18009bfe <z_shell_history_get+0x14>
		sys_dlist_peek_head_not_empty(&history->list) :
18009c32:	2d00      	cmp	r5, #0
18009c34:	d0ee      	beq.n	18009c14 <z_shell_history_get+0x2a>
	return (node == list->tail) ? NULL : node->next;
18009c36:	6883      	ldr	r3, [r0, #8]
18009c38:	42ab      	cmp	r3, r5
18009c3a:	d0e7      	beq.n	18009c0c <z_shell_history_get+0x22>
18009c3c:	682c      	ldr	r4, [r5, #0]
18009c3e:	e7e9      	b.n	18009c14 <z_shell_history_get+0x2a>

18009c40 <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
18009c40:	b538      	push	{r3, r4, r5, lr}
18009c42:	4604      	mov	r4, r0
	if (sys_dlist_is_empty(&history->list)) {
18009c44:	1d05      	adds	r5, r0, #4
18009c46:	6863      	ldr	r3, [r4, #4]
18009c48:	42ab      	cmp	r3, r5
18009c4a:	d004      	beq.n	18009c56 <z_shell_history_purge+0x16>
18009c4c:	4620      	mov	r0, r4
18009c4e:	f7ff ffb7 	bl	18009bc0 <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
18009c52:	2800      	cmp	r0, #0
18009c54:	d1f7      	bne.n	18009c46 <z_shell_history_purge+0x6>
	}
}
18009c56:	bd38      	pop	{r3, r4, r5, pc}

18009c58 <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
18009c58:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 *
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	return buf->size;
18009c5c:	6803      	ldr	r3, [r0, #0]
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
18009c5e:	f102 050c 	add.w	r5, r2, #12
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
18009c62:	f1c5 0800 	rsb	r8, r5, #0

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
18009c66:	691b      	ldr	r3, [r3, #16]
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
18009c68:	f008 0803 	and.w	r8, r8, #3
	total_len += padding;
18009c6c:	4445      	add	r5, r8
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
18009c6e:	429d      	cmp	r5, r3
{
18009c70:	4604      	mov	r4, r0
18009c72:	468a      	mov	sl, r1
18009c74:	4617      	mov	r7, r2
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
18009c76:	d841      	bhi.n	18009cfc <z_shell_history_put+0xa4>
	history->current = NULL;
18009c78:	2300      	movs	r3, #0
18009c7a:	60c3      	str	r3, [r0, #12]
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
18009c7c:	2a00      	cmp	r2, #0
18009c7e:	d03d      	beq.n	18009cfc <z_shell_history_put+0xa4>
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
18009c80:	f100 0904 	add.w	r9, r0, #4
	return list->head == list;
18009c84:	6840      	ldr	r0, [r0, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
18009c86:	4581      	cmp	r9, r0
18009c88:	d12d      	bne.n	18009ce6 <z_shell_history_put+0x8e>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
18009c8a:	9301      	str	r3, [sp, #4]
			add_to_head(history, h_item, line, len, padding);
			ring_buf_put_finish(history->ring_buf, claim_len);
			break;
		}

		ring_buf_put_finish(history->ring_buf, 0);
18009c8c:	f04f 0b00 	mov.w	fp, #0
		claim_len = ring_buf_put_claim(history->ring_buf,
18009c90:	462a      	mov	r2, r5
18009c92:	6820      	ldr	r0, [r4, #0]
18009c94:	a901      	add	r1, sp, #4
18009c96:	f7fe fb4e 	bl	18008336 <ring_buf_put_claim>
		if (claim_len < total_len) {
18009c9a:	4285      	cmp	r5, r0
		claim_len = ring_buf_put_claim(history->ring_buf,
18009c9c:	4606      	mov	r6, r0
		if (claim_len < total_len) {
18009c9e:	d930      	bls.n	18009d02 <z_shell_history_put+0xaa>
				ring_buf_put_claim(history->ring_buf,
18009ca0:	462a      	mov	r2, r5
18009ca2:	6820      	ldr	r0, [r4, #0]
18009ca4:	a901      	add	r1, sp, #4
18009ca6:	f7fe fb46 	bl	18008336 <ring_buf_put_claim>
			if (claim2_len == total_len) {
18009caa:	4285      	cmp	r5, r0
18009cac:	d12a      	bne.n	18009d04 <z_shell_history_put+0xac>
				ring_buf_put_finish(history->ring_buf,
18009cae:	4631      	mov	r1, r6
18009cb0:	6820      	ldr	r0, [r4, #0]
				padding += claim_len;
18009cb2:	44b0      	add	r8, r6
				ring_buf_put_finish(history->ring_buf,
18009cb4:	f7fe fb5b 	bl	1800836e <ring_buf_put_finish>
				padding += claim_len;
18009cb8:	462e      	mov	r6, r5
18009cba:	fa1f f888 	uxth.w	r8, r8
			add_to_head(history, h_item, line, len, padding);
18009cbe:	9d01      	ldr	r5, [sp, #4]
	memcpy(item->data, src, len);
18009cc0:	4651      	mov	r1, sl
18009cc2:	463a      	mov	r2, r7
	item->len = len;
18009cc4:	812f      	strh	r7, [r5, #8]
	item->padding = padding;
18009cc6:	f8a5 800a 	strh.w	r8, [r5, #10]
	memcpy(item->data, src, len);
18009cca:	f105 000c 	add.w	r0, r5, #12
18009cce:	f000 fa40 	bl	1800a152 <memcpy>
	sys_dnode_t *const head = list->head;
18009cd2:	6863      	ldr	r3, [r4, #4]
			ring_buf_put_finish(history->ring_buf, claim_len);
18009cd4:	4631      	mov	r1, r6
	node->prev = list;
18009cd6:	e9c5 3900 	strd	r3, r9, [r5]
18009cda:	6820      	ldr	r0, [r4, #0]
	head->prev = node;
18009cdc:	605d      	str	r5, [r3, #4]
	list->head = node;
18009cde:	6065      	str	r5, [r4, #4]
18009ce0:	f7fe fb45 	bl	1800836e <ring_buf_put_finish>
			break;
18009ce4:	e00a      	b.n	18009cfc <z_shell_history_put+0xa4>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
18009ce6:	9001      	str	r0, [sp, #4]
	if (l_item &&
18009ce8:	2800      	cmp	r0, #0
18009cea:	d0cf      	beq.n	18009c8c <z_shell_history_put+0x34>
	   (h_item->len == len) &&
18009cec:	8903      	ldrh	r3, [r0, #8]
	if (l_item &&
18009cee:	4293      	cmp	r3, r2
18009cf0:	d1cc      	bne.n	18009c8c <z_shell_history_put+0x34>
	   (memcmp(h_item->data, line, len) == 0)) {
18009cf2:	300c      	adds	r0, #12
18009cf4:	f000 fa04 	bl	1800a100 <memcmp>
	   (h_item->len == len) &&
18009cf8:	2800      	cmp	r0, #0
18009cfa:	d1c7      	bne.n	18009c8c <z_shell_history_put+0x34>
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
		}
	} while (1);
}
18009cfc:	b003      	add	sp, #12
18009cfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (claim_len == total_len) {
18009d02:	d0dc      	beq.n	18009cbe <z_shell_history_put+0x66>
		ring_buf_put_finish(history->ring_buf, 0);
18009d04:	2100      	movs	r1, #0
18009d06:	6820      	ldr	r0, [r4, #0]
18009d08:	f7fe fb31 	bl	1800836e <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
18009d0c:	6863      	ldr	r3, [r4, #4]
18009d0e:	4599      	cmp	r9, r3
18009d10:	d108      	bne.n	18009d24 <z_shell_history_put+0xcc>
	memset(&buf->misc, 0, sizeof(buf->misc));
18009d12:	2208      	movs	r2, #8
			ring_buf_reset(history->ring_buf);
18009d14:	6820      	ldr	r0, [r4, #0]
18009d16:	2100      	movs	r1, #0
	buf->tail = 0;
18009d18:	e9c0 bb00 	strd	fp, fp, [r0]
	memset(&buf->misc, 0, sizeof(buf->misc));
18009d1c:	4410      	add	r0, r2
18009d1e:	f000 fa23 	bl	1800a168 <memset>
}
18009d22:	e7b5      	b.n	18009c90 <z_shell_history_put+0x38>
18009d24:	4620      	mov	r0, r4
18009d26:	f7ff ff4b 	bl	18009bc0 <remove_from_tail.part.0>
		if (remove_from_tail(history) == false) {
18009d2a:	2800      	cmp	r0, #0
18009d2c:	d1b0      	bne.n	18009c90 <z_shell_history_put+0x38>
18009d2e:	e7f0      	b.n	18009d12 <z_shell_history_put+0xba>

18009d30 <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
18009d30:	1d03      	adds	r3, r0, #4
	list->tail = (sys_dnode_t *)list;
18009d32:	e9c0 3301 	strd	r3, r3, [r0, #4]
	history->current = NULL;
18009d36:	2300      	movs	r3, #0
18009d38:	60c3      	str	r3, [r0, #12]
}
18009d3a:	4770      	bx	lr

18009d3c <z_shell_has_wildcard>:
{
18009d3c:	b510      	push	{r4, lr}
	return str == NULL ? 0U : (uint16_t)strlen(str);
18009d3e:	4604      	mov	r4, r0
18009d40:	b908      	cbnz	r0, 18009d46 <z_shell_has_wildcard+0xa>
	return false;
18009d42:	2000      	movs	r0, #0
}
18009d44:	bd10      	pop	{r4, pc}
18009d46:	f000 f9ae 	bl	1800a0a6 <strlen>
	for (size_t i = 0; i < str_len; i++) {
18009d4a:	2300      	movs	r3, #0
18009d4c:	b280      	uxth	r0, r0
18009d4e:	4283      	cmp	r3, r0
18009d50:	d2f7      	bcs.n	18009d42 <z_shell_has_wildcard+0x6>
		if ((str[i] == '?') || (str[i] == '*')) {
18009d52:	5ce2      	ldrb	r2, [r4, r3]
18009d54:	2a3f      	cmp	r2, #63	; 0x3f
18009d56:	d003      	beq.n	18009d60 <z_shell_has_wildcard+0x24>
18009d58:	2a2a      	cmp	r2, #42	; 0x2a
18009d5a:	d001      	beq.n	18009d60 <z_shell_has_wildcard+0x24>
	for (size_t i = 0; i < str_len; i++) {
18009d5c:	3301      	adds	r3, #1
18009d5e:	e7f6      	b.n	18009d4e <z_shell_has_wildcard+0x12>
			return true;
18009d60:	2001      	movs	r0, #1
18009d62:	e7ef      	b.n	18009d44 <z_shell_has_wildcard+0x8>

18009d64 <z_shell_wildcard_prepare>:
{
18009d64:	b510      	push	{r4, lr}
18009d66:	4604      	mov	r4, r0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
18009d68:	6880      	ldr	r0, [r0, #8]
18009d6a:	f44f 7280 	mov.w	r2, #256	; 0x100
18009d6e:	2100      	movs	r1, #0
18009d70:	f500 70a1 	add.w	r0, r0, #322	; 0x142
18009d74:	f000 f9f8 	bl	1800a168 <memset>
	memcpy(shell->ctx->temp_buff,
18009d78:	68a0      	ldr	r0, [r4, #8]
18009d7a:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
18009d7c:	f100 0142 	add.w	r1, r0, #66	; 0x42
18009d80:	f500 70a1 	add.w	r0, r0, #322	; 0x142
18009d84:	f000 f9e5 	bl	1800a152 <memcpy>
	z_shell_spaces_trim(shell->ctx->temp_buff);
18009d88:	68a0      	ldr	r0, [r4, #8]
18009d8a:	f500 70a1 	add.w	r0, r0, #322	; 0x142
18009d8e:	f7ff fac4 	bl	1800931a <z_shell_spaces_trim>
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
18009d92:	68a3      	ldr	r3, [r4, #8]
18009d94:	f513 70a1 	adds.w	r0, r3, #322	; 0x142
18009d98:	d007      	beq.n	18009daa <z_shell_wildcard_prepare+0x46>
18009d9a:	f000 f984 	bl	1800a0a6 <strlen>
18009d9e:	b283      	uxth	r3, r0
18009da0:	68a2      	ldr	r2, [r4, #8]
18009da2:	3301      	adds	r3, #1
18009da4:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
}
18009da8:	bd10      	pop	{r4, pc}
18009daa:	4603      	mov	r3, r0
18009dac:	e7f8      	b.n	18009da0 <z_shell_wildcard_prepare+0x3c>

18009dae <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *shell)
{
18009dae:	b510      	push	{r4, lr}
18009db0:	4604      	mov	r4, r0
	memcpy(shell->ctx->cmd_buff,
18009db2:	6880      	ldr	r0, [r0, #8]
18009db4:	f8b0 2040 	ldrh.w	r2, [r0, #64]	; 0x40
18009db8:	f500 71a1 	add.w	r1, r0, #322	; 0x142
18009dbc:	3042      	adds	r0, #66	; 0x42
18009dbe:	f000 f9c8 	bl	1800a152 <memcpy>
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
18009dc2:	68a3      	ldr	r3, [r4, #8]
18009dc4:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
18009dc8:	879a      	strh	r2, [r3, #60]	; 0x3c
}
18009dca:	bd10      	pop	{r4, pc}

18009dcc <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
18009dcc:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
18009dce:	6800      	ldr	r0, [r0, #0]
18009dd0:	f7fa bed6 	b.w	18004b80 <z_arm_fatal_error>

18009dd4 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
18009dd4:	2100      	movs	r1, #0
18009dd6:	2001      	movs	r0, #1
18009dd8:	f7fa bed2 	b.w	18004b80 <z_arm_fatal_error>

18009ddc <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
18009ddc:	b508      	push	{r3, lr}
	handler();
18009dde:	f7fa ff39 	bl	18004c54 <z_SysNmiOnReset>
	z_arm_int_exit();
}
18009de2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
18009de6:	f7fa bffd 	b.w	18004de4 <z_arm_exc_exit>

18009dea <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
18009dea:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
18009dee:	f383 880b 	msr	PSPLIM, r3
}
18009df2:	4770      	bx	lr

18009df4 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
18009df4:	e840 f300 	tt	r3, r0
int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
		return addr_info.flags.mpu_region;
18009df8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
18009dfc:	b2d8      	uxtb	r0, r3
	}

	return -EINVAL;
}
18009dfe:	bf08      	it	eq
18009e00:	f06f 0015 	mvneq.w	r0, #21
18009e04:	4770      	bx	lr

18009e06 <mpu_configure_region>:
{
18009e06:	b530      	push	{r4, r5, lr}
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
18009e08:	684b      	ldr	r3, [r1, #4]
	region_conf.base = new_region->start;
18009e0a:	680c      	ldr	r4, [r1, #0]
{
18009e0c:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
18009e0e:	890a      	ldrh	r2, [r1, #8]
18009e10:	894d      	ldrh	r5, [r1, #10]
	region_conf.base = new_region->start;
18009e12:	9400      	str	r4, [sp, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
18009e14:	3b01      	subs	r3, #1
18009e16:	f024 041f 	bic.w	r4, r4, #31
18009e1a:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
18009e1c:	f002 021f 	and.w	r2, r2, #31
18009e20:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
18009e24:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
18009e28:	4669      	mov	r1, sp
	p_attr->rbar = attr->rbar &
18009e2a:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
18009e2e:	9303      	str	r3, [sp, #12]
18009e30:	f7fb fc40 	bl	180056b4 <region_allocate_and_init>
}
18009e34:	b005      	add	sp, #20
18009e36:	bd30      	pop	{r4, r5, pc}

18009e38 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
18009e38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
18009e3c:	4684      	mov	ip, r0
18009e3e:	4688      	mov	r8, r1
	register const char *s = nptr;
18009e40:	4604      	mov	r4, r0
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
18009e42:	4621      	mov	r1, r4
18009e44:	f814 3b01 	ldrb.w	r3, [r4], #1
18009e48:	2b20      	cmp	r3, #32
18009e4a:	d0fa      	beq.n	18009e42 <strtol+0xa>
18009e4c:	f1a3 0009 	sub.w	r0, r3, #9
18009e50:	2804      	cmp	r0, #4
18009e52:	d9f6      	bls.n	18009e42 <strtol+0xa>
	} while (isspace(c));
	if (c == '-') {
18009e54:	2b2d      	cmp	r3, #45	; 0x2d
18009e56:	d12d      	bne.n	18009eb4 <strtol+0x7c>
		neg = 1;
		c = *s++;
18009e58:	784b      	ldrb	r3, [r1, #1]
18009e5a:	1c8c      	adds	r4, r1, #2
		neg = 1;
18009e5c:	2101      	movs	r1, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
18009e5e:	2a00      	cmp	r2, #0
18009e60:	d05a      	beq.n	18009f18 <strtol+0xe0>
18009e62:	2a10      	cmp	r2, #16
18009e64:	d109      	bne.n	18009e7a <strtol+0x42>
18009e66:	2b30      	cmp	r3, #48	; 0x30
18009e68:	d107      	bne.n	18009e7a <strtol+0x42>
	    c == '0' && (*s == 'x' || *s == 'X')) {
18009e6a:	7823      	ldrb	r3, [r4, #0]
18009e6c:	f003 03df 	and.w	r3, r3, #223	; 0xdf
18009e70:	2b58      	cmp	r3, #88	; 0x58
18009e72:	d14c      	bne.n	18009f0e <strtol+0xd6>
		c = s[1];
		s += 2;
		base = 16;
18009e74:	2210      	movs	r2, #16
		c = s[1];
18009e76:	7863      	ldrb	r3, [r4, #1]
		s += 2;
18009e78:	3402      	adds	r4, #2
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
18009e7a:	2600      	movs	r6, #0
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
18009e7c:	f101 4700 	add.w	r7, r1, #2147483648	; 0x80000000
18009e80:	3f01      	subs	r7, #1
	cutlim = cutoff % (unsigned long)base;
18009e82:	fbb7 fef2 	udiv	lr, r7, r2
	for (acc = 0, any = 0;; c = *s++) {
18009e86:	4630      	mov	r0, r6
	cutlim = cutoff % (unsigned long)base;
18009e88:	fb02 791e 	mls	r9, r2, lr, r7
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
18009e8c:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
18009e90:	2d09      	cmp	r5, #9
18009e92:	d815      	bhi.n	18009ec0 <strtol+0x88>
			c -= '0';
18009e94:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
18009e96:	429a      	cmp	r2, r3
18009e98:	dd22      	ble.n	18009ee0 <strtol+0xa8>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
18009e9a:	1c75      	adds	r5, r6, #1
18009e9c:	d007      	beq.n	18009eae <strtol+0x76>
18009e9e:	4570      	cmp	r0, lr
18009ea0:	d81b      	bhi.n	18009eda <strtol+0xa2>
18009ea2:	d101      	bne.n	18009ea8 <strtol+0x70>
18009ea4:	454b      	cmp	r3, r9
18009ea6:	dc18      	bgt.n	18009eda <strtol+0xa2>
			any = -1;
		} else {
			any = 1;
18009ea8:	2601      	movs	r6, #1
			acc *= base;
			acc += c;
18009eaa:	fb00 3002 	mla	r0, r0, r2, r3
	for (acc = 0, any = 0;; c = *s++) {
18009eae:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
18009eb2:	e7eb      	b.n	18009e8c <strtol+0x54>
	} else if (c == '+') {
18009eb4:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
18009eb6:	bf04      	itt	eq
18009eb8:	784b      	ldrbeq	r3, [r1, #1]
18009eba:	1c8c      	addeq	r4, r1, #2
	register int neg = 0, any, cutlim;
18009ebc:	2100      	movs	r1, #0
18009ebe:	e7ce      	b.n	18009e5e <strtol+0x26>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
18009ec0:	f043 0520 	orr.w	r5, r3, #32
18009ec4:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
18009ec6:	2d19      	cmp	r5, #25
18009ec8:	d80a      	bhi.n	18009ee0 <strtol+0xa8>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
18009eca:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
18009ece:	2d1a      	cmp	r5, #26
18009ed0:	bf34      	ite	cc
18009ed2:	2537      	movcc	r5, #55	; 0x37
18009ed4:	2557      	movcs	r5, #87	; 0x57
18009ed6:	1b5b      	subs	r3, r3, r5
18009ed8:	e7dd      	b.n	18009e96 <strtol+0x5e>
			any = -1;
18009eda:	f04f 36ff 	mov.w	r6, #4294967295
18009ede:	e7e6      	b.n	18009eae <strtol+0x76>
		}
	}

	if (any < 0) {
18009ee0:	1c73      	adds	r3, r6, #1
18009ee2:	d109      	bne.n	18009ef8 <strtol+0xc0>
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
18009ee4:	f7fc fc98 	bl	18006818 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
18009ee8:	2322      	movs	r3, #34	; 0x22
18009eea:	6003      	str	r3, [r0, #0]
		acc = neg ? LONG_MIN : LONG_MAX;
18009eec:	4638      	mov	r0, r7
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
18009eee:	f1b8 0f00 	cmp.w	r8, #0
18009ef2:	d107      	bne.n	18009f04 <strtol+0xcc>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
18009ef4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (neg) {
18009ef8:	b101      	cbz	r1, 18009efc <strtol+0xc4>
		acc = -acc;
18009efa:	4240      	negs	r0, r0
	if (endptr != NULL) {
18009efc:	f1b8 0f00 	cmp.w	r8, #0
18009f00:	d0f8      	beq.n	18009ef4 <strtol+0xbc>
		*endptr = (char *)(any ? s - 1 : nptr);
18009f02:	b10e      	cbz	r6, 18009f08 <strtol+0xd0>
18009f04:	f104 3cff 	add.w	ip, r4, #4294967295
18009f08:	f8c8 c000 	str.w	ip, [r8]
	return acc;
18009f0c:	e7f2      	b.n	18009ef4 <strtol+0xbc>
	if (base == 0) {
18009f0e:	2330      	movs	r3, #48	; 0x30
18009f10:	2a00      	cmp	r2, #0
18009f12:	d1b2      	bne.n	18009e7a <strtol+0x42>
		base = c == '0' ? 8 : 10;
18009f14:	2208      	movs	r2, #8
18009f16:	e7b0      	b.n	18009e7a <strtol+0x42>
	if ((base == 0 || base == 16) &&
18009f18:	2b30      	cmp	r3, #48	; 0x30
18009f1a:	d0a6      	beq.n	18009e6a <strtol+0x32>
		base = c == '0' ? 8 : 10;
18009f1c:	220a      	movs	r2, #10
18009f1e:	e7ac      	b.n	18009e7a <strtol+0x42>

18009f20 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
18009f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
18009f24:	4607      	mov	r7, r0
18009f26:	4688      	mov	r8, r1
	register const char *s = nptr;
18009f28:	4604      	mov	r4, r0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
18009f2a:	4621      	mov	r1, r4
18009f2c:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
18009f30:	2b20      	cmp	r3, #32
18009f32:	d0fa      	beq.n	18009f2a <strtoul+0xa>
18009f34:	f1a3 0009 	sub.w	r0, r3, #9
18009f38:	2804      	cmp	r0, #4
18009f3a:	d9f6      	bls.n	18009f2a <strtoul+0xa>
	} while (isspace(c));
	if (c == '-') {
18009f3c:	2b2d      	cmp	r3, #45	; 0x2d
18009f3e:	d12f      	bne.n	18009fa0 <strtoul+0x80>
		neg = 1;
18009f40:	f04f 0c01 	mov.w	ip, #1
		c = *s++;
18009f44:	784b      	ldrb	r3, [r1, #1]
18009f46:	1c8c      	adds	r4, r1, #2
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
18009f48:	2a00      	cmp	r2, #0
18009f4a:	d05e      	beq.n	1800a00a <strtoul+0xea>
18009f4c:	2a10      	cmp	r2, #16
18009f4e:	d109      	bne.n	18009f64 <strtoul+0x44>
18009f50:	2b30      	cmp	r3, #48	; 0x30
18009f52:	d107      	bne.n	18009f64 <strtoul+0x44>
	    c == '0' && (*s == 'x' || *s == 'X')) {
18009f54:	7823      	ldrb	r3, [r4, #0]
18009f56:	f003 03df 	and.w	r3, r3, #223	; 0xdf
18009f5a:	2b58      	cmp	r3, #88	; 0x58
18009f5c:	d150      	bne.n	1800a000 <strtoul+0xe0>
		c = s[1];
		s += 2;
		base = 16;
18009f5e:	2210      	movs	r2, #16
		c = s[1];
18009f60:	7863      	ldrb	r3, [r4, #1]
		s += 2;
18009f62:	3402      	adds	r4, #2

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
18009f64:	f04f 31ff 	mov.w	r1, #4294967295
18009f68:	fbb1 f1f2 	udiv	r1, r1, r2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
18009f6c:	2600      	movs	r6, #0
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
18009f6e:	fb02 fe01 	mul.w	lr, r2, r1
	for (acc = 0, any = 0;; c = *s++) {
18009f72:	4630      	mov	r0, r6
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
18009f74:	ea6f 0e0e 	mvn.w	lr, lr
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
18009f78:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
18009f7c:	2d09      	cmp	r5, #9
18009f7e:	d816      	bhi.n	18009fae <strtoul+0x8e>
			c -= '0';
18009f80:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
18009f82:	429a      	cmp	r2, r3
18009f84:	dd23      	ble.n	18009fce <strtoul+0xae>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
18009f86:	2e00      	cmp	r6, #0
18009f88:	db1e      	blt.n	18009fc8 <strtoul+0xa8>
18009f8a:	4288      	cmp	r0, r1
18009f8c:	d81c      	bhi.n	18009fc8 <strtoul+0xa8>
18009f8e:	d101      	bne.n	18009f94 <strtoul+0x74>
18009f90:	4573      	cmp	r3, lr
18009f92:	dc19      	bgt.n	18009fc8 <strtoul+0xa8>
			any = -1;
		} else {
			any = 1;
18009f94:	2601      	movs	r6, #1
			acc *= base;
			acc += c;
18009f96:	fb00 3002 	mla	r0, r0, r2, r3
	for (acc = 0, any = 0;; c = *s++) {
18009f9a:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
18009f9e:	e7eb      	b.n	18009f78 <strtoul+0x58>
	} else if (c == '+') {
18009fa0:	2b2b      	cmp	r3, #43	; 0x2b
	register int neg = 0, any, cutlim;
18009fa2:	f04f 0c00 	mov.w	ip, #0
		c = *s++;
18009fa6:	bf04      	itt	eq
18009fa8:	784b      	ldrbeq	r3, [r1, #1]
18009faa:	1c8c      	addeq	r4, r1, #2
18009fac:	e7cc      	b.n	18009f48 <strtoul+0x28>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
18009fae:	f043 0520 	orr.w	r5, r3, #32
18009fb2:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
18009fb4:	2d19      	cmp	r5, #25
18009fb6:	d80a      	bhi.n	18009fce <strtoul+0xae>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
18009fb8:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
18009fbc:	2d1a      	cmp	r5, #26
18009fbe:	bf34      	ite	cc
18009fc0:	2537      	movcc	r5, #55	; 0x37
18009fc2:	2557      	movcs	r5, #87	; 0x57
18009fc4:	1b5b      	subs	r3, r3, r5
18009fc6:	e7dc      	b.n	18009f82 <strtoul+0x62>
			any = -1;
18009fc8:	f04f 36ff 	mov.w	r6, #4294967295
18009fcc:	e7e5      	b.n	18009f9a <strtoul+0x7a>
		}
	}
	if (any < 0) {
18009fce:	2e00      	cmp	r6, #0
18009fd0:	da0a      	bge.n	18009fe8 <strtoul+0xc8>
18009fd2:	f7fc fc21 	bl	18006818 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
18009fd6:	2322      	movs	r3, #34	; 0x22
18009fd8:	6003      	str	r3, [r0, #0]
		acc = ULONG_MAX;
18009fda:	f04f 30ff 	mov.w	r0, #4294967295
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
18009fde:	f1b8 0f00 	cmp.w	r8, #0
18009fe2:	d109      	bne.n	18009ff8 <strtoul+0xd8>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
18009fe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (neg) {
18009fe8:	f1bc 0f00 	cmp.w	ip, #0
18009fec:	d000      	beq.n	18009ff0 <strtoul+0xd0>
		acc = -acc;
18009fee:	4240      	negs	r0, r0
	if (endptr != NULL) {
18009ff0:	f1b8 0f00 	cmp.w	r8, #0
18009ff4:	d0f6      	beq.n	18009fe4 <strtoul+0xc4>
		*endptr = (char *)(any ? s - 1 : nptr);
18009ff6:	b106      	cbz	r6, 18009ffa <strtoul+0xda>
18009ff8:	1e67      	subs	r7, r4, #1
18009ffa:	f8c8 7000 	str.w	r7, [r8]
	return acc;
18009ffe:	e7f1      	b.n	18009fe4 <strtoul+0xc4>
	if (base == 0) {
1800a000:	2330      	movs	r3, #48	; 0x30
1800a002:	2a00      	cmp	r2, #0
1800a004:	d1ae      	bne.n	18009f64 <strtoul+0x44>
		base = c == '0' ? 8 : 10;
1800a006:	2208      	movs	r2, #8
1800a008:	e7ac      	b.n	18009f64 <strtoul+0x44>
	if ((base == 0 || base == 16) &&
1800a00a:	2b30      	cmp	r3, #48	; 0x30
1800a00c:	d0a2      	beq.n	18009f54 <strtoul+0x34>
		base = c == '0' ? 8 : 10;
1800a00e:	220a      	movs	r2, #10
1800a010:	e7a8      	b.n	18009f64 <strtoul+0x44>

1800a012 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
1800a012:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	char c, sc;
	size_t len;

	c = *find++;
1800a016:	f891 8000 	ldrb.w	r8, [r1]
{
1800a01a:	4605      	mov	r5, r0
	if (c != 0) {
1800a01c:	f1b8 0f00 	cmp.w	r8, #0
1800a020:	d010      	beq.n	1800a044 <strstr+0x32>
	c = *find++;
1800a022:	1c4c      	adds	r4, r1, #1
		len = strlen(find);
1800a024:	4620      	mov	r0, r4
1800a026:	f000 f83e 	bl	1800a0a6 <strlen>
1800a02a:	4607      	mov	r7, r0
		do {
			do {
				sc = *s++;
1800a02c:	462e      	mov	r6, r5
1800a02e:	f816 3b01 	ldrb.w	r3, [r6], #1
				if (sc == 0) {
1800a032:	b163      	cbz	r3, 1800a04e <strstr+0x3c>
					return NULL;
				}
			} while (sc != c);
1800a034:	4598      	cmp	r8, r3
1800a036:	d108      	bne.n	1800a04a <strstr+0x38>
		} while (strncmp(s, find, len) != 0);
1800a038:	463a      	mov	r2, r7
1800a03a:	4621      	mov	r1, r4
1800a03c:	4630      	mov	r0, r6
1800a03e:	f000 f84e 	bl	1800a0de <strncmp>
1800a042:	b910      	cbnz	r0, 1800a04a <strstr+0x38>
	s--;
	}
	return (char *)s;
}
1800a044:	4628      	mov	r0, r5
1800a046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
1800a04a:	4635      	mov	r5, r6
1800a04c:	e7ee      	b.n	1800a02c <strstr+0x1a>
					return NULL;
1800a04e:	461d      	mov	r5, r3
1800a050:	e7f8      	b.n	1800a044 <strstr+0x32>

1800a052 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
1800a052:	4603      	mov	r3, r0
1800a054:	3901      	subs	r1, #1
1800a056:	f811 2f01 	ldrb.w	r2, [r1, #1]!
1800a05a:	b90a      	cbnz	r2, 1800a060 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
1800a05c:	701a      	strb	r2, [r3, #0]

	return dest;
}
1800a05e:	4770      	bx	lr
		*d = *s;
1800a060:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
1800a064:	e7f7      	b.n	1800a056 <strcpy+0x4>

1800a066 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
1800a066:	b570      	push	{r4, r5, r6, lr}
1800a068:	4605      	mov	r5, r0
1800a06a:	462b      	mov	r3, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
1800a06c:	b142      	cbz	r2, 1800a080 <strncpy+0x1a>
1800a06e:	f811 4b01 	ldrb.w	r4, [r1], #1
		*d = *s;
		s++;
		d++;
		n--;
1800a072:	1e56      	subs	r6, r2, #1
	while ((n > 0) && *s != '\0') {
1800a074:	b92c      	cbnz	r4, 1800a082 <strncpy+0x1c>
1800a076:	442a      	add	r2, r5
	}

	while (n > 0) {
		*d = '\0';
1800a078:	f803 4b01 	strb.w	r4, [r3], #1
	while (n > 0) {
1800a07c:	429a      	cmp	r2, r3
1800a07e:	d1fb      	bne.n	1800a078 <strncpy+0x12>
		d++;
		n--;
	}

	return dest;
}
1800a080:	bd70      	pop	{r4, r5, r6, pc}
		n--;
1800a082:	4632      	mov	r2, r6
		*d = *s;
1800a084:	f805 4b01 	strb.w	r4, [r5], #1
		n--;
1800a088:	e7ef      	b.n	1800a06a <strncpy+0x4>

1800a08a <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
1800a08a:	4603      	mov	r3, r0
1800a08c:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
1800a08e:	781a      	ldrb	r2, [r3, #0]
1800a090:	4618      	mov	r0, r3
1800a092:	428a      	cmp	r2, r1
1800a094:	f103 0301 	add.w	r3, r3, #1
1800a098:	d004      	beq.n	1800a0a4 <strchr+0x1a>
1800a09a:	2a00      	cmp	r2, #0
1800a09c:	d1f7      	bne.n	1800a08e <strchr+0x4>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
1800a09e:	2900      	cmp	r1, #0
1800a0a0:	bf18      	it	ne
1800a0a2:	2000      	movne	r0, #0
}
1800a0a4:	4770      	bx	lr

1800a0a6 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
1800a0a6:	4603      	mov	r3, r0
	size_t n = 0;
1800a0a8:	2000      	movs	r0, #0

	while (*s != '\0') {
1800a0aa:	5c1a      	ldrb	r2, [r3, r0]
1800a0ac:	b902      	cbnz	r2, 1800a0b0 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
1800a0ae:	4770      	bx	lr
		n++;
1800a0b0:	3001      	adds	r0, #1
1800a0b2:	e7fa      	b.n	1800a0aa <strlen+0x4>

1800a0b4 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
1800a0b4:	4603      	mov	r3, r0
	size_t n = 0;
1800a0b6:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
1800a0b8:	5c1a      	ldrb	r2, [r3, r0]
1800a0ba:	b10a      	cbz	r2, 1800a0c0 <strnlen+0xc>
1800a0bc:	4288      	cmp	r0, r1
1800a0be:	d100      	bne.n	1800a0c2 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
1800a0c0:	4770      	bx	lr
		n++;
1800a0c2:	3001      	adds	r0, #1
1800a0c4:	e7f8      	b.n	1800a0b8 <strnlen+0x4>

1800a0c6 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
1800a0c6:	1e43      	subs	r3, r0, #1
1800a0c8:	3901      	subs	r1, #1
1800a0ca:	f813 2f01 	ldrb.w	r2, [r3, #1]!
1800a0ce:	f811 0f01 	ldrb.w	r0, [r1, #1]!
1800a0d2:	4282      	cmp	r2, r0
1800a0d4:	d101      	bne.n	1800a0da <strcmp+0x14>
1800a0d6:	2a00      	cmp	r2, #0
1800a0d8:	d1f7      	bne.n	1800a0ca <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
1800a0da:	1a10      	subs	r0, r2, r0
1800a0dc:	4770      	bx	lr

1800a0de <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
1800a0de:	b510      	push	{r4, lr}
1800a0e0:	3901      	subs	r1, #1
1800a0e2:	4402      	add	r2, r0
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
1800a0e4:	4282      	cmp	r2, r0
1800a0e6:	d009      	beq.n	1800a0fc <strncmp+0x1e>
1800a0e8:	7803      	ldrb	r3, [r0, #0]
1800a0ea:	f811 4f01 	ldrb.w	r4, [r1, #1]!
1800a0ee:	42a3      	cmp	r3, r4
1800a0f0:	d100      	bne.n	1800a0f4 <strncmp+0x16>
1800a0f2:	b90b      	cbnz	r3, 1800a0f8 <strncmp+0x1a>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
1800a0f4:	1b18      	subs	r0, r3, r4
1800a0f6:	e002      	b.n	1800a0fe <strncmp+0x20>
		s1++;
1800a0f8:	3001      	adds	r0, #1
		n--;
1800a0fa:	e7f3      	b.n	1800a0e4 <strncmp+0x6>
	return (n == 0) ? 0 : (*s1 - *s2);
1800a0fc:	2000      	movs	r0, #0
}
1800a0fe:	bd10      	pop	{r4, pc}

1800a100 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
1800a100:	4603      	mov	r3, r0
1800a102:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
1800a104:	b15a      	cbz	r2, 1800a11e <memcmp+0x1e>
1800a106:	3901      	subs	r1, #1
1800a108:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
1800a10a:	f813 0b01 	ldrb.w	r0, [r3], #1
1800a10e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
1800a112:	42a3      	cmp	r3, r4
1800a114:	d001      	beq.n	1800a11a <memcmp+0x1a>
1800a116:	4290      	cmp	r0, r2
1800a118:	d0f7      	beq.n	1800a10a <memcmp+0xa>
		c1++;
		c2++;
	}

	return *c1 - *c2;
1800a11a:	1a80      	subs	r0, r0, r2
}
1800a11c:	bd10      	pop	{r4, pc}
		return 0;
1800a11e:	4610      	mov	r0, r2
1800a120:	e7fc      	b.n	1800a11c <memcmp+0x1c>

1800a122 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
1800a122:	1a43      	subs	r3, r0, r1
1800a124:	4293      	cmp	r3, r2
{
1800a126:	b510      	push	{r4, lr}
1800a128:	eb00 0302 	add.w	r3, r0, r2
	if ((size_t) (dest - src) < n) {
1800a12c:	d308      	bcc.n	1800a140 <memmove+0x1e>
	char *dest = d;
1800a12e:	4602      	mov	r2, r0
1800a130:	3901      	subs	r1, #1
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
1800a132:	429a      	cmp	r2, r3
1800a134:	d007      	beq.n	1800a146 <memmove+0x24>
			*dest = *src;
1800a136:	f811 4f01 	ldrb.w	r4, [r1, #1]!
1800a13a:	f802 4b01 	strb.w	r4, [r2], #1
			dest++;
			src++;
			n--;
1800a13e:	e7f8      	b.n	1800a132 <memmove+0x10>
1800a140:	440a      	add	r2, r1
		while (n > 0) {
1800a142:	428a      	cmp	r2, r1
1800a144:	d100      	bne.n	1800a148 <memmove+0x26>
		}
	}

	return d;
}
1800a146:	bd10      	pop	{r4, pc}
			dest[n] = src[n];
1800a148:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
1800a14c:	f803 4d01 	strb.w	r4, [r3, #-1]!
1800a150:	e7f7      	b.n	1800a142 <memmove+0x20>

1800a152 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
1800a152:	b510      	push	{r4, lr}
1800a154:	1e43      	subs	r3, r0, #1
1800a156:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
1800a158:	4291      	cmp	r1, r2
1800a15a:	d100      	bne.n	1800a15e <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
1800a15c:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
1800a15e:	f811 4b01 	ldrb.w	r4, [r1], #1
1800a162:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
1800a166:	e7f7      	b.n	1800a158 <memcpy+0x6>

1800a168 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
1800a168:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
1800a16a:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
1800a16c:	4402      	add	r2, r0
1800a16e:	4293      	cmp	r3, r2
1800a170:	d100      	bne.n	1800a174 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
1800a172:	4770      	bx	lr
		*(d_byte++) = c_byte;
1800a174:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
1800a178:	e7f9      	b.n	1800a16e <memset+0x6>

1800a17a <_stdout_hook_default>:
}
1800a17a:	f04f 30ff 	mov.w	r0, #4294967295
1800a17e:	4770      	bx	lr

1800a180 <mcux_lpc_syscon_clock_control_on>:

static int mcux_lpc_syscon_clock_control_on(const struct device *dev,
			      clock_control_subsys_t sub_system)
{
	return 0;
}
1800a180:	2000      	movs	r0, #0
1800a182:	4770      	bx	lr

1800a184 <mcux_lpc_syscon_clock_control_init>:
}

static int mcux_lpc_syscon_clock_control_init(const struct device *dev)
{
	return 0;
}
1800a184:	2000      	movs	r0, #0
1800a186:	4770      	bx	lr

1800a188 <mcux_lpc_syscon_clock_control_get_subsys_rate>:
{
1800a188:	b510      	push	{r4, lr}
1800a18a:	4614      	mov	r4, r2
	switch (clock_name) {
1800a18c:	290a      	cmp	r1, #10
1800a18e:	d80b      	bhi.n	1800a1a8 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x20>
1800a190:	e8df f001 	tbb	[pc, r1]
1800a194:	100e0c06 	.word	0x100e0c06
1800a198:	18161412 	.word	0x18161412
1800a19c:	1c1a      	.short	0x1c1a
1800a19e:	20          	.byte	0x20
1800a19f:	00          	.byte	0x00
		*rate = CLOCK_GetFlexCommClkFreq(0);
1800a1a0:	2000      	movs	r0, #0
		*rate = CLOCK_GetFlexCommClkFreq(14);
1800a1a2:	f7fb ff55 	bl	18006050 <CLOCK_GetFlexCommClkFreq>
		*rate = CLOCK_GetSdioClkFreq(1);
1800a1a6:	6020      	str	r0, [r4, #0]
}
1800a1a8:	2000      	movs	r0, #0
1800a1aa:	bd10      	pop	{r4, pc}
		*rate = CLOCK_GetFlexCommClkFreq(1);
1800a1ac:	2001      	movs	r0, #1
1800a1ae:	e7f8      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetFlexCommClkFreq(2);
1800a1b0:	2002      	movs	r0, #2
1800a1b2:	e7f6      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetFlexCommClkFreq(3);
1800a1b4:	2003      	movs	r0, #3
1800a1b6:	e7f4      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetFlexCommClkFreq(4);
1800a1b8:	2004      	movs	r0, #4
1800a1ba:	e7f2      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetFlexCommClkFreq(5);
1800a1bc:	2005      	movs	r0, #5
1800a1be:	e7f0      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetFlexCommClkFreq(6);
1800a1c0:	2006      	movs	r0, #6
1800a1c2:	e7ee      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetFlexCommClkFreq(7);
1800a1c4:	2007      	movs	r0, #7
1800a1c6:	e7ec      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetFlexCommClkFreq(14);
1800a1c8:	200e      	movs	r0, #14
1800a1ca:	e7ea      	b.n	1800a1a2 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1a>
		*rate = CLOCK_GetSdioClkFreq(0);
1800a1cc:	2000      	movs	r0, #0
		*rate = CLOCK_GetSdioClkFreq(1);
1800a1ce:	f7fb ff6f 	bl	180060b0 <CLOCK_GetSdioClkFreq>
1800a1d2:	e7e8      	b.n	1800a1a6 <mcux_lpc_syscon_clock_control_get_subsys_rate+0x1e>
1800a1d4:	2001      	movs	r0, #1
1800a1d6:	e7fa      	b.n	1800a1ce <mcux_lpc_syscon_clock_control_get_subsys_rate+0x46>

1800a1d8 <mcux_lpc_syscon_clock_control_off>:
1800a1d8:	2000      	movs	r0, #0
1800a1da:	4770      	bx	lr

1800a1dc <gpio_mcux_lpc_configure>:
{
1800a1dc:	b570      	push	{r4, r5, r6, lr}
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a1de:	6843      	ldr	r3, [r0, #4]
	if (((flags & GPIO_INPUT) != 0) && ((flags & GPIO_OUTPUT) != 0)) {
1800a1e0:	f402 7440 	and.w	r4, r2, #768	; 0x300
1800a1e4:	f5b4 7f40 	cmp.w	r4, #768	; 0x300
	GPIO_Type *gpio_base = config->gpio_base;
1800a1e8:	685d      	ldr	r5, [r3, #4]
	uint32_t port = config->port_no;
1800a1ea:	6918      	ldr	r0, [r3, #16]
	if (((flags & GPIO_INPUT) != 0) && ((flags & GPIO_OUTPUT) != 0)) {
1800a1ec:	d03f      	beq.n	1800a26e <gpio_mcux_lpc_configure+0x92>
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
1800a1ee:	0794      	lsls	r4, r2, #30
1800a1f0:	d43d      	bmi.n	1800a26e <gpio_mcux_lpc_configure+0x92>
	IOPCTL_Type *pinmux_base = config->pinmux_base;
1800a1f2:	68db      	ldr	r3, [r3, #12]
	*pinconfig |= IOPCTL_PIO_INBUF_EN;
1800a1f4:	eb01 1440 	add.w	r4, r1, r0, lsl #5
1800a1f8:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
	if (flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) {
1800a1fc:	f012 0f30 	tst.w	r2, #48	; 0x30
	*pinconfig |= IOPCTL_PIO_INBUF_EN;
1800a200:	f046 0640 	orr.w	r6, r6, #64	; 0x40
1800a204:	f843 6024 	str.w	r6, [r3, r4, lsl #2]
	if (flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) {
1800a208:	d00d      	beq.n	1800a226 <gpio_mcux_lpc_configure+0x4a>
		*pinconfig |= IOPCTL_PIO_PUPD_EN;
1800a20a:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
1800a20e:	f046 0610 	orr.w	r6, r6, #16
1800a212:	f843 6024 	str.w	r6, [r3, r4, lsl #2]
		if ((flags & GPIO_PULL_UP) != 0) {
1800a216:	06d6      	lsls	r6, r2, #27
1800a218:	d522      	bpl.n	1800a260 <gpio_mcux_lpc_configure+0x84>
			*pinconfig |= IOPCTL_PIO_PULLUP_EN;
1800a21a:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
1800a21e:	f046 0620 	orr.w	r6, r6, #32
			*pinconfig &= ~(IOPCTL_PIO_PULLUP_EN);
1800a222:	f843 6024 	str.w	r6, [r3, r4, lsl #2]
		gpio_base->SET[port] = BIT(pin);
1800a226:	2301      	movs	r3, #1
	if (flags & GPIO_OUTPUT_INIT_HIGH) {
1800a228:	0514      	lsls	r4, r2, #20
		gpio_base->SET[port] = BIT(pin);
1800a22a:	fa03 f101 	lsl.w	r1, r3, r1
1800a22e:	bf44      	itt	mi
1800a230:	f500 6308 	addmi.w	r3, r0, #2176	; 0x880
1800a234:	f845 1023 	strmi.w	r1, [r5, r3, lsl #2]
	if (flags & GPIO_OUTPUT_INIT_LOW) {
1800a238:	0553      	lsls	r3, r2, #21
		gpio_base->CLR[port] = BIT(pin);
1800a23a:	bf44      	itt	mi
1800a23c:	f500 630a 	addmi.w	r3, r0, #2208	; 0x8a0
1800a240:	f845 1023 	strmi.w	r1, [r5, r3, lsl #2]
	WRITE_BIT(gpio_base->DIR[port], pin, flags & GPIO_OUTPUT);
1800a244:	f500 6000 	add.w	r0, r0, #2048	; 0x800
1800a248:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
1800a24c:	f412 7f00 	tst.w	r2, #512	; 0x200
1800a250:	bf14      	ite	ne
1800a252:	4319      	orrne	r1, r3
1800a254:	ea23 0101 	biceq.w	r1, r3, r1
1800a258:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
	return 0;
1800a25c:	2000      	movs	r0, #0
}
1800a25e:	bd70      	pop	{r4, r5, r6, pc}
		} else if ((flags & GPIO_PULL_DOWN) != 0) {
1800a260:	0696      	lsls	r6, r2, #26
1800a262:	d5e0      	bpl.n	1800a226 <gpio_mcux_lpc_configure+0x4a>
			*pinconfig &= ~(IOPCTL_PIO_PULLUP_EN);
1800a264:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
1800a268:	f026 0620 	bic.w	r6, r6, #32
1800a26c:	e7d9      	b.n	1800a222 <gpio_mcux_lpc_configure+0x46>
		return -ENOTSUP;
1800a26e:	f06f 0085 	mvn.w	r0, #133	; 0x85
1800a272:	e7f4      	b.n	1800a25e <gpio_mcux_lpc_configure+0x82>

1800a274 <gpio_mcux_lpc_port_get_raw>:
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a274:	6843      	ldr	r3, [r0, #4]
}
1800a276:	2000      	movs	r0, #0
	GPIO_Type *gpio_base = config->gpio_base;
1800a278:	685a      	ldr	r2, [r3, #4]
	*value = gpio_base->PIN[config->port_no];
1800a27a:	691b      	ldr	r3, [r3, #16]
1800a27c:	f503 6304 	add.w	r3, r3, #2112	; 0x840
1800a280:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1800a284:	600b      	str	r3, [r1, #0]
}
1800a286:	4770      	bx	lr

1800a288 <gpio_mcux_lpc_port_set_masked_raw>:
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a288:	6840      	ldr	r0, [r0, #4]
{
1800a28a:	b510      	push	{r4, lr}
1800a28c:	6843      	ldr	r3, [r0, #4]
1800a28e:	6904      	ldr	r4, [r0, #16]
	gpio_base->MASK[port] = ~mask;
1800a290:	43c9      	mvns	r1, r1
	gpio_base->MASK[port] = 0U;
1800a292:	2000      	movs	r0, #0
1800a294:	eb03 0384 	add.w	r3, r3, r4, lsl #2
	gpio_base->MASK[port] = ~mask;
1800a298:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
1800a29c:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
	gpio_base->MPIN[port] = value;
1800a2a0:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	gpio_base->MASK[port] = 0U;
1800a2a4:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
}
1800a2a8:	bd10      	pop	{r4, pc}

1800a2aa <gpio_mcux_lpc_port_set_bits_raw>:
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a2aa:	6843      	ldr	r3, [r0, #4]
}
1800a2ac:	2000      	movs	r0, #0
	GPIO_Type *gpio_base = config->gpio_base;
1800a2ae:	685a      	ldr	r2, [r3, #4]
	gpio_base->SET[config->port_no] = mask;
1800a2b0:	691b      	ldr	r3, [r3, #16]
1800a2b2:	f503 6308 	add.w	r3, r3, #2176	; 0x880
1800a2b6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
1800a2ba:	4770      	bx	lr

1800a2bc <gpio_mcux_lpc_port_clear_bits_raw>:
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a2bc:	6843      	ldr	r3, [r0, #4]
}
1800a2be:	2000      	movs	r0, #0
	GPIO_Type *gpio_base = config->gpio_base;
1800a2c0:	685a      	ldr	r2, [r3, #4]
	gpio_base->CLR[config->port_no] = mask;
1800a2c2:	691b      	ldr	r3, [r3, #16]
1800a2c4:	f503 630a 	add.w	r3, r3, #2208	; 0x8a0
1800a2c8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
1800a2cc:	4770      	bx	lr

1800a2ce <gpio_mcux_lpc_port_toggle_bits>:
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a2ce:	6843      	ldr	r3, [r0, #4]
}
1800a2d0:	2000      	movs	r0, #0
	GPIO_Type *gpio_base = config->gpio_base;
1800a2d2:	685a      	ldr	r2, [r3, #4]
	gpio_base->NOT[config->port_no] = mask;
1800a2d4:	691b      	ldr	r3, [r3, #16]
1800a2d6:	f503 630c 	add.w	r3, r3, #2240	; 0x8c0
1800a2da:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
1800a2de:	4770      	bx	lr

1800a2e0 <gpio_mcux_lpc_manage_cb>:

static int gpio_mcux_lpc_manage_cb(const struct device *port,
				   struct gpio_callback *callback, bool set)
{
	struct gpio_mcux_lpc_data *data = port->data;
1800a2e0:	6903      	ldr	r3, [r0, #16]
{
1800a2e2:	b530      	push	{r4, r5, lr}
	return list->head;
1800a2e4:	6858      	ldr	r0, [r3, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
1800a2e6:	b158      	cbz	r0, 1800a300 <gpio_mcux_lpc_manage_cb+0x20>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
1800a2e8:	2400      	movs	r4, #0
1800a2ea:	4281      	cmp	r1, r0
1800a2ec:	d112      	bne.n	1800a314 <gpio_mcux_lpc_manage_cb+0x34>
	return node->next;
1800a2ee:	6808      	ldr	r0, [r1, #0]
	return list->tail;
1800a2f0:	689d      	ldr	r5, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
1800a2f2:	b954      	cbnz	r4, 1800a30a <gpio_mcux_lpc_manage_cb+0x2a>
1800a2f4:	428d      	cmp	r5, r1
	list->head = node;
1800a2f6:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
1800a2f8:	d100      	bne.n	1800a2fc <gpio_mcux_lpc_manage_cb+0x1c>
	list->tail = node;
1800a2fa:	6098      	str	r0, [r3, #8]
	parent->next = child;
1800a2fc:	2000      	movs	r0, #0
1800a2fe:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
1800a300:	b96a      	cbnz	r2, 1800a31e <gpio_mcux_lpc_manage_cb+0x3e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
1800a302:	2000      	movs	r0, #0

	return gpio_manage_callback(&data->callbacks, callback, set);
}
1800a304:	bd30      	pop	{r4, r5, pc}
1800a306:	4628      	mov	r0, r5
1800a308:	e7ef      	b.n	1800a2ea <gpio_mcux_lpc_manage_cb+0xa>
Z_GENLIST_REMOVE(slist, snode)
1800a30a:	428d      	cmp	r5, r1
	parent->next = child;
1800a30c:	6020      	str	r0, [r4, #0]
	list->tail = node;
1800a30e:	bf08      	it	eq
1800a310:	609c      	streq	r4, [r3, #8]
}
1800a312:	e7f3      	b.n	1800a2fc <gpio_mcux_lpc_manage_cb+0x1c>
	return node->next;
1800a314:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
1800a316:	4604      	mov	r4, r0
1800a318:	2d00      	cmp	r5, #0
1800a31a:	d1f4      	bne.n	1800a306 <gpio_mcux_lpc_manage_cb+0x26>
			if (!set) {
1800a31c:	b13a      	cbz	r2, 1800a32e <gpio_mcux_lpc_manage_cb+0x4e>
	parent->next = child;
1800a31e:	685a      	ldr	r2, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
1800a320:	6898      	ldr	r0, [r3, #8]
	parent->next = child;
1800a322:	600a      	str	r2, [r1, #0]
	list->head = node;
1800a324:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
1800a326:	2800      	cmp	r0, #0
1800a328:	d1eb      	bne.n	1800a302 <gpio_mcux_lpc_manage_cb+0x22>
	list->tail = node;
1800a32a:	6099      	str	r1, [r3, #8]
}
1800a32c:	e7ea      	b.n	1800a304 <gpio_mcux_lpc_manage_cb+0x24>
				return -EINVAL;
1800a32e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&data->callbacks, callback, set);
1800a332:	e7e7      	b.n	1800a304 <gpio_mcux_lpc_manage_cb+0x24>

1800a334 <gpio_mcux_lpc_init.isra.0>:

static int gpio_mcux_lpc_init(const struct device *dev)
{
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a334:	6843      	ldr	r3, [r0, #4]
static int gpio_mcux_lpc_init(const struct device *dev)
1800a336:	b510      	push	{r4, lr}
	struct gpio_mcux_lpc_data *data = dev->data;
	int i;

	GPIO_PortInit(config->gpio_base, config->port_no);
1800a338:	6919      	ldr	r1, [r3, #16]
	struct gpio_mcux_lpc_data *data = dev->data;
1800a33a:	6904      	ldr	r4, [r0, #16]
	GPIO_PortInit(config->gpio_base, config->port_no);
1800a33c:	6858      	ldr	r0, [r3, #4]
1800a33e:	f7fc f8ff 	bl	18006540 <GPIO_PortInit>

	for (i = 0; i < 32; i++) {
		data->pint_id[i] = NO_PINT_INT;
1800a342:	2101      	movs	r1, #1
1800a344:	f104 030c 	add.w	r3, r4, #12
1800a348:	f104 022c 	add.w	r2, r4, #44	; 0x2c
1800a34c:	f803 1b01 	strb.w	r1, [r3], #1
	for (i = 0; i < 32; i++) {
1800a350:	4293      	cmp	r3, r2
1800a352:	d1fb      	bne.n	1800a34c <gpio_mcux_lpc_init.isra.0+0x18>
	}

	data->isr_list_idx = 0;
1800a354:	2300      	movs	r3, #0
1800a356:	64e3      	str	r3, [r4, #76]	; 0x4c

	return 0;
}
1800a358:	bd10      	pop	{r4, pc}

1800a35a <lpc_gpio_init_2>:
		GPIO_MCUX_LPC_IRQ(n, 3);						\
											\
		return 0;								\
	}

DT_INST_FOREACH_STATUS_OKAY(GPIO_MCUX_LPC)
1800a35a:	b508      	push	{r3, lr}
1800a35c:	f7ff ffea 	bl	1800a334 <gpio_mcux_lpc_init.isra.0>
1800a360:	2000      	movs	r0, #0
1800a362:	bd08      	pop	{r3, pc}

1800a364 <lpc_gpio_init_1>:
1800a364:	b538      	push	{r3, r4, r5, lr}
1800a366:	4604      	mov	r4, r0
1800a368:	f7ff ffe4 	bl	1800a334 <gpio_mcux_lpc_init.isra.0>
1800a36c:	6925      	ldr	r5, [r4, #16]
1800a36e:	2200      	movs	r2, #0
1800a370:	2102      	movs	r1, #2
1800a372:	2023      	movs	r0, #35	; 0x23
1800a374:	f7fa fc58 	bl	18004c28 <z_arm_irq_priority_set>
1800a378:	2023      	movs	r0, #35	; 0x23
1800a37a:	f7fa fc45 	bl	18004c08 <arch_irq_enable>
1800a37e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
1800a380:	2102      	movs	r1, #2
1800a382:	1c5a      	adds	r2, r3, #1
1800a384:	64ea      	str	r2, [r5, #76]	; 0x4c
1800a386:	eb05 0583 	add.w	r5, r5, r3, lsl #2
1800a38a:	2323      	movs	r3, #35	; 0x23
1800a38c:	2200      	movs	r2, #0
1800a38e:	62eb      	str	r3, [r5, #44]	; 0x2c
1800a390:	2024      	movs	r0, #36	; 0x24
1800a392:	6925      	ldr	r5, [r4, #16]
1800a394:	f7fa fc48 	bl	18004c28 <z_arm_irq_priority_set>
1800a398:	2024      	movs	r0, #36	; 0x24
1800a39a:	f7fa fc35 	bl	18004c08 <arch_irq_enable>
1800a39e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
1800a3a0:	2102      	movs	r1, #2
1800a3a2:	1c5a      	adds	r2, r3, #1
1800a3a4:	64ea      	str	r2, [r5, #76]	; 0x4c
1800a3a6:	eb05 0583 	add.w	r5, r5, r3, lsl #2
1800a3aa:	2324      	movs	r3, #36	; 0x24
1800a3ac:	2200      	movs	r2, #0
1800a3ae:	62eb      	str	r3, [r5, #44]	; 0x2c
1800a3b0:	2025      	movs	r0, #37	; 0x25
1800a3b2:	6925      	ldr	r5, [r4, #16]
1800a3b4:	f7fa fc38 	bl	18004c28 <z_arm_irq_priority_set>
1800a3b8:	2025      	movs	r0, #37	; 0x25
1800a3ba:	f7fa fc25 	bl	18004c08 <arch_irq_enable>
1800a3be:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
1800a3c0:	6924      	ldr	r4, [r4, #16]
1800a3c2:	1c5a      	adds	r2, r3, #1
1800a3c4:	64ea      	str	r2, [r5, #76]	; 0x4c
1800a3c6:	eb05 0583 	add.w	r5, r5, r3, lsl #2
1800a3ca:	2325      	movs	r3, #37	; 0x25
1800a3cc:	2200      	movs	r2, #0
1800a3ce:	62eb      	str	r3, [r5, #44]	; 0x2c
1800a3d0:	2102      	movs	r1, #2
1800a3d2:	2026      	movs	r0, #38	; 0x26
1800a3d4:	f7fa fc28 	bl	18004c28 <z_arm_irq_priority_set>
1800a3d8:	2026      	movs	r0, #38	; 0x26
1800a3da:	f7fa fc15 	bl	18004c08 <arch_irq_enable>
1800a3de:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
1800a3e0:	2000      	movs	r0, #0
1800a3e2:	1c5a      	adds	r2, r3, #1
1800a3e4:	64e2      	str	r2, [r4, #76]	; 0x4c
1800a3e6:	eb04 0483 	add.w	r4, r4, r3, lsl #2
1800a3ea:	2326      	movs	r3, #38	; 0x26
1800a3ec:	62e3      	str	r3, [r4, #44]	; 0x2c
1800a3ee:	bd38      	pop	{r3, r4, r5, pc}

1800a3f0 <lpc_gpio_init_0>:
1800a3f0:	b538      	push	{r3, r4, r5, lr}
1800a3f2:	4604      	mov	r4, r0
1800a3f4:	f7ff ff9e 	bl	1800a334 <gpio_mcux_lpc_init.isra.0>
1800a3f8:	6925      	ldr	r5, [r4, #16]
1800a3fa:	2200      	movs	r2, #0
1800a3fc:	2102      	movs	r1, #2
1800a3fe:	2004      	movs	r0, #4
1800a400:	f7fa fc12 	bl	18004c28 <z_arm_irq_priority_set>
1800a404:	2004      	movs	r0, #4
1800a406:	f7fa fbff 	bl	18004c08 <arch_irq_enable>
1800a40a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
1800a40c:	2102      	movs	r1, #2
1800a40e:	1c5a      	adds	r2, r3, #1
1800a410:	64ea      	str	r2, [r5, #76]	; 0x4c
1800a412:	eb05 0583 	add.w	r5, r5, r3, lsl #2
1800a416:	2304      	movs	r3, #4
1800a418:	2200      	movs	r2, #0
1800a41a:	62eb      	str	r3, [r5, #44]	; 0x2c
1800a41c:	2005      	movs	r0, #5
1800a41e:	6925      	ldr	r5, [r4, #16]
1800a420:	f7fa fc02 	bl	18004c28 <z_arm_irq_priority_set>
1800a424:	2005      	movs	r0, #5
1800a426:	f7fa fbef 	bl	18004c08 <arch_irq_enable>
1800a42a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
1800a42c:	2102      	movs	r1, #2
1800a42e:	1c5a      	adds	r2, r3, #1
1800a430:	64ea      	str	r2, [r5, #76]	; 0x4c
1800a432:	eb05 0583 	add.w	r5, r5, r3, lsl #2
1800a436:	2305      	movs	r3, #5
1800a438:	2200      	movs	r2, #0
1800a43a:	62eb      	str	r3, [r5, #44]	; 0x2c
1800a43c:	2006      	movs	r0, #6
1800a43e:	6925      	ldr	r5, [r4, #16]
1800a440:	f7fa fbf2 	bl	18004c28 <z_arm_irq_priority_set>
1800a444:	2006      	movs	r0, #6
1800a446:	f7fa fbdf 	bl	18004c08 <arch_irq_enable>
1800a44a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
1800a44c:	6924      	ldr	r4, [r4, #16]
1800a44e:	1c5a      	adds	r2, r3, #1
1800a450:	64ea      	str	r2, [r5, #76]	; 0x4c
1800a452:	eb05 0583 	add.w	r5, r5, r3, lsl #2
1800a456:	2306      	movs	r3, #6
1800a458:	2200      	movs	r2, #0
1800a45a:	62eb      	str	r3, [r5, #44]	; 0x2c
1800a45c:	2102      	movs	r1, #2
1800a45e:	2007      	movs	r0, #7
1800a460:	f7fa fbe2 	bl	18004c28 <z_arm_irq_priority_set>
1800a464:	2007      	movs	r0, #7
1800a466:	f7fa fbcf 	bl	18004c08 <arch_irq_enable>
1800a46a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
1800a46c:	2000      	movs	r0, #0
1800a46e:	1c5a      	adds	r2, r3, #1
1800a470:	64e2      	str	r2, [r4, #76]	; 0x4c
1800a472:	eb04 0483 	add.w	r4, r4, r3, lsl #2
1800a476:	2307      	movs	r3, #7
1800a478:	62e3      	str	r3, [r4, #44]	; 0x2c
1800a47a:	bd38      	pop	{r3, r4, r5, pc}

1800a47c <gpio_mcux_lpc_port_isr>:
{
1800a47c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct gpio_mcux_lpc_data *data = dev->data;
1800a480:	f8d0 a010 	ldr.w	sl, [r0, #16]
{
1800a484:	4607      	mov	r7, r0
	struct gpio_mcux_lpc_data *data = dev->data;
1800a486:	4656      	mov	r6, sl
	const struct gpio_mcux_lpc_config *config = dev->config;
1800a488:	f8d0 8004 	ldr.w	r8, [r0, #4]
	for (pin = 0; pin < 32; pin++) {
1800a48c:	f10a 0920 	add.w	r9, sl, #32
		if (data->pint_id[pin] != NO_PINT_INT) {
1800a490:	7b34      	ldrb	r4, [r6, #12]
1800a492:	eba6 0b0a 	sub.w	fp, r6, sl
1800a496:	2c01      	cmp	r4, #1
1800a498:	d104      	bne.n	1800a4a4 <gpio_mcux_lpc_port_isr+0x28>
	for (pin = 0; pin < 32; pin++) {
1800a49a:	3601      	adds	r6, #1
1800a49c:	454e      	cmp	r6, r9
1800a49e:	d1f7      	bne.n	1800a490 <gpio_mcux_lpc_port_isr+0x14>
}
1800a4a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			int_flags = PINT_PinInterruptGetStatus(
1800a4a4:	f8d8 0008 	ldr.w	r0, [r8, #8]
			PINT_PinInterruptClrStatus(config->pint_base,
1800a4a8:	4621      	mov	r1, r4
    return ((base->IST & (1UL << (uint32_t)pintr)) != 0U ? 1U : 0U);
1800a4aa:	6a45      	ldr	r5, [r0, #36]	; 0x24
1800a4ac:	f000 f94a 	bl	1800a744 <PINT_PinInterruptClrStatus>
			gpio_fire_callbacks(&data->callbacks, dev, enabled_int);
1800a4b0:	f8da 1004 	ldr.w	r1, [sl, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
1800a4b4:	2900      	cmp	r1, #0
1800a4b6:	d0f0      	beq.n	1800a49a <gpio_mcux_lpc_port_isr+0x1e>
1800a4b8:	fa25 f404 	lsr.w	r4, r5, r4
1800a4bc:	f004 0401 	and.w	r4, r4, #1
	return node->next;
1800a4c0:	680d      	ldr	r5, [r1, #0]
			enabled_int = int_flags << pin;
1800a4c2:	fa04 f40b 	lsl.w	r4, r4, fp
		if (cb->pin_mask & pins) {
1800a4c6:	688a      	ldr	r2, [r1, #8]
1800a4c8:	4022      	ands	r2, r4
1800a4ca:	d002      	beq.n	1800a4d2 <gpio_mcux_lpc_port_isr+0x56>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
1800a4cc:	4638      	mov	r0, r7
1800a4ce:	684b      	ldr	r3, [r1, #4]
1800a4d0:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
1800a4d2:	2d00      	cmp	r5, #0
1800a4d4:	d0e1      	beq.n	1800a49a <gpio_mcux_lpc_port_isr+0x1e>
1800a4d6:	4629      	mov	r1, r5
1800a4d8:	682d      	ldr	r5, [r5, #0]
1800a4da:	e7f4      	b.n	1800a4c6 <gpio_mcux_lpc_port_isr+0x4a>

1800a4dc <mcux_flexcomm_poll_in>:
};

static int mcux_flexcomm_poll_in(const struct device *dev, unsigned char *c)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t flags = USART_GetStatusFlags(config->base);
1800a4dc:	6843      	ldr	r3, [r0, #4]
1800a4de:	681b      	ldr	r3, [r3, #0]
 * @param base USART peripheral base address.
 * @return USART status flags which are ORed by the enumerators in the _usart_flags.
 */
static inline uint32_t USART_GetStatusFlags(USART_Type *base)
{
    return base->FIFOSTAT;
1800a4e0:	f8d3 2e04 	ldr.w	r2, [r3, #3588]	; 0xe04
	int ret = -1;

	if (flags & kUSART_RxFifoNotEmptyFlag) {
1800a4e4:	0652      	lsls	r2, r2, #25
 * @param base USART peripheral base address.
 * @return The byte read from USART data register.
 */
static inline uint8_t USART_ReadByte(USART_Type *base)
{
    return (uint8_t)base->FIFORD;
1800a4e6:	bf43      	ittte	mi
1800a4e8:	f8d3 3e30 	ldrmi.w	r3, [r3, #3632]	; 0xe30
		*c = USART_ReadByte(config->base);
		ret = 0;
1800a4ec:	2000      	movmi	r0, #0
1800a4ee:	700b      	strbmi	r3, [r1, #0]
	int ret = -1;
1800a4f0:	f04f 30ff 	movpl.w	r0, #4294967295
	}

	return ret;
}
1800a4f4:	4770      	bx	lr

1800a4f6 <mcux_flexcomm_poll_out>:
					     unsigned char c)
{
	const struct mcux_flexcomm_config *config = dev->config;

	/* Wait until space is available in TX FIFO */
	while (!(USART_GetStatusFlags(config->base) & kUSART_TxFifoEmptyFlag)) {
1800a4f6:	6843      	ldr	r3, [r0, #4]
1800a4f8:	681b      	ldr	r3, [r3, #0]
    return base->FIFOSTAT;
1800a4fa:	f8d3 2e04 	ldr.w	r2, [r3, #3588]	; 0xe04
1800a4fe:	06d2      	lsls	r2, r2, #27
1800a500:	d5fb      	bpl.n	1800a4fa <mcux_flexcomm_poll_out+0x4>
    base->FIFOWR = data;
1800a502:	f8c3 1e20 	str.w	r1, [r3, #3616]	; 0xe20
	}

	USART_WriteByte(config->base, c);
}
1800a506:	4770      	bx	lr

1800a508 <mcux_flexcomm_err_check>:
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t flags = USART_GetStatusFlags(config->base);
	int err = 0;

	if (flags & kStatus_USART_RxRingBufferOverrun) {
1800a508:	f241 614c 	movw	r1, #5708	; 0x164c
	uint32_t flags = USART_GetStatusFlags(config->base);
1800a50c:	6843      	ldr	r3, [r0, #4]
1800a50e:	681a      	ldr	r2, [r3, #0]
    return base->FIFOSTAT;
1800a510:	f8d2 3e04 	ldr.w	r3, [r2, #3588]	; 0xe04
	if (flags & kStatus_USART_RxRingBufferOverrun) {
1800a514:	420b      	tst	r3, r1
		err |= UART_ERROR_OVERRUN;
	}

	if (flags & kStatus_USART_ParityError) {
1800a516:	f241 6150 	movw	r1, #5712	; 0x1650
	if (flags & kStatus_USART_RxRingBufferOverrun) {
1800a51a:	bf14      	ite	ne
1800a51c:	2001      	movne	r0, #1
1800a51e:	2000      	moveq	r0, #0
	if (flags & kStatus_USART_ParityError) {
1800a520:	420b      	tst	r3, r1
		err |= UART_ERROR_PARITY;
	}

	if (flags & kStatus_USART_FramingError) {
1800a522:	f241 614f 	movw	r1, #5711	; 0x164f
		err |= UART_ERROR_PARITY;
1800a526:	bf18      	it	ne
1800a528:	f040 0002 	orrne.w	r0, r0, #2
	if (flags & kStatus_USART_FramingError) {
1800a52c:	420b      	tst	r3, r1
    base->FIFOSTAT = mask & (USART_FIFOSTAT_TXERR_MASK | USART_FIFOSTAT_RXERR_MASK);
1800a52e:	f04f 0303 	mov.w	r3, #3
		err |= UART_ERROR_FRAMING;
1800a532:	bf18      	it	ne
1800a534:	f040 0004 	orrne.w	r0, r0, #4
1800a538:	f8c2 3e04 	str.w	r3, [r2, #3588]	; 0xe04
			       kStatus_USART_RxRingBufferOverrun |
			       kStatus_USART_ParityError |
			       kStatus_USART_FramingError);

	return err;
}
1800a53c:	4770      	bx	lr

1800a53e <mcux_flexcomm_fifo_fill>:
				   int len)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint8_t num_tx = 0U;

	while ((len - num_tx > 0) &&
1800a53e:	2300      	movs	r3, #0
{
1800a540:	b570      	push	{r4, r5, r6, lr}
	const struct mcux_flexcomm_config *config = dev->config;
1800a542:	6846      	ldr	r6, [r0, #4]
	while ((len - num_tx > 0) &&
1800a544:	b2d8      	uxtb	r0, r3
1800a546:	1a14      	subs	r4, r2, r0
1800a548:	2c00      	cmp	r4, #0
1800a54a:	dd05      	ble.n	1800a558 <mcux_flexcomm_fifo_fill+0x1a>
	       (USART_GetStatusFlags(config->base)
1800a54c:	6834      	ldr	r4, [r6, #0]
	while ((len - num_tx > 0) &&
1800a54e:	3301      	adds	r3, #1
    return base->FIFOSTAT;
1800a550:	f8d4 5e04 	ldr.w	r5, [r4, #3588]	; 0xe04
1800a554:	06ad      	lsls	r5, r5, #26
1800a556:	d400      	bmi.n	1800a55a <mcux_flexcomm_fifo_fill+0x1c>

		USART_WriteByte(config->base, tx_data[num_tx++]);
	}

	return num_tx;
}
1800a558:	bd70      	pop	{r4, r5, r6, pc}
    base->FIFOWR = data;
1800a55a:	5c08      	ldrb	r0, [r1, r0]
1800a55c:	f8c4 0e20 	str.w	r0, [r4, #3616]	; 0xe20
}
1800a560:	e7f0      	b.n	1800a544 <mcux_flexcomm_fifo_fill+0x6>

1800a562 <mcux_flexcomm_fifo_read>:
				   const int len)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint8_t num_rx = 0U;

	while ((len - num_rx > 0) &&
1800a562:	2300      	movs	r3, #0
{
1800a564:	b570      	push	{r4, r5, r6, lr}
	const struct mcux_flexcomm_config *config = dev->config;
1800a566:	6846      	ldr	r6, [r0, #4]
	while ((len - num_rx > 0) &&
1800a568:	b2d8      	uxtb	r0, r3
1800a56a:	1a14      	subs	r4, r2, r0
1800a56c:	2c00      	cmp	r4, #0
1800a56e:	dd05      	ble.n	1800a57c <mcux_flexcomm_fifo_read+0x1a>
	       (USART_GetStatusFlags(config->base)
1800a570:	6834      	ldr	r4, [r6, #0]
	while ((len - num_rx > 0) &&
1800a572:	3301      	adds	r3, #1
    return base->FIFOSTAT;
1800a574:	f8d4 5e04 	ldr.w	r5, [r4, #3588]	; 0xe04
1800a578:	066d      	lsls	r5, r5, #25
1800a57a:	d400      	bmi.n	1800a57e <mcux_flexcomm_fifo_read+0x1c>

		rx_data[num_rx++] = USART_ReadByte(config->base);
	}

	return num_rx;
}
1800a57c:	bd70      	pop	{r4, r5, r6, pc}
    return (uint8_t)base->FIFORD;
1800a57e:	f8d4 4e30 	ldr.w	r4, [r4, #3632]	; 0xe30
1800a582:	540c      	strb	r4, [r1, r0]
1800a584:	e7f0      	b.n	1800a568 <mcux_flexcomm_fifo_read+0x6>

1800a586 <mcux_flexcomm_irq_tx_enable>:
    base->FIFOINTENSET = mask & 0xFUL;
1800a586:	2204      	movs	r2, #4
static void mcux_flexcomm_irq_tx_enable(const struct device *dev)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t mask = kUSART_TxLevelInterruptEnable;

	USART_EnableInterrupts(config->base, mask);
1800a588:	6843      	ldr	r3, [r0, #4]
1800a58a:	681b      	ldr	r3, [r3, #0]
1800a58c:	f8c3 2e10 	str.w	r2, [r3, #3600]	; 0xe10
}
1800a590:	4770      	bx	lr

1800a592 <mcux_flexcomm_irq_tx_disable>:
    base->FIFOINTENCLR = mask & 0xFUL;
1800a592:	2204      	movs	r2, #4
static void mcux_flexcomm_irq_tx_disable(const struct device *dev)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t mask = kUSART_TxLevelInterruptEnable;

	USART_DisableInterrupts(config->base, mask);
1800a594:	6843      	ldr	r3, [r0, #4]
1800a596:	681b      	ldr	r3, [r3, #0]
1800a598:	f8c3 2e14 	str.w	r2, [r3, #3604]	; 0xe14
}
1800a59c:	4770      	bx	lr

1800a59e <mcux_flexcomm_irq_tx_complete>:

static int mcux_flexcomm_irq_tx_complete(const struct device *dev)
{
	const struct mcux_flexcomm_config *config = dev->config;

	return (config->base->STAT & USART_STAT_TXIDLE_MASK) != 0;
1800a59e:	6843      	ldr	r3, [r0, #4]
1800a5a0:	681b      	ldr	r3, [r3, #0]
1800a5a2:	6898      	ldr	r0, [r3, #8]
}
1800a5a4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
1800a5a8:	4770      	bx	lr

1800a5aa <mcux_flexcomm_irq_tx_ready>:

static int mcux_flexcomm_irq_tx_ready(const struct device *dev)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t mask = kUSART_TxLevelInterruptEnable;
	uint32_t flags = USART_GetStatusFlags(config->base);
1800a5aa:	6843      	ldr	r3, [r0, #4]
1800a5ac:	681b      	ldr	r3, [r3, #0]
    return base->FIFOSTAT;
1800a5ae:	f8d3 2e04 	ldr.w	r2, [r3, #3588]	; 0xe04
    return base->FIFOINTENSET;
1800a5b2:	f8d3 0e10 	ldr.w	r0, [r3, #3600]	; 0xe10

	return (USART_GetEnabledInterrupts(config->base) & mask)
		&& (flags & kUSART_TxFifoEmptyFlag);
1800a5b6:	f010 0004 	ands.w	r0, r0, #4
1800a5ba:	bf18      	it	ne
1800a5bc:	f3c2 1000 	ubfxne	r0, r2, #4, #1
}
1800a5c0:	4770      	bx	lr

1800a5c2 <mcux_flexcomm_irq_rx_enable>:
    base->FIFOINTENSET = mask & 0xFUL;
1800a5c2:	2208      	movs	r2, #8
static void mcux_flexcomm_irq_rx_enable(const struct device *dev)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t mask = kUSART_RxLevelInterruptEnable;

	USART_EnableInterrupts(config->base, mask);
1800a5c4:	6843      	ldr	r3, [r0, #4]
1800a5c6:	681b      	ldr	r3, [r3, #0]
1800a5c8:	f8c3 2e10 	str.w	r2, [r3, #3600]	; 0xe10
}
1800a5cc:	4770      	bx	lr

1800a5ce <mcux_flexcomm_irq_rx_disable>:
    base->FIFOINTENCLR = mask & 0xFUL;
1800a5ce:	2208      	movs	r2, #8
static void mcux_flexcomm_irq_rx_disable(const struct device *dev)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t mask = kUSART_RxLevelInterruptEnable;

	USART_DisableInterrupts(config->base, mask);
1800a5d0:	6843      	ldr	r3, [r0, #4]
1800a5d2:	681b      	ldr	r3, [r3, #0]
1800a5d4:	f8c3 2e14 	str.w	r2, [r3, #3604]	; 0xe14
}
1800a5d8:	4770      	bx	lr

1800a5da <mcux_flexcomm_irq_rx_full>:

static int mcux_flexcomm_irq_rx_full(const struct device *dev)
{
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t flags = USART_GetStatusFlags(config->base);
1800a5da:	6843      	ldr	r3, [r0, #4]
1800a5dc:	681b      	ldr	r3, [r3, #0]
    return base->FIFOSTAT;
1800a5de:	f8d3 0e04 	ldr.w	r0, [r3, #3588]	; 0xe04

	return (flags & kUSART_RxFifoNotEmptyFlag) != 0U;
}
1800a5e2:	f3c0 1080 	ubfx	r0, r0, #6, #1
1800a5e6:	4770      	bx	lr

1800a5e8 <mcux_flexcomm_irq_err_enable>:
    base->FIFOINTENSET = mask & 0xFUL;
1800a5e8:	220f      	movs	r2, #15
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t mask = kStatus_USART_NoiseError |
			kStatus_USART_FramingError |
			kStatus_USART_ParityError;

	USART_EnableInterrupts(config->base, mask);
1800a5ea:	6843      	ldr	r3, [r0, #4]
1800a5ec:	681b      	ldr	r3, [r3, #0]
1800a5ee:	f8c3 2e10 	str.w	r2, [r3, #3600]	; 0xe10
}
1800a5f2:	4770      	bx	lr

1800a5f4 <mcux_flexcomm_irq_err_disable>:
    base->FIFOINTENCLR = mask & 0xFUL;
1800a5f4:	220f      	movs	r2, #15
	const struct mcux_flexcomm_config *config = dev->config;
	uint32_t mask = kStatus_USART_NoiseError |
			kStatus_USART_FramingError |
			kStatus_USART_ParityError;

	USART_DisableInterrupts(config->base, mask);
1800a5f6:	6843      	ldr	r3, [r0, #4]
1800a5f8:	681b      	ldr	r3, [r3, #0]
1800a5fa:	f8c3 2e14 	str.w	r2, [r3, #3604]	; 0xe14
}
1800a5fe:	4770      	bx	lr

1800a600 <mcux_flexcomm_irq_update>:
}

static int mcux_flexcomm_irq_update(const struct device *dev)
{
	return 1;
}
1800a600:	2001      	movs	r0, #1
1800a602:	4770      	bx	lr

1800a604 <mcux_flexcomm_irq_callback_set>:

static void mcux_flexcomm_irq_callback_set(const struct device *dev,
					   uart_irq_callback_user_data_t cb,
					   void *cb_data)
{
	struct mcux_flexcomm_data *data = dev->data;
1800a604:	6903      	ldr	r3, [r0, #16]

	data->callback = cb;
	data->cb_data = cb_data;
1800a606:	e9c3 1200 	strd	r1, r2, [r3]
}
1800a60a:	4770      	bx	lr

1800a60c <mcux_flexcomm_isr>:

static void mcux_flexcomm_isr(const struct device *dev)
{
	struct mcux_flexcomm_data *data = dev->data;
1800a60c:	6902      	ldr	r2, [r0, #16]

	if (data->callback) {
1800a60e:	6813      	ldr	r3, [r2, #0]
1800a610:	b10b      	cbz	r3, 1800a616 <mcux_flexcomm_isr+0xa>
		data->callback(dev, data->cb_data);
1800a612:	6851      	ldr	r1, [r2, #4]
1800a614:	4718      	bx	r3
	}
}
1800a616:	4770      	bx	lr

1800a618 <mcux_flexcomm_config_func_0>:
									\
	UART_MCUX_FLEXCOMM_CONFIG_FUNC(n)				\
									\
	UART_MCUX_FLEXCOMM_INIT_CFG(n);

DT_INST_FOREACH_STATUS_OKAY(UART_MCUX_FLEXCOMM_INIT)
1800a618:	2200      	movs	r2, #0
1800a61a:	b508      	push	{r3, lr}
1800a61c:	200e      	movs	r0, #14
1800a61e:	4611      	mov	r1, r2
1800a620:	f7fa fb02 	bl	18004c28 <z_arm_irq_priority_set>
1800a624:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
1800a628:	200e      	movs	r0, #14
1800a62a:	f7fa baed 	b.w	18004c08 <arch_irq_enable>

1800a62e <mcux_flexcomm_init>:
{
1800a62e:	b5f0      	push	{r4, r5, r6, r7, lr}
	const struct mcux_flexcomm_config *config = dev->config;
1800a630:	6844      	ldr	r4, [r0, #4]
{
1800a632:	b087      	sub	sp, #28
1800a634:	4607      	mov	r7, r0
	if (clock_control_get_rate(config->clock_dev, config->clock_subsys,
1800a636:	e9d4 5601 	ldrd	r5, r6, [r4, #4]
1800a63a:	4628      	mov	r0, r5
1800a63c:	f000 f9af 	bl	1800a99e <z_device_ready>
1800a640:	b920      	cbnz	r0, 1800a64c <mcux_flexcomm_init+0x1e>
		return -EINVAL;
1800a642:	f06f 0615 	mvn.w	r6, #21
}
1800a646:	4630      	mov	r0, r6
1800a648:	b007      	add	sp, #28
1800a64a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	}

	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->api;

	if (api->get_rate == NULL) {
1800a64c:	68ab      	ldr	r3, [r5, #8]
1800a64e:	68db      	ldr	r3, [r3, #12]
1800a650:	2b00      	cmp	r3, #0
1800a652:	d0f6      	beq.n	1800a642 <mcux_flexcomm_init+0x14>
		return -ENOSYS;
	}

	return api->get_rate(dev, sys, rate);
1800a654:	4631      	mov	r1, r6
1800a656:	466a      	mov	r2, sp
1800a658:	4628      	mov	r0, r5
1800a65a:	4798      	blx	r3
	if (clock_control_get_rate(config->clock_dev, config->clock_subsys,
1800a65c:	4606      	mov	r6, r0
1800a65e:	2800      	cmp	r0, #0
1800a660:	d1ef      	bne.n	1800a642 <mcux_flexcomm_init+0x14>
	if (config->parity == UART_CFG_PARITY_ODD) {
1800a662:	7c25      	ldrb	r5, [r4, #16]
1800a664:	2d01      	cmp	r5, #1
1800a666:	d016      	beq.n	1800a696 <mcux_flexcomm_init+0x68>
		parity_mode = kUSART_ParityDisabled;
1800a668:	2d02      	cmp	r5, #2
1800a66a:	bf18      	it	ne
1800a66c:	2500      	movne	r5, #0
	USART_GetDefaultConfig(&usart_config);
1800a66e:	a801      	add	r0, sp, #4
1800a670:	f000 f891 	bl	1800a796 <USART_GetDefaultConfig>
	usart_config.enableRx = true;
1800a674:	f240 1301 	movw	r3, #257	; 0x101
	usart_config.parityMode = parity_mode;
1800a678:	f88d 5008 	strb.w	r5, [sp, #8]
	usart_config.enableRx = true;
1800a67c:	f8ad 300c 	strh.w	r3, [sp, #12]
	usart_config.baudRate_Bps = config->baud_rate;
1800a680:	68e3      	ldr	r3, [r4, #12]
	USART_Init(config->base, &usart_config, clock_freq);
1800a682:	9a00      	ldr	r2, [sp, #0]
1800a684:	6820      	ldr	r0, [r4, #0]
1800a686:	a901      	add	r1, sp, #4
	usart_config.baudRate_Bps = config->baud_rate;
1800a688:	9301      	str	r3, [sp, #4]
	USART_Init(config->base, &usart_config, clock_freq);
1800a68a:	f000 f8ee 	bl	1800a86a <USART_Init>
	config->irq_config_func(dev);
1800a68e:	4638      	mov	r0, r7
1800a690:	6963      	ldr	r3, [r4, #20]
1800a692:	4798      	blx	r3
	return 0;
1800a694:	e7d7      	b.n	1800a646 <mcux_flexcomm_init+0x18>
		parity_mode = kUSART_ParityOdd;
1800a696:	2503      	movs	r5, #3
1800a698:	e7e9      	b.n	1800a66e <mcux_flexcomm_init+0x40>

1800a69a <mcux_flexcomm_irq_is_pending>:
{
1800a69a:	b508      	push	{r3, lr}
1800a69c:	4601      	mov	r1, r0
	return (mcux_flexcomm_irq_tx_ready(dev)
1800a69e:	f7ff ff84 	bl	1800a5aa <mcux_flexcomm_irq_tx_ready>
		|| mcux_flexcomm_irq_rx_pending(dev));
1800a6a2:	b960      	cbnz	r0, 1800a6be <mcux_flexcomm_irq_is_pending+0x24>
	return (USART_GetEnabledInterrupts(config->base) & mask)
1800a6a4:	684b      	ldr	r3, [r1, #4]
1800a6a6:	681b      	ldr	r3, [r3, #0]
    return base->FIFOINTENSET;
1800a6a8:	f8d3 3e10 	ldr.w	r3, [r3, #3600]	; 0xe10
		&& mcux_flexcomm_irq_rx_full(dev);
1800a6ac:	071b      	lsls	r3, r3, #28
1800a6ae:	d505      	bpl.n	1800a6bc <mcux_flexcomm_irq_is_pending+0x22>
1800a6b0:	4608      	mov	r0, r1
1800a6b2:	f7ff ff92 	bl	1800a5da <mcux_flexcomm_irq_rx_full>
1800a6b6:	3800      	subs	r0, #0
1800a6b8:	bf18      	it	ne
1800a6ba:	2001      	movne	r0, #1
}
1800a6bc:	bd08      	pop	{r3, pc}
		|| mcux_flexcomm_irq_rx_pending(dev));
1800a6be:	2001      	movs	r0, #1
1800a6c0:	e7fc      	b.n	1800a6bc <mcux_flexcomm_irq_is_pending+0x22>

1800a6c2 <CLOCK_AttachClk>:
            pClkSel = CLKCTL_TUPLE_REG(CLKCTL1, connection);
1800a6c2:	f3c0 020b 	ubfx	r2, r0, #0, #12
        if (((((uint32_t)connection) & 0x80000000U) | ((((uint32_t)connection) & 0x8000U))) != 0UL)
1800a6c6:	f010 2f80 	tst.w	r0, #2147516416	; 0x80008000
1800a6ca:	f102 43a0 	add.w	r3, r2, #1342177280	; 0x50000000
            pClkSel = CLKCTL_TUPLE_REG(CLKCTL0, connection);
1800a6ce:	bf0c      	ite	eq
1800a6d0:	f503 5380 	addeq.w	r3, r3, #4096	; 0x1000
            pClkSel = CLKCTL_TUPLE_REG(CLKCTL1, connection);
1800a6d4:	f503 3304 	addne.w	r3, r3, #135168	; 0x21000
        if ((((uint32_t)connection) & 0xfffU) != 0UL)
1800a6d8:	b182      	cbz	r2, 1800a6fc <CLOCK_AttachClk+0x3a>
            *pClkSel = CLKCTL_TUPLE_SEL(connection);
1800a6da:	f3c0 3202 	ubfx	r2, r0, #12, #3
1800a6de:	601a      	str	r2, [r3, #0]
            pClkSel = CLKCTL_TUPLE_REG(CLKCTL1, connection);
1800a6e0:	f3c0 420b 	ubfx	r2, r0, #16, #12
        if (((((uint32_t)connection) & 0x80000000U) | ((((uint32_t)connection) & 0x8000U))) != 0UL)
1800a6e4:	2800      	cmp	r0, #0
1800a6e6:	f102 43a0 	add.w	r3, r2, #1342177280	; 0x50000000
            pClkSel = CLKCTL_TUPLE_REG(CLKCTL1, connection);
1800a6ea:	bfb4      	ite	lt
1800a6ec:	f503 3304 	addlt.w	r3, r3, #135168	; 0x21000
            pClkSel = CLKCTL_TUPLE_REG(CLKCTL0, connection);
1800a6f0:	f503 5380 	addge.w	r3, r3, #4096	; 0x1000
        if ((((uint32_t)connection) & 0xfffU) != 0UL)
1800a6f4:	b112      	cbz	r2, 1800a6fc <CLOCK_AttachClk+0x3a>
            *pClkSel = CLKCTL_TUPLE_SEL(connection);
1800a6f6:	f3c0 7002 	ubfx	r0, r0, #28, #3
1800a6fa:	6018      	str	r0, [r3, #0]
}
1800a6fc:	4770      	bx	lr

1800a6fe <CLOCK_SetClkDiv>:
        pClkDiv = CLKCTL_TUPLE_REG(CLKCTL1, div_name);
1800a6fe:	f3c0 030b 	ubfx	r3, r0, #0, #12
1800a702:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    if ((((uint32_t)div_name) & 0x80000000U) != 0UL)
1800a706:	2800      	cmp	r0, #0
        pClkDiv = CLKCTL_TUPLE_REG(CLKCTL1, div_name);
1800a708:	bfb4      	ite	lt
1800a70a:	f503 3304 	addlt.w	r3, r3, #135168	; 0x21000
        pClkDiv = CLKCTL_TUPLE_REG(CLKCTL0, div_name);
1800a70e:	f503 5380 	addge.w	r3, r3, #4096	; 0x1000
    *pClkDiv |= 1UL << 29U;
1800a712:	681a      	ldr	r2, [r3, #0]
1800a714:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
1800a718:	601a      	str	r2, [r3, #0]
    if (divider == 0U) /*!<  halt */
1800a71a:	b921      	cbnz	r1, 1800a726 <CLOCK_SetClkDiv+0x28>
        *pClkDiv |= 1UL << 30U;
1800a71c:	681a      	ldr	r2, [r3, #0]
1800a71e:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
1800a722:	601a      	str	r2, [r3, #0]
1800a724:	4770      	bx	lr
        *pClkDiv = divider - 1U;
1800a726:	3901      	subs	r1, #1
1800a728:	6019      	str	r1, [r3, #0]
        while (((*pClkDiv) & 0x80000000U) != 0UL)
1800a72a:	681a      	ldr	r2, [r3, #0]
1800a72c:	2a00      	cmp	r2, #0
1800a72e:	dbfc      	blt.n	1800a72a <CLOCK_SetClkDiv+0x2c>
}
1800a730:	4770      	bx	lr

1800a732 <RESET_PeripheralReset>:
 *
 * param peripheral Peripheral to reset. The enum argument contains encoding of reset register
 *                   and reset bit position in the reset register.
 */
void RESET_PeripheralReset(reset_ip_name_t peripheral)
{
1800a732:	b510      	push	{r4, lr}
1800a734:	4604      	mov	r4, r0
    RESET_SetPeripheralReset(peripheral);
1800a736:	f7fb fe4f 	bl	180063d8 <RESET_SetPeripheralReset>
    RESET_ClearPeripheralReset(peripheral);
1800a73a:	4620      	mov	r0, r4
}
1800a73c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RESET_ClearPeripheralReset(peripheral);
1800a740:	f7fb be80 	b.w	18006444 <RESET_ClearPeripheralReset>

1800a744 <PINT_PinInterruptClrStatus>:
 *
 * @retval None.
 */
void PINT_PinInterruptClrStatus(PINT_Type *base, pint_pin_int_t pintr)
{
    uint32_t pinIntMode   = base->ISEL & (1UL << (uint32_t)pintr);
1800a744:	2301      	movs	r3, #1
1800a746:	6802      	ldr	r2, [r0, #0]
1800a748:	fa03 f101 	lsl.w	r1, r3, r1
    uint32_t pinIntStatus = base->IST & (1UL << (uint32_t)pintr);

    /* Edge sensitive and pin interrupt that is currently requesting an interrupt. */
    if ((pinIntMode == 0x0UL) && (pinIntStatus != 0x0UL))
1800a74c:	420a      	tst	r2, r1
    uint32_t pinIntStatus = base->IST & (1UL << (uint32_t)pintr);
1800a74e:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if ((pinIntMode == 0x0UL) && (pinIntStatus != 0x0UL))
1800a750:	d102      	bne.n	1800a758 <PINT_PinInterruptClrStatus+0x14>
1800a752:	4219      	tst	r1, r3
    {
        base->IST = (1UL << (uint32_t)pintr);
1800a754:	bf18      	it	ne
1800a756:	6241      	strne	r1, [r0, #36]	; 0x24
    }
}
1800a758:	4770      	bx	lr

1800a75a <INPUTMUX_AttachSignal>:
    output_id = ((uint32_t)(connection)) & ((1UL << PMUX_SHIFT) - 1U);
1800a75a:	f3c2 0313 	ubfx	r3, r2, #0, #20
    *(volatile uint32_t *)(((uint32_t)base) + pmux_id + (index * 4U)) = output_id;
1800a75e:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    pmux_id = ((uint32_t)(connection)) >> PMUX_SHIFT;
1800a762:	0d12      	lsrs	r2, r2, #20
    *(volatile uint32_t *)(((uint32_t)base) + pmux_id + (index * 4U)) = output_id;
1800a764:	5083      	str	r3, [r0, r2]
}
1800a766:	4770      	bx	lr

1800a768 <OSTIMER_GetCurrentTimerValue>:
 */
static inline uint64_t OSTIMER_GetCurrentTimerRawValue(OSTIMER_Type *base)
{
    uint64_t tmp = 0U;

    tmp = base->EVTIMERL;
1800a768:	6803      	ldr	r3, [r0, #0]
    tmp |= (uint64_t)(base->EVTIMERH) << 32U;
1800a76a:	6842      	ldr	r2, [r0, #4]
1800a76c:	4618      	mov	r0, r3
1800a76e:	4611      	mov	r1, r2
    while (temp != 0U)
1800a770:	ea53 0c02 	orrs.w	ip, r3, r2
1800a774:	d100      	bne.n	1800a778 <OSTIMER_GetCurrentTimerValue+0x10>
}
1800a776:	4770      	bx	lr
        temp >>= 1U;
1800a778:	085b      	lsrs	r3, r3, #1
1800a77a:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
1800a77e:	0852      	lsrs	r2, r2, #1
        gray ^= temp;
1800a780:	4058      	eors	r0, r3
1800a782:	4051      	eors	r1, r2
1800a784:	e7f4      	b.n	1800a770 <OSTIMER_GetCurrentTimerValue+0x8>

1800a786 <OSTIMER_SetMatchValue>:
    return (dec ^ (dec >> 1U));
1800a786:	0851      	lsrs	r1, r2, #1
1800a788:	ea41 71c3 	orr.w	r1, r1, r3, lsl #31
    return OSTIMER_SetMatchRawValue(base, tmp, cb);
1800a78c:	404a      	eors	r2, r1
1800a78e:	ea83 0353 	eor.w	r3, r3, r3, lsr #1
1800a792:	f7fb bf63 	b.w	1800665c <OSTIMER_SetMatchRawValue>

1800a796 <USART_GetDefaultConfig>:
{
    /* Check arguments */
    assert(NULL != config);

    /* Initializes the configure structure to zero. */
    (void)memset(config, 0, sizeof(*config));
1800a796:	2214      	movs	r2, #20
{
1800a798:	b510      	push	{r4, lr}
    (void)memset(config, 0, sizeof(*config));
1800a79a:	2100      	movs	r1, #0
{
1800a79c:	4604      	mov	r4, r0
    (void)memset(config, 0, sizeof(*config));
1800a79e:	f7ff fce3 	bl	1800a168 <memset>

    /* Set always all members ! */
    config->baudRate_Bps              = 115200U;
    config->parityMode                = kUSART_ParityDisabled;
1800a7a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
1800a7a6:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
1800a7aa:	e9c4 2300 	strd	r2, r3, [r4]
    config->stopBitCount              = kUSART_OneStopBit;
    config->bitCountPerChar           = kUSART_8BitsPerChar;
    config->loopback                  = false;
    config->enableRx                  = false;
1800a7ae:	2300      	movs	r3, #0
    config->txWatermark               = kUSART_TxFifo0;
    config->rxWatermark               = kUSART_RxFifo1;
    config->syncMode                  = kUSART_SyncModeDisabled;
    config->enableContinuousSCLK      = false;
    config->clockPolarity             = kUSART_RxSampleOnFallingEdge;
    config->enableHardwareFlowControl = false;
1800a7b0:	e9c4 3302 	strd	r3, r3, [r4, #8]
    config->clockPolarity             = kUSART_RxSampleOnFallingEdge;
1800a7b4:	7423      	strb	r3, [r4, #16]
}
1800a7b6:	bd10      	pop	{r4, pc}

1800a7b8 <USART_SetBaudRate>:
 * retval kStatus_USART_BaudrateNotSupport Baudrate is not support in current clock source.
 * retval kStatus_Success Set baudrate succeed.
 * retval kStatus_InvalidArgument One or more arguments are invalid.
 */
status_t USART_SetBaudRate(USART_Type *base, uint32_t baudrate_Bps, uint32_t srcClock_Hz)
{
1800a7b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint32_t best_diff = (uint32_t)-1, best_osrval = 0xf, best_brgval = (uint32_t)-1;
    uint32_t osrval, brgval, diff, baudrate;

    /* check arguments */
    assert(!((NULL == base) || (0U == baudrate_Bps) || (0U == srcClock_Hz)));
    if ((NULL == base) || (0U == baudrate_Bps) || (0U == srcClock_Hz))
1800a7bc:	4604      	mov	r4, r0
1800a7be:	2800      	cmp	r0, #0
1800a7c0:	d04e      	beq.n	1800a860 <USART_SetBaudRate+0xa8>
1800a7c2:	2900      	cmp	r1, #0
1800a7c4:	d04c      	beq.n	1800a860 <USART_SetBaudRate+0xa8>
1800a7c6:	2a00      	cmp	r2, #0
1800a7c8:	d04a      	beq.n	1800a860 <USART_SetBaudRate+0xa8>
    {
        return kStatus_InvalidArgument;
    }

    /* If synchronous master mode is enabled, only configure the BRG value. */
    if ((base->CFG & USART_CFG_SYNCEN_MASK) != 0U)
1800a7ca:	6803      	ldr	r3, [r0, #0]
1800a7cc:	051b      	lsls	r3, r3, #20
1800a7ce:	d50a      	bpl.n	1800a7e6 <USART_SetBaudRate+0x2e>
    {
        if ((base->CFG & USART_CFG_SYNCMST_MASK) != 0U)
1800a7d0:	6800      	ldr	r0, [r0, #0]
1800a7d2:	f410 4080 	ands.w	r0, r0, #16384	; 0x4000
1800a7d6:	d004      	beq.n	1800a7e2 <USART_SetBaudRate+0x2a>
        {
            brgval    = srcClock_Hz / baudrate_Bps;
1800a7d8:	fbb2 f1f1 	udiv	r1, r2, r1
            base->BRG = brgval - 1U;
1800a7dc:	3901      	subs	r1, #1
1800a7de:	6221      	str	r1, [r4, #32]

        base->OSR = best_osrval;
        base->BRG = best_brgval;
    }

    return kStatus_Success;
1800a7e0:	2000      	movs	r0, #0
}
1800a7e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    uint32_t best_diff = (uint32_t)-1, best_osrval = 0xf, best_brgval = (uint32_t)-1;
1800a7e6:	f04f 35ff 	mov.w	r5, #4294967295
1800a7ea:	270f      	movs	r7, #15
            brgval = (((srcClock_Hz * 10U) / ((osrval + 1U) * baudrate_Bps)) - 5U) / 10U;
1800a7ec:	f04f 080a 	mov.w	r8, #10
    uint32_t best_diff = (uint32_t)-1, best_osrval = 0xf, best_brgval = (uint32_t)-1;
1800a7f0:	46ae      	mov	lr, r5
        for (osrval = best_osrval; osrval >= 8U; osrval--)
1800a7f2:	463e      	mov	r6, r7
            brgval = (((srcClock_Hz * 10U) / ((osrval + 1U) * baudrate_Bps)) - 5U) / 10U;
1800a7f4:	fb08 f902 	mul.w	r9, r8, r2
1800a7f8:	ea4f 1c01 	mov.w	ip, r1, lsl #4
1800a7fc:	fbb9 f0fc 	udiv	r0, r9, ip
1800a800:	3805      	subs	r0, #5
            if (brgval > 0xFFFFU)
1800a802:	f5b0 2f20 	cmp.w	r0, #655360	; 0xa0000
1800a806:	f106 0301 	add.w	r3, r6, #1
1800a80a:	d20e      	bcs.n	1800a82a <USART_SetBaudRate+0x72>
            brgval = (((srcClock_Hz * 10U) / ((osrval + 1U) * baudrate_Bps)) - 5U) / 10U;
1800a80c:	fbb0 f0f8 	udiv	r0, r0, r8
            baudrate = srcClock_Hz / ((osrval + 1U) * (brgval + 1U));
1800a810:	fb00 3303 	mla	r3, r0, r3, r3
1800a814:	fbb2 f3f3 	udiv	r3, r2, r3
            diff     = (baudrate_Bps < baudrate) ? (baudrate - baudrate_Bps) : (baudrate_Bps - baudrate);
1800a818:	4299      	cmp	r1, r3
1800a81a:	bf34      	ite	cc
1800a81c:	1a5b      	subcc	r3, r3, r1
1800a81e:	1acb      	subcs	r3, r1, r3
            if (diff < best_diff)
1800a820:	4573      	cmp	r3, lr
                best_brgval = brgval;
1800a822:	bf3e      	ittt	cc
1800a824:	4605      	movcc	r5, r0
            if (diff < best_diff)
1800a826:	4637      	movcc	r7, r6
1800a828:	469e      	movcc	lr, r3
        for (osrval = best_osrval; osrval >= 8U; osrval--)
1800a82a:	3e01      	subs	r6, #1
1800a82c:	2e07      	cmp	r6, #7
1800a82e:	ebac 0c01 	sub.w	ip, ip, r1
1800a832:	d1e3      	bne.n	1800a7fc <USART_SetBaudRate+0x44>
        baudrate = srcClock_Hz / ((best_osrval + 1U) * (best_brgval + 1U));
1800a834:	1c6b      	adds	r3, r5, #1
1800a836:	fb07 3303 	mla	r3, r7, r3, r3
1800a83a:	fbb2 f2f3 	udiv	r2, r2, r3
        if (diff > ((baudrate_Bps / 100U) * 3U))
1800a83e:	2364      	movs	r3, #100	; 0x64
        diff     = (baudrate_Bps < baudrate) ? (baudrate - baudrate_Bps) : (baudrate_Bps - baudrate);
1800a840:	4291      	cmp	r1, r2
1800a842:	bf34      	ite	cc
1800a844:	1a52      	subcc	r2, r2, r1
1800a846:	1a8a      	subcs	r2, r1, r2
        if (diff > ((baudrate_Bps / 100U) * 3U))
1800a848:	fbb1 f1f3 	udiv	r1, r1, r3
1800a84c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
1800a850:	4291      	cmp	r1, r2
1800a852:	d307      	bcc.n	1800a864 <USART_SetBaudRate+0xac>
        if (best_brgval > 0xFFFFU)
1800a854:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
1800a858:	d204      	bcs.n	1800a864 <USART_SetBaudRate+0xac>
        base->OSR = best_osrval;
1800a85a:	62a7      	str	r7, [r4, #40]	; 0x28
        base->BRG = best_brgval;
1800a85c:	6225      	str	r5, [r4, #32]
1800a85e:	e7bf      	b.n	1800a7e0 <USART_SetBaudRate+0x28>
        return kStatus_InvalidArgument;
1800a860:	2004      	movs	r0, #4
1800a862:	e7be      	b.n	1800a7e2 <USART_SetBaudRate+0x2a>
            return kStatus_USART_BaudrateNotSupport;
1800a864:	f241 6051 	movw	r0, #5713	; 0x1651
1800a868:	e7bb      	b.n	1800a7e2 <USART_SetBaudRate+0x2a>

1800a86a <USART_Init>:
{
1800a86a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1800a86c:	460d      	mov	r5, r1
1800a86e:	4617      	mov	r7, r2
    if ((NULL == base) || (NULL == config) || (0U == srcClock_Hz))
1800a870:	4604      	mov	r4, r0
1800a872:	2800      	cmp	r0, #0
1800a874:	f000 808d 	beq.w	1800a992 <USART_Init+0x128>
1800a878:	2900      	cmp	r1, #0
1800a87a:	f000 808a 	beq.w	1800a992 <USART_Init+0x128>
1800a87e:	2a00      	cmp	r2, #0
1800a880:	f000 8087 	beq.w	1800a992 <USART_Init+0x128>
    result = FLEXCOMM_Init(base, FLEXCOMM_PERIPH_USART);
1800a884:	2101      	movs	r1, #1
1800a886:	f7fb ff41 	bl	1800670c <FLEXCOMM_Init>
    if (kStatus_Success != result)
1800a88a:	4606      	mov	r6, r0
1800a88c:	2800      	cmp	r0, #0
1800a88e:	d172      	bne.n	1800a976 <USART_Init+0x10c>
    if (config->enableTx)
1800a890:	7a6b      	ldrb	r3, [r5, #9]
1800a892:	b1d3      	cbz	r3, 1800a8ca <USART_Init+0x60>
        base->FIFOCFG |= USART_FIFOCFG_EMPTYTX_MASK | USART_FIFOCFG_ENABLETX_MASK;
1800a894:	f8d4 3e00 	ldr.w	r3, [r4, #3584]	; 0xe00
1800a898:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
1800a89c:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
        base->FIFOTRIG &= ~(USART_FIFOTRIG_TXLVL_MASK);
1800a8a0:	f8d4 3e08 	ldr.w	r3, [r4, #3592]	; 0xe08
1800a8a4:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
1800a8a8:	f8c4 3e08 	str.w	r3, [r4, #3592]	; 0xe08
        base->FIFOTRIG |= USART_FIFOTRIG_TXLVL(config->txWatermark);
1800a8ac:	7b6b      	ldrb	r3, [r5, #13]
1800a8ae:	f8d4 2e08 	ldr.w	r2, [r4, #3592]	; 0xe08
1800a8b2:	021b      	lsls	r3, r3, #8
1800a8b4:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
1800a8b8:	4313      	orrs	r3, r2
1800a8ba:	f8c4 3e08 	str.w	r3, [r4, #3592]	; 0xe08
        base->FIFOTRIG |= USART_FIFOTRIG_TXLVLENA_MASK;
1800a8be:	f8d4 3e08 	ldr.w	r3, [r4, #3592]	; 0xe08
1800a8c2:	f043 0301 	orr.w	r3, r3, #1
1800a8c6:	f8c4 3e08 	str.w	r3, [r4, #3592]	; 0xe08
    if (config->enableRx)
1800a8ca:	7a2b      	ldrb	r3, [r5, #8]
1800a8cc:	b1d3      	cbz	r3, 1800a904 <USART_Init+0x9a>
        base->FIFOCFG |= USART_FIFOCFG_EMPTYRX_MASK | USART_FIFOCFG_ENABLERX_MASK;
1800a8ce:	f8d4 3e00 	ldr.w	r3, [r4, #3584]	; 0xe00
1800a8d2:	f043 1302 	orr.w	r3, r3, #131074	; 0x20002
1800a8d6:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
        base->FIFOTRIG &= ~(USART_FIFOTRIG_RXLVL_MASK);
1800a8da:	f8d4 3e08 	ldr.w	r3, [r4, #3592]	; 0xe08
1800a8de:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
1800a8e2:	f8c4 3e08 	str.w	r3, [r4, #3592]	; 0xe08
        base->FIFOTRIG |= USART_FIFOTRIG_RXLVL(config->rxWatermark);
1800a8e6:	7bab      	ldrb	r3, [r5, #14]
1800a8e8:	f8d4 2e08 	ldr.w	r2, [r4, #3592]	; 0xe08
1800a8ec:	041b      	lsls	r3, r3, #16
1800a8ee:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
1800a8f2:	4313      	orrs	r3, r2
1800a8f4:	f8c4 3e08 	str.w	r3, [r4, #3592]	; 0xe08
        base->FIFOTRIG |= USART_FIFOTRIG_RXLVLENA_MASK;
1800a8f8:	f8d4 3e08 	ldr.w	r3, [r4, #3592]	; 0xe08
1800a8fc:	f043 0302 	orr.w	r3, r3, #2
1800a900:	f8c4 3e08 	str.w	r3, [r4, #3592]	; 0xe08
                USART_CFG_CLKPOL(config->clockPolarity) | USART_CFG_MODE32K(config->enableMode32k) |
1800a904:	7aea      	ldrb	r2, [r5, #11]
                USART_CFG_SYNCEN((uint32_t)config->syncMode >> 1) | USART_CFG_SYNCMST((uint8_t)config->syncMode) |
1800a906:	7be9      	ldrb	r1, [r5, #15]
                USART_CFG_DATALEN(config->bitCountPerChar) | USART_CFG_LOOP(config->loopback) |
1800a908:	79e8      	ldrb	r0, [r5, #7]
                USART_CFG_CLKPOL(config->clockPolarity) | USART_CFG_MODE32K(config->enableMode32k) |
1800a90a:	01d3      	lsls	r3, r2, #7
1800a90c:	ea43 33c0 	orr.w	r3, r3, r0, lsl #15
                USART_CFG_SYNCEN((uint32_t)config->syncMode >> 1) | USART_CFG_SYNCMST((uint8_t)config->syncMode) |
1800a910:	0288      	lsls	r0, r1, #10
1800a912:	f400 6000 	and.w	r0, r0, #2048	; 0x800
                USART_CFG_CLKPOL(config->clockPolarity) | USART_CFG_MODE32K(config->enableMode32k) |
1800a916:	4303      	orrs	r3, r0
                USART_CFG_CTSEN(config->enableHardwareFlowControl) | USART_CFG_ENABLE_MASK;
1800a918:	7b28      	ldrb	r0, [r5, #12]
                USART_CFG_SYNCEN((uint32_t)config->syncMode >> 1) | USART_CFG_SYNCMST((uint8_t)config->syncMode) |
1800a91a:	0389      	lsls	r1, r1, #14
                USART_CFG_CLKPOL(config->clockPolarity) | USART_CFG_MODE32K(config->enableMode32k) |
1800a91c:	ea43 2340 	orr.w	r3, r3, r0, lsl #9
    base->CFG = USART_CFG_PARITYSEL(config->parityMode) | USART_CFG_STOPLEN(config->stopBitCount) |
1800a920:	7928      	ldrb	r0, [r5, #4]
                USART_CFG_SYNCEN((uint32_t)config->syncMode >> 1) | USART_CFG_SYNCMST((uint8_t)config->syncMode) |
1800a922:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
    base->CFG = USART_CFG_PARITYSEL(config->parityMode) | USART_CFG_STOPLEN(config->stopBitCount) |
1800a926:	0100      	lsls	r0, r0, #4
1800a928:	f000 0030 	and.w	r0, r0, #48	; 0x30
                USART_CFG_CLKPOL(config->clockPolarity) | USART_CFG_MODE32K(config->enableMode32k) |
1800a92c:	4303      	orrs	r3, r0
    base->CFG = USART_CFG_PARITYSEL(config->parityMode) | USART_CFG_STOPLEN(config->stopBitCount) |
1800a92e:	7968      	ldrb	r0, [r5, #5]
1800a930:	0180      	lsls	r0, r0, #6
1800a932:	f000 0040 	and.w	r0, r0, #64	; 0x40
                USART_CFG_CLKPOL(config->clockPolarity) | USART_CFG_MODE32K(config->enableMode32k) |
1800a936:	4303      	orrs	r3, r0
                USART_CFG_DATALEN(config->bitCountPerChar) | USART_CFG_LOOP(config->loopback) |
1800a938:	79a8      	ldrb	r0, [r5, #6]
1800a93a:	0080      	lsls	r0, r0, #2
1800a93c:	f000 000c 	and.w	r0, r0, #12
                USART_CFG_CLKPOL(config->clockPolarity) | USART_CFG_MODE32K(config->enableMode32k) |
1800a940:	4303      	orrs	r3, r0
1800a942:	430b      	orrs	r3, r1
1800a944:	7c29      	ldrb	r1, [r5, #16]
1800a946:	0309      	lsls	r1, r1, #12
1800a948:	f401 5180 	and.w	r1, r1, #4096	; 0x1000
1800a94c:	430b      	orrs	r3, r1
                USART_CFG_CTSEN(config->enableHardwareFlowControl) | USART_CFG_ENABLE_MASK;
1800a94e:	f043 0301 	orr.w	r3, r3, #1
        if ((9600U % config->baudRate_Bps) == 0U)
1800a952:	6829      	ldr	r1, [r5, #0]
    base->CFG = USART_CFG_PARITYSEL(config->parityMode) | USART_CFG_STOPLEN(config->stopBitCount) |
1800a954:	6023      	str	r3, [r4, #0]
    if (config->enableMode32k)
1800a956:	b182      	cbz	r2, 1800a97a <USART_Init+0x110>
        if ((9600U % config->baudRate_Bps) == 0U)
1800a958:	f44f 5316 	mov.w	r3, #9600	; 0x2580
1800a95c:	fbb3 f3f1 	udiv	r3, r3, r1
1800a960:	4359      	muls	r1, r3
1800a962:	f5b1 5f16 	cmp.w	r1, #9600	; 0x2580
1800a966:	d116      	bne.n	1800a996 <USART_Init+0x12c>
            base->BRG = 9600U / config->baudRate_Bps;
1800a968:	6223      	str	r3, [r4, #32]
    if (enable)
1800a96a:	7aab      	ldrb	r3, [r5, #10]
1800a96c:	b16b      	cbz	r3, 1800a98a <USART_Init+0x120>
        base->CTL |= USART_CTL_CC_MASK;
1800a96e:	6863      	ldr	r3, [r4, #4]
1800a970:	f443 7380 	orr.w	r3, r3, #256	; 0x100
        base->CTL &= ~USART_CTL_CC_MASK;
1800a974:	6063      	str	r3, [r4, #4]
}
1800a976:	4630      	mov	r0, r6
1800a978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        result = USART_SetBaudRate(base, config->baudRate_Bps, srcClock_Hz);
1800a97a:	463a      	mov	r2, r7
1800a97c:	4620      	mov	r0, r4
1800a97e:	f7ff ff1b 	bl	1800a7b8 <USART_SetBaudRate>
        if (kStatus_Success != result)
1800a982:	2800      	cmp	r0, #0
1800a984:	d0f1      	beq.n	1800a96a <USART_Init+0x100>
1800a986:	4606      	mov	r6, r0
1800a988:	e7f5      	b.n	1800a976 <USART_Init+0x10c>
1800a98a:	6863      	ldr	r3, [r4, #4]
1800a98c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
1800a990:	e7f0      	b.n	1800a974 <USART_Init+0x10a>
        return kStatus_InvalidArgument;
1800a992:	2604      	movs	r6, #4
1800a994:	e7ef      	b.n	1800a976 <USART_Init+0x10c>
            return kStatus_USART_BaudrateNotSupport;
1800a996:	f241 6651 	movw	r6, #5713	; 0x1651
1800a99a:	e7ec      	b.n	1800a976 <USART_Init+0x10c>

1800a99c <z_device_state_init>:
}
1800a99c:	4770      	bx	lr

1800a99e <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
1800a99e:	b138      	cbz	r0, 1800a9b0 <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
1800a9a0:	68c3      	ldr	r3, [r0, #12]
1800a9a2:	8818      	ldrh	r0, [r3, #0]
1800a9a4:	f3c0 0008 	ubfx	r0, r0, #0, #9
1800a9a8:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
1800a9ac:	4258      	negs	r0, r3
1800a9ae:	4158      	adcs	r0, r3
}
1800a9b0:	4770      	bx	lr

1800a9b2 <arch_system_halt>:
	__asm__ volatile(
1800a9b2:	f04f 0220 	mov.w	r2, #32
1800a9b6:	f3ef 8311 	mrs	r3, BASEPRI
1800a9ba:	f382 8812 	msr	BASEPRI_MAX, r2
1800a9be:	f3bf 8f6f 	isb	sy
	for (;;) {
1800a9c2:	e7fe      	b.n	1800a9c2 <arch_system_halt+0x10>

1800a9c4 <k_mem_slab_init>:
{
1800a9c4:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
1800a9c6:	2400      	movs	r4, #0
1800a9c8:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
1800a9ca:	ea41 0402 	orr.w	r4, r1, r2
1800a9ce:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
1800a9d2:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
1800a9d6:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
1800a9d8:	d10c      	bne.n	1800a9f4 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
1800a9da:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
1800a9dc:	42a3      	cmp	r3, r4
1800a9de:	d103      	bne.n	1800a9e8 <k_mem_slab_init+0x24>
1800a9e0:	e9c0 0000 	strd	r0, r0, [r0]
}
1800a9e4:	2000      	movs	r0, #0
}
1800a9e6:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
1800a9e8:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
1800a9ea:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
1800a9ec:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
1800a9ee:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
1800a9f0:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
1800a9f2:	e7f3      	b.n	1800a9dc <k_mem_slab_init+0x18>
		return -EINVAL;
1800a9f4:	f06f 0015 	mvn.w	r0, #21
	return rc;
1800a9f8:	e7f5      	b.n	1800a9e6 <k_mem_slab_init+0x22>

1800a9fa <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
1800a9fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1800a9fc:	4604      	mov	r4, r0
1800a9fe:	460d      	mov	r5, r1
1800aa00:	f04f 0320 	mov.w	r3, #32
1800aa04:	f3ef 8611 	mrs	r6, BASEPRI
1800aa08:	f383 8812 	msr	BASEPRI_MAX, r3
1800aa0c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
1800aa10:	6947      	ldr	r7, [r0, #20]
1800aa12:	b97f      	cbnz	r7, 1800aa34 <k_mem_slab_free+0x3a>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
1800aa14:	f000 f934 	bl	1800ac80 <z_unpend_first_thread>

		if (pending_thread != NULL) {
1800aa18:	b160      	cbz	r0, 1800aa34 <k_mem_slab_free+0x3a>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
1800aa1a:	682a      	ldr	r2, [r5, #0]
1800aa1c:	f8c0 70b0 	str.w	r7, [r0, #176]	; 0xb0
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
1800aa20:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
1800aa22:	f000 f8bc 	bl	1800ab9e <z_ready_thread>
			z_reschedule(&slab->lock, key);
1800aa26:	4631      	mov	r1, r6
1800aa28:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
1800aa2c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
1800aa30:	f7fc bc0a 	b.w	18007248 <z_reschedule>
	**(char ***) mem = slab->free_list;
1800aa34:	682b      	ldr	r3, [r5, #0]
1800aa36:	6962      	ldr	r2, [r4, #20]
1800aa38:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
1800aa3a:	682b      	ldr	r3, [r5, #0]
1800aa3c:	6163      	str	r3, [r4, #20]
	slab->num_used--;
1800aa3e:	69a3      	ldr	r3, [r4, #24]
1800aa40:	3b01      	subs	r3, #1
1800aa42:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
1800aa44:	f386 8811 	msr	BASEPRI, r6
1800aa48:	f3bf 8f6f 	isb	sy
}
1800aa4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

1800aa4e <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1800aa4e:	f3ef 8005 	mrs	r0, IPSR
}
1800aa52:	3800      	subs	r0, #0
1800aa54:	bf18      	it	ne
1800aa56:	2001      	movne	r0, #1
1800aa58:	4770      	bx	lr

1800aa5a <k_thread_name_get>:
}
1800aa5a:	3078      	adds	r0, #120	; 0x78
1800aa5c:	4770      	bx	lr

1800aa5e <z_impl_k_thread_start>:
	z_sched_start(thread);
1800aa5e:	f7fc bce9 	b.w	18007434 <z_sched_start>

1800aa62 <z_impl_k_thread_stack_space_get>:
int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
	size_t size = thread->stack_info.size;
	size_t unused = 0;
1800aa62:	2300      	movs	r3, #0
{
1800aa64:	b510      	push	{r4, lr}
	size_t size = thread->stack_info.size;
1800aa66:	e9d0 4227 	ldrd	r4, r2, [r0, #156]	; 0x9c
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
1800aa6a:	4293      	cmp	r3, r2
1800aa6c:	d102      	bne.n	1800aa74 <z_impl_k_thread_stack_space_get+0x12>
	}

	*unused_ptr = unused;

	return 0;
}
1800aa6e:	2000      	movs	r0, #0
	*unused_ptr = unused;
1800aa70:	600b      	str	r3, [r1, #0]
}
1800aa72:	bd10      	pop	{r4, pc}
		if ((checked_stack[i]) == 0xaaU) {
1800aa74:	5ce0      	ldrb	r0, [r4, r3]
1800aa76:	28aa      	cmp	r0, #170	; 0xaa
1800aa78:	d1f9      	bne.n	1800aa6e <z_impl_k_thread_stack_space_get+0xc>
			unused++;
1800aa7a:	3301      	adds	r3, #1
	for (size_t i = 0; i < size; i++) {
1800aa7c:	e7f5      	b.n	1800aa6a <z_impl_k_thread_stack_space_get+0x8>

1800aa7e <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
1800aa7e:	b508      	push	{r3, lr}
	__asm__ volatile(
1800aa80:	f04f 0220 	mov.w	r2, #32
1800aa84:	f3ef 8311 	mrs	r3, BASEPRI
1800aa88:	f382 8812 	msr	BASEPRI_MAX, r2
1800aa8c:	f3bf 8f6f 	isb	sy
	arch_cpu_idle();
1800aa90:	f7fa f868 	bl	18004b64 <arch_cpu_idle>
1800aa94:	e7f4      	b.n	1800aa80 <idle+0x2>

1800aa96 <z_impl_k_msgq_peek>:
}
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
1800aa96:	4603      	mov	r3, r0
1800aa98:	b510      	push	{r4, lr}
1800aa9a:	4608      	mov	r0, r1
1800aa9c:	f04f 0220 	mov.w	r2, #32
1800aaa0:	f3ef 8411 	mrs	r4, BASEPRI
1800aaa4:	f382 8812 	msr	BASEPRI_MAX, r2
1800aaa8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);

	if (msgq->used_msgs > 0U) {
1800aaac:	6a1a      	ldr	r2, [r3, #32]
1800aaae:	b14a      	cbz	r2, 1800aac4 <z_impl_k_msgq_peek+0x2e>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
1800aab0:	689a      	ldr	r2, [r3, #8]
1800aab2:	6999      	ldr	r1, [r3, #24]
1800aab4:	f7ff fb4d 	bl	1800a152 <memcpy>
		result = 0;
1800aab8:	2000      	movs	r0, #0
	__asm__ volatile(
1800aaba:	f384 8811 	msr	BASEPRI, r4
1800aabe:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
1800aac2:	bd10      	pop	{r4, pc}
		result = -ENOMSG;
1800aac4:	f06f 0022 	mvn.w	r0, #34	; 0x22
1800aac8:	e7f7      	b.n	1800aaba <z_impl_k_msgq_peek+0x24>

1800aaca <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
1800aaca:	f990 300e 	ldrsb.w	r3, [r0, #14]
1800aace:	428b      	cmp	r3, r1
1800aad0:	d001      	beq.n	1800aad6 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
1800aad2:	f7fc bd1f 	b.w	18007514 <z_set_prio>
}
1800aad6:	2000      	movs	r0, #0
1800aad8:	4770      	bx	lr

1800aada <z_impl_k_mutex_init>:
{
1800aada:	4603      	mov	r3, r0
	mutex->owner = NULL;
1800aadc:	2000      	movs	r0, #0
1800aade:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
1800aae2:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
1800aae6:	4770      	bx	lr

1800aae8 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
1800aae8:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
1800aaec:	6013      	str	r3, [r2, #0]
	next->prev = prev;
1800aaee:	605a      	str	r2, [r3, #4]
	node->next = NULL;
1800aaf0:	2300      	movs	r3, #0
	node->prev = NULL;
1800aaf2:	e9c0 3300 	strd	r3, r3, [r0]
}
1800aaf6:	4770      	bx	lr

1800aaf8 <unpend_thread_no_timeout>:
{
1800aaf8:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
1800aafa:	f7ff fff5 	bl	1800aae8 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
1800aafe:	7b43      	ldrb	r3, [r0, #13]
1800ab00:	f023 0302 	bic.w	r3, r3, #2
1800ab04:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
1800ab06:	2300      	movs	r3, #0
1800ab08:	6083      	str	r3, [r0, #8]
}
1800ab0a:	bd08      	pop	{r3, pc}

1800ab0c <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
1800ab0c:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
1800ab10:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
1800ab14:	4283      	cmp	r3, r0
		return b2 - b1;
1800ab16:	bf14      	ite	ne
1800ab18:	1ac0      	subne	r0, r0, r3
	return 0;
1800ab1a:	2000      	moveq	r0, #0
}
1800ab1c:	4770      	bx	lr

1800ab1e <z_unpend_thread_no_timeout>:
{
1800ab1e:	b508      	push	{r3, lr}
	__asm__ volatile(
1800ab20:	f04f 0320 	mov.w	r3, #32
1800ab24:	f3ef 8111 	mrs	r1, BASEPRI
1800ab28:	f383 8812 	msr	BASEPRI_MAX, r3
1800ab2c:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
1800ab30:	f7ff ffe2 	bl	1800aaf8 <unpend_thread_no_timeout>
	__asm__ volatile(
1800ab34:	f381 8811 	msr	BASEPRI, r1
1800ab38:	f3bf 8f6f 	isb	sy
}
1800ab3c:	bd08      	pop	{r3, pc}

1800ab3e <z_unpend_thread>:
{
1800ab3e:	b510      	push	{r4, lr}
	__asm__ volatile(
1800ab40:	f04f 0320 	mov.w	r3, #32
1800ab44:	f3ef 8411 	mrs	r4, BASEPRI
1800ab48:	f383 8812 	msr	BASEPRI_MAX, r3
1800ab4c:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
1800ab50:	f7ff ffd2 	bl	1800aaf8 <unpend_thread_no_timeout>
	__asm__ volatile(
1800ab54:	f384 8811 	msr	BASEPRI, r4
1800ab58:	f3bf 8f6f 	isb	sy
}
1800ab5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
1800ab60:	3018      	adds	r0, #24
1800ab62:	f000 b8c3 	b.w	1800acec <z_abort_timeout>

1800ab66 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
1800ab66:	4603      	mov	r3, r0
1800ab68:	b920      	cbnz	r0, 1800ab74 <z_reschedule_irqlock+0xe>
1800ab6a:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
1800ab6e:	b90a      	cbnz	r2, 1800ab74 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
1800ab70:	f7fa b898 	b.w	18004ca4 <arch_swap>
1800ab74:	f383 8811 	msr	BASEPRI, r3
1800ab78:	f3bf 8f6f 	isb	sy
}
1800ab7c:	4770      	bx	lr

1800ab7e <z_reschedule_unlocked>:
	__asm__ volatile(
1800ab7e:	f04f 0320 	mov.w	r3, #32
1800ab82:	f3ef 8011 	mrs	r0, BASEPRI
1800ab86:	f383 8812 	msr	BASEPRI_MAX, r3
1800ab8a:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
1800ab8e:	f7ff bfea 	b.w	1800ab66 <z_reschedule_irqlock>

1800ab92 <z_priq_dumb_best>:
{
1800ab92:	4603      	mov	r3, r0
	return list->head == list;
1800ab94:	6800      	ldr	r0, [r0, #0]
}
1800ab96:	4283      	cmp	r3, r0
1800ab98:	bf08      	it	eq
1800ab9a:	2000      	moveq	r0, #0
1800ab9c:	4770      	bx	lr

1800ab9e <z_ready_thread>:
{
1800ab9e:	b510      	push	{r4, lr}
1800aba0:	f04f 0320 	mov.w	r3, #32
1800aba4:	f3ef 8411 	mrs	r4, BASEPRI
1800aba8:	f383 8812 	msr	BASEPRI_MAX, r3
1800abac:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
1800abb0:	f7fc fc0a 	bl	180073c8 <ready_thread>
	__asm__ volatile(
1800abb4:	f384 8811 	msr	BASEPRI, r4
1800abb8:	f3bf 8f6f 	isb	sy
}
1800abbc:	bd10      	pop	{r4, pc}

1800abbe <z_thread_timeout>:
{
1800abbe:	4601      	mov	r1, r0
1800abc0:	b510      	push	{r4, lr}
	__asm__ volatile(
1800abc2:	f04f 0320 	mov.w	r3, #32
1800abc6:	f3ef 8411 	mrs	r4, BASEPRI
1800abca:	f383 8812 	msr	BASEPRI_MAX, r3
1800abce:	f3bf 8f6f 	isb	sy
		if (!killed) {
1800abd2:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
1800abd6:	f013 0f28 	tst.w	r3, #40	; 0x28
1800abda:	d10d      	bne.n	1800abf8 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
1800abdc:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
1800abe0:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
1800abe2:	b10b      	cbz	r3, 1800abe8 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
1800abe4:	f7ff ff88 	bl	1800aaf8 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
1800abe8:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
1800abec:	f023 0314 	bic.w	r3, r3, #20
1800abf0:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
1800abf4:	f7fc fbe8 	bl	180073c8 <ready_thread>
	__asm__ volatile(
1800abf8:	f384 8811 	msr	BASEPRI, r4
1800abfc:	f3bf 8f6f 	isb	sy
}
1800ac00:	bd10      	pop	{r4, pc}

1800ac02 <add_to_waitq_locked>:
{
1800ac02:	b538      	push	{r3, r4, r5, lr}
1800ac04:	4604      	mov	r4, r0
1800ac06:	460d      	mov	r5, r1
	unready_thread(thread);
1800ac08:	f7fc fc32 	bl	18007470 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
1800ac0c:	7b63      	ldrb	r3, [r4, #13]
1800ac0e:	f043 0302 	orr.w	r3, r3, #2
1800ac12:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
1800ac14:	b195      	cbz	r5, 1800ac3c <add_to_waitq_locked+0x3a>
1800ac16:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
1800ac18:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1800ac1a:	429d      	cmp	r5, r3
1800ac1c:	d015      	beq.n	1800ac4a <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1800ac1e:	b1a3      	cbz	r3, 1800ac4a <add_to_waitq_locked+0x48>
	int32_t b1 = thread_1->base.prio;
1800ac20:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
1800ac24:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
1800ac28:	4291      	cmp	r1, r2
1800ac2a:	d008      	beq.n	1800ac3e <add_to_waitq_locked+0x3c>
		return b2 - b1;
1800ac2c:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
1800ac2e:	2a00      	cmp	r2, #0
1800ac30:	dd05      	ble.n	1800ac3e <add_to_waitq_locked+0x3c>
	sys_dnode_t *const prev = successor->prev;
1800ac32:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
1800ac34:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
1800ac38:	6014      	str	r4, [r2, #0]
	successor->prev = node;
1800ac3a:	605c      	str	r4, [r3, #4]
}
1800ac3c:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
1800ac3e:	686a      	ldr	r2, [r5, #4]
1800ac40:	4293      	cmp	r3, r2
1800ac42:	d002      	beq.n	1800ac4a <add_to_waitq_locked+0x48>
1800ac44:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1800ac46:	2b00      	cmp	r3, #0
1800ac48:	d1ec      	bne.n	1800ac24 <add_to_waitq_locked+0x22>
	sys_dnode_t *const tail = list->tail;
1800ac4a:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
1800ac4c:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
1800ac50:	601c      	str	r4, [r3, #0]
	list->tail = node;
1800ac52:	606c      	str	r4, [r5, #4]
}
1800ac54:	e7f2      	b.n	1800ac3c <add_to_waitq_locked+0x3a>

1800ac56 <z_unpend1_no_timeout>:
{
1800ac56:	b510      	push	{r4, lr}
	__asm__ volatile(
1800ac58:	f04f 0320 	mov.w	r3, #32
1800ac5c:	f3ef 8411 	mrs	r4, BASEPRI
1800ac60:	f383 8812 	msr	BASEPRI_MAX, r3
1800ac64:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
1800ac68:	f7ff ff93 	bl	1800ab92 <z_priq_dumb_best>
		if (thread != NULL) {
1800ac6c:	4601      	mov	r1, r0
1800ac6e:	b108      	cbz	r0, 1800ac74 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
1800ac70:	f7ff ff42 	bl	1800aaf8 <unpend_thread_no_timeout>
	__asm__ volatile(
1800ac74:	f384 8811 	msr	BASEPRI, r4
1800ac78:	f3bf 8f6f 	isb	sy
}
1800ac7c:	4608      	mov	r0, r1
1800ac7e:	bd10      	pop	{r4, pc}

1800ac80 <z_unpend_first_thread>:
{
1800ac80:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
1800ac82:	f04f 0320 	mov.w	r3, #32
1800ac86:	f3ef 8511 	mrs	r5, BASEPRI
1800ac8a:	f383 8812 	msr	BASEPRI_MAX, r3
1800ac8e:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
1800ac92:	f7ff ff7e 	bl	1800ab92 <z_priq_dumb_best>
		if (thread != NULL) {
1800ac96:	4604      	mov	r4, r0
1800ac98:	b120      	cbz	r0, 1800aca4 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
1800ac9a:	f7ff ff2d 	bl	1800aaf8 <unpend_thread_no_timeout>
1800ac9e:	3018      	adds	r0, #24
1800aca0:	f000 f824 	bl	1800acec <z_abort_timeout>
	__asm__ volatile(
1800aca4:	f385 8811 	msr	BASEPRI, r5
1800aca8:	f3bf 8f6f 	isb	sy
}
1800acac:	4620      	mov	r0, r4
1800acae:	bd38      	pop	{r3, r4, r5, pc}

1800acb0 <z_sched_wake>:
{
1800acb0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
1800acb2:	f04f 0320 	mov.w	r3, #32
1800acb6:	f3ef 8511 	mrs	r5, BASEPRI
1800acba:	f383 8812 	msr	BASEPRI_MAX, r3
1800acbe:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
1800acc2:	f7ff ff66 	bl	1800ab92 <z_priq_dumb_best>
		if (thread != NULL) {
1800acc6:	4604      	mov	r4, r0
1800acc8:	b158      	cbz	r0, 1800ace2 <z_sched_wake+0x32>
1800acca:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
1800acce:	6142      	str	r2, [r0, #20]
			unpend_thread_no_timeout(thread);
1800acd0:	f7ff ff12 	bl	1800aaf8 <unpend_thread_no_timeout>
1800acd4:	3018      	adds	r0, #24
1800acd6:	f000 f809 	bl	1800acec <z_abort_timeout>
			ready_thread(thread);
1800acda:	4620      	mov	r0, r4
1800acdc:	f7fc fb74 	bl	180073c8 <ready_thread>
			ret = true;
1800ace0:	2001      	movs	r0, #1
	__asm__ volatile(
1800ace2:	f385 8811 	msr	BASEPRI, r5
1800ace6:	f3bf 8f6f 	isb	sy
}
1800acea:	bd38      	pop	{r3, r4, r5, pc}

1800acec <z_abort_timeout>:
{
1800acec:	b510      	push	{r4, lr}
	__asm__ volatile(
1800acee:	f04f 0220 	mov.w	r2, #32
1800acf2:	f3ef 8411 	mrs	r4, BASEPRI
1800acf6:	f382 8812 	msr	BASEPRI_MAX, r2
1800acfa:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
1800acfe:	6803      	ldr	r3, [r0, #0]
1800ad00:	b13b      	cbz	r3, 1800ad12 <z_abort_timeout+0x26>
			remove_timeout(to);
1800ad02:	f7fc fe13 	bl	1800792c <remove_timeout>
			ret = 0;
1800ad06:	2000      	movs	r0, #0
	__asm__ volatile(
1800ad08:	f384 8811 	msr	BASEPRI, r4
1800ad0c:	f3bf 8f6f 	isb	sy
}
1800ad10:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
1800ad12:	f06f 0015 	mvn.w	r0, #21
1800ad16:	e7f7      	b.n	1800ad08 <z_abort_timeout+0x1c>

1800ad18 <z_set_timeout_expiry>:
{
1800ad18:	b570      	push	{r4, r5, r6, lr}
1800ad1a:	4604      	mov	r4, r0
1800ad1c:	460d      	mov	r5, r1
	__asm__ volatile(
1800ad1e:	f04f 0320 	mov.w	r3, #32
1800ad22:	f3ef 8611 	mrs	r6, BASEPRI
1800ad26:	f383 8812 	msr	BASEPRI_MAX, r3
1800ad2a:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
1800ad2e:	f7fc fdd5 	bl	180078dc <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
1800ad32:	2801      	cmp	r0, #1
1800ad34:	dd05      	ble.n	1800ad42 <z_set_timeout_expiry+0x2a>
1800ad36:	42a0      	cmp	r0, r4
1800ad38:	db03      	blt.n	1800ad42 <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
1800ad3a:	4629      	mov	r1, r5
1800ad3c:	4620      	mov	r0, r4
1800ad3e:	f7fa ff63 	bl	18005c08 <sys_clock_set_timeout>
	__asm__ volatile(
1800ad42:	f386 8811 	msr	BASEPRI, r6
1800ad46:	f3bf 8f6f 	isb	sy
}
1800ad4a:	bd70      	pop	{r4, r5, r6, pc}

1800ad4c <sys_clock_tick_get_32>:
{
1800ad4c:	b508      	push	{r3, lr}
	return (uint32_t)sys_clock_tick_get();
1800ad4e:	f7fc fedd 	bl	18007b0c <sys_clock_tick_get>
}
1800ad52:	bd08      	pop	{r3, pc}

1800ad54 <z_impl_k_uptime_ticks>:
	return sys_clock_tick_get();
1800ad54:	f7fc beda 	b.w	18007b0c <sys_clock_tick_get>

1800ad58 <k_timer_init>:
	timer->status = 0U;
1800ad58:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
1800ad5a:	e9c0 1208 	strd	r1, r2, [r0, #32]
	sys_dlist_init(&w->waitq);
1800ad5e:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
1800ad62:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
1800ad66:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
1800ad6a:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
1800ad6c:	6343      	str	r3, [r0, #52]	; 0x34
}
1800ad6e:	4770      	bx	lr

1800ad70 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
1800ad70:	b510      	push	{r4, lr}
1800ad72:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
1800ad74:	f7ff ffba 	bl	1800acec <z_abort_timeout>

	if (inactive) {
1800ad78:	b9b0      	cbnz	r0, 1800ada8 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
1800ad7a:	6a63      	ldr	r3, [r4, #36]	; 0x24
1800ad7c:	b10b      	cbz	r3, 1800ad82 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
1800ad7e:	4620      	mov	r0, r4
1800ad80:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
1800ad82:	f104 0018 	add.w	r0, r4, #24
1800ad86:	f7ff ff66 	bl	1800ac56 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
1800ad8a:	b168      	cbz	r0, 1800ada8 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
1800ad8c:	f7ff ff07 	bl	1800ab9e <z_ready_thread>
	__asm__ volatile(
1800ad90:	f04f 0320 	mov.w	r3, #32
1800ad94:	f3ef 8011 	mrs	r0, BASEPRI
1800ad98:	f383 8812 	msr	BASEPRI_MAX, r3
1800ad9c:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
1800ada0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
1800ada4:	f7ff bedf 	b.w	1800ab66 <z_reschedule_irqlock>
1800ada8:	bd10      	pop	{r4, pc}

1800adaa <add_event>:
{
1800adaa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1800adac:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
1800adae:	e9d0 2300 	ldrd	r2, r3, [r0]
1800adb2:	4290      	cmp	r0, r2
1800adb4:	4604      	mov	r4, r0
1800adb6:	460d      	mov	r5, r1
1800adb8:	d105      	bne.n	1800adc6 <add_event+0x1c>
	sys_dnode_t *const tail = list->tail;
1800adba:	6863      	ldr	r3, [r4, #4]
	node->prev = tail;
1800adbc:	e9c5 4300 	strd	r4, r3, [r5]
	tail->next = node;
1800adc0:	601d      	str	r5, [r3, #0]
	list->tail = node;
1800adc2:	6065      	str	r5, [r4, #4]
}
1800adc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
1800adc6:	2b00      	cmp	r3, #0
1800adc8:	d0f7      	beq.n	1800adba <add_event+0x10>
		(z_sched_prio_cmp(poller_thread(pending->poller),
1800adca:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
1800adcc:	b100      	cbz	r0, 1800add0 <add_event+0x26>
1800adce:	3860      	subs	r0, #96	; 0x60
1800add0:	b107      	cbz	r7, 1800add4 <add_event+0x2a>
1800add2:	3f60      	subs	r7, #96	; 0x60
		(z_sched_prio_cmp(poller_thread(pending->poller),
1800add4:	4639      	mov	r1, r7
1800add6:	f7ff fe99 	bl	1800ab0c <z_sched_prio_cmp>
	if ((pending == NULL) ||
1800adda:	2800      	cmp	r0, #0
1800addc:	dced      	bgt.n	1800adba <add_event+0x10>
	return list->head == list;
1800adde:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1800ade0:	42b4      	cmp	r4, r6
1800ade2:	d0ea      	beq.n	1800adba <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
1800ade4:	2e00      	cmp	r6, #0
1800ade6:	d0e8      	beq.n	1800adba <add_event+0x10>
		if (z_sched_prio_cmp(poller_thread(poller),
1800ade8:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
1800adea:	b101      	cbz	r1, 1800adee <add_event+0x44>
1800adec:	3960      	subs	r1, #96	; 0x60
		if (z_sched_prio_cmp(poller_thread(poller),
1800adee:	4638      	mov	r0, r7
1800adf0:	f7ff fe8c 	bl	1800ab0c <z_sched_prio_cmp>
1800adf4:	2800      	cmp	r0, #0
1800adf6:	dd05      	ble.n	1800ae04 <add_event+0x5a>
	sys_dnode_t *const prev = successor->prev;
1800adf8:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
1800adfa:	e9c5 6300 	strd	r6, r3, [r5]
	prev->next = node;
1800adfe:	601d      	str	r5, [r3, #0]
	successor->prev = node;
1800ae00:	6075      	str	r5, [r6, #4]
			return;
1800ae02:	e7df      	b.n	1800adc4 <add_event+0x1a>
	return (node == list->tail) ? NULL : node->next;
1800ae04:	6863      	ldr	r3, [r4, #4]
1800ae06:	42b3      	cmp	r3, r6
1800ae08:	d0d7      	beq.n	1800adba <add_event+0x10>
1800ae0a:	6836      	ldr	r6, [r6, #0]
1800ae0c:	e7ea      	b.n	1800ade4 <add_event+0x3a>

1800ae0e <register_events>:
{
1800ae0e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
1800ae12:	2500      	movs	r5, #0
{
1800ae14:	468b      	mov	fp, r1
1800ae16:	4614      	mov	r4, r2
1800ae18:	461f      	mov	r7, r3
1800ae1a:	4682      	mov	sl, r0
	int events_registered = 0;
1800ae1c:	462e      	mov	r6, r5
	event->poller = NULL;
1800ae1e:	46a8      	mov	r8, r5
	for (int ii = 0; ii < num_events; ii++) {
1800ae20:	455d      	cmp	r5, fp
1800ae22:	db02      	blt.n	1800ae2a <register_events+0x1c>
}
1800ae24:	4630      	mov	r0, r6
1800ae26:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
1800ae2a:	f04f 0320 	mov.w	r3, #32
1800ae2e:	f3ef 8911 	mrs	r9, BASEPRI
1800ae32:	f383 8812 	msr	BASEPRI_MAX, r3
1800ae36:	f3bf 8f6f 	isb	sy
	switch (event->type) {
1800ae3a:	f89a 300d 	ldrb.w	r3, [sl, #13]
1800ae3e:	f003 031f 	and.w	r3, r3, #31
1800ae42:	3b01      	subs	r3, #1
1800ae44:	2b07      	cmp	r3, #7
1800ae46:	d80f      	bhi.n	1800ae68 <register_events+0x5a>
1800ae48:	e8df f003 	tbb	[pc, r3]
1800ae4c:	0a0e041e 	.word	0x0a0e041e
1800ae50:	250e0e0e 	.word	0x250e0e0e
		if (k_sem_count_get(event->sem) > 0U) {
1800ae54:	f8da 3010 	ldr.w	r3, [sl, #16]
1800ae58:	689b      	ldr	r3, [r3, #8]
1800ae5a:	b12b      	cbz	r3, 1800ae68 <register_events+0x5a>
			*state = K_POLL_STATE_SEM_AVAILABLE;
1800ae5c:	2302      	movs	r3, #2
1800ae5e:	e020      	b.n	1800aea2 <register_events+0x94>
		if (!k_queue_is_empty(event->queue)) {
1800ae60:	f8da 3010 	ldr.w	r3, [sl, #16]
1800ae64:	681b      	ldr	r3, [r3, #0]
1800ae66:	bb8b      	cbnz	r3, 1800aecc <register_events+0xbe>
		} else if (!just_check && poller->is_polling) {
1800ae68:	bb47      	cbnz	r7, 1800aebc <register_events+0xae>
1800ae6a:	7823      	ldrb	r3, [r4, #0]
1800ae6c:	b333      	cbz	r3, 1800aebc <register_events+0xae>
	switch (event->type) {
1800ae6e:	f89a 300d 	ldrb.w	r3, [sl, #13]
1800ae72:	f003 031f 	and.w	r3, r3, #31
1800ae76:	3b01      	subs	r3, #1
1800ae78:	2b07      	cmp	r3, #7
1800ae7a:	d830      	bhi.n	1800aede <register_events+0xd0>
1800ae7c:	e8df f003 	tbb	[pc, r3]
1800ae80:	282f2833 	.word	0x282f2833
1800ae84:	382f2f2f 	.word	0x382f2f2f
		if (event->signal->signaled != 0U) {
1800ae88:	f8da 3010 	ldr.w	r3, [sl, #16]
1800ae8c:	689b      	ldr	r3, [r3, #8]
1800ae8e:	2b00      	cmp	r3, #0
1800ae90:	d0ea      	beq.n	1800ae68 <register_events+0x5a>
			*state = K_POLL_STATE_SIGNALED;
1800ae92:	2301      	movs	r3, #1
1800ae94:	e005      	b.n	1800aea2 <register_events+0x94>
		if (event->msgq->used_msgs > 0) {
1800ae96:	f8da 3010 	ldr.w	r3, [sl, #16]
1800ae9a:	6a1b      	ldr	r3, [r3, #32]
1800ae9c:	2b00      	cmp	r3, #0
1800ae9e:	d0e3      	beq.n	1800ae68 <register_events+0x5a>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
1800aea0:	2310      	movs	r3, #16
	event->state |= state;
1800aea2:	f8da 200c 	ldr.w	r2, [sl, #12]
	event->poller = NULL;
1800aea6:	f8ca 8008 	str.w	r8, [sl, #8]
	event->state |= state;
1800aeaa:	f3c2 3145 	ubfx	r1, r2, #13, #6
1800aeae:	430b      	orrs	r3, r1
1800aeb0:	f363 3252 	bfi	r2, r3, #13, #6
1800aeb4:	f8ca 200c 	str.w	r2, [sl, #12]
			poller->is_polling = false;
1800aeb8:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
1800aebc:	f389 8811 	msr	BASEPRI, r9
1800aec0:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
1800aec4:	3501      	adds	r5, #1
1800aec6:	f10a 0a14 	add.w	sl, sl, #20
1800aeca:	e7a9      	b.n	1800ae20 <register_events+0x12>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
1800aecc:	2304      	movs	r3, #4
1800aece:	e7e8      	b.n	1800aea2 <register_events+0x94>
		add_event(&event->queue->poll_events, event, poller);
1800aed0:	4622      	mov	r2, r4
1800aed2:	4651      	mov	r1, sl
1800aed4:	f8da 0010 	ldr.w	r0, [sl, #16]
1800aed8:	3010      	adds	r0, #16
		add_event(&event->msgq->poll_events, event, poller);
1800aeda:	f7ff ff66 	bl	1800adaa <add_event>
	event->poller = poller;
1800aede:	f8ca 4008 	str.w	r4, [sl, #8]
			events_registered += 1;
1800aee2:	3601      	adds	r6, #1
1800aee4:	e7ea      	b.n	1800aebc <register_events+0xae>
		add_event(&event->signal->poll_events, event, poller);
1800aee6:	4622      	mov	r2, r4
1800aee8:	4651      	mov	r1, sl
1800aeea:	f8da 0010 	ldr.w	r0, [sl, #16]
1800aeee:	e7f4      	b.n	1800aeda <register_events+0xcc>
		add_event(&event->msgq->poll_events, event, poller);
1800aef0:	f8da 0010 	ldr.w	r0, [sl, #16]
1800aef4:	4622      	mov	r2, r4
1800aef6:	4651      	mov	r1, sl
1800aef8:	3024      	adds	r0, #36	; 0x24
1800aefa:	e7ee      	b.n	1800aeda <register_events+0xcc>

1800aefc <signal_poll_event>:
{
1800aefc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
1800af00:	6884      	ldr	r4, [r0, #8]
{
1800af02:	4605      	mov	r5, r0
1800af04:	460e      	mov	r6, r1
	if (poller != NULL) {
1800af06:	b144      	cbz	r4, 1800af1a <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
1800af08:	7863      	ldrb	r3, [r4, #1]
1800af0a:	2b01      	cmp	r3, #1
1800af0c:	d136      	bne.n	1800af7c <signal_poll_event+0x80>
	if (!z_is_thread_pending(thread)) {
1800af0e:	f814 3c53 	ldrb.w	r3, [r4, #-83]
1800af12:	f013 0302 	ands.w	r3, r3, #2
1800af16:	d10a      	bne.n	1800af2e <signal_poll_event+0x32>
		poller->is_polling = false;
1800af18:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
1800af1a:	2000      	movs	r0, #0
	event->state |= state;
1800af1c:	68eb      	ldr	r3, [r5, #12]
	event->poller = NULL;
1800af1e:	60a8      	str	r0, [r5, #8]
	event->state |= state;
1800af20:	f3c3 3145 	ubfx	r1, r3, #13, #6
1800af24:	430e      	orrs	r6, r1
1800af26:	f366 3352 	bfi	r3, r6, #13, #6
1800af2a:	60eb      	str	r3, [r5, #12]
	return retcode;
1800af2c:	e00b      	b.n	1800af46 <signal_poll_event+0x4a>
	if (z_is_thread_timeout_expired(thread)) {
1800af2e:	e954 230e 	ldrd	r2, r3, [r4, #-56]	; 0x38
1800af32:	f1b3 3fff 	cmp.w	r3, #4294967295
1800af36:	bf08      	it	eq
1800af38:	f112 0f02 	cmneq.w	r2, #2
1800af3c:	d105      	bne.n	1800af4a <signal_poll_event+0x4e>
		poller->is_polling = false;
1800af3e:	2300      	movs	r3, #0
		return -EAGAIN;
1800af40:	f06f 000a 	mvn.w	r0, #10
		poller->is_polling = false;
1800af44:	7023      	strb	r3, [r4, #0]
}
1800af46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
1800af4a:	f1a4 0860 	sub.w	r8, r4, #96	; 0x60
	z_unpend_thread(thread);
1800af4e:	4640      	mov	r0, r8
1800af50:	f7ff fdf5 	bl	1800ab3e <z_unpend_thread>
	arch_thread_return_value_set(thread,
1800af54:	2e08      	cmp	r6, #8
1800af56:	bf0c      	ite	eq
1800af58:	f06f 0303 	mvneq.w	r3, #3
1800af5c:	2300      	movne	r3, #0
1800af5e:	6523      	str	r3, [r4, #80]	; 0x50
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
1800af60:	f814 3c53 	ldrb.w	r3, [r4, #-83]
1800af64:	06db      	lsls	r3, r3, #27
1800af66:	d102      	bne.n	1800af6e <signal_poll_event+0x72>
	if (!z_is_thread_ready(thread)) {
1800af68:	f854 7c48 	ldr.w	r7, [r4, #-72]
1800af6c:	b10f      	cbz	r7, 1800af72 <signal_poll_event+0x76>
		poller->is_polling = false;
1800af6e:	2300      	movs	r3, #0
1800af70:	e7d2      	b.n	1800af18 <signal_poll_event+0x1c>
	z_ready_thread(thread);
1800af72:	4640      	mov	r0, r8
1800af74:	f7ff fe13 	bl	1800ab9e <z_ready_thread>
		poller->is_polling = false;
1800af78:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
1800af7a:	e7ce      	b.n	1800af1a <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
1800af7c:	2b02      	cmp	r3, #2
1800af7e:	d1f6      	bne.n	1800af6e <signal_poll_event+0x72>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
1800af80:	7823      	ldrb	r3, [r4, #0]
1800af82:	2b00      	cmp	r3, #0
1800af84:	d0c9      	beq.n	1800af1a <signal_poll_event+0x1e>
1800af86:	f854 7c04 	ldr.w	r7, [r4, #-4]
1800af8a:	2f00      	cmp	r7, #0
1800af8c:	d0f4      	beq.n	1800af78 <signal_poll_event+0x7c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
1800af8e:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
1800af92:	f1a4 0914 	sub.w	r9, r4, #20
1800af96:	f104 0014 	add.w	r0, r4, #20
1800af9a:	f7ff fea7 	bl	1800acec <z_abort_timeout>
		k_work_submit_to_queue(work_q, &twork->work);
1800af9e:	4649      	mov	r1, r9
1800afa0:	4638      	mov	r0, r7
		twork->poll_result = 0;
1800afa2:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		k_work_submit_to_queue(work_q, &twork->work);
1800afa6:	f000 f876 	bl	1800b096 <k_work_submit_to_queue>
		poller->is_polling = false;
1800afaa:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
1800afae:	e7b4      	b.n	1800af1a <signal_poll_event+0x1e>

1800afb0 <clear_event_registrations>:
	while (num_events--) {
1800afb0:	2314      	movs	r3, #20
{
1800afb2:	b5f0      	push	{r4, r5, r6, r7, lr}
	event->poller = NULL;
1800afb4:	2400      	movs	r4, #0
1800afb6:	2601      	movs	r6, #1
1800afb8:	fb03 0001 	mla	r0, r3, r1, r0
	while (num_events--) {
1800afbc:	b901      	cbnz	r1, 1800afc0 <clear_event_registrations+0x10>
}
1800afbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (event->type) {
1800afc0:	f810 3c07 	ldrb.w	r3, [r0, #-7]
1800afc4:	f1a0 0714 	sub.w	r7, r0, #20
1800afc8:	f003 031f 	and.w	r3, r3, #31
1800afcc:	2b08      	cmp	r3, #8
	event->poller = NULL;
1800afce:	f840 4c0c 	str.w	r4, [r0, #-12]
	switch (event->type) {
1800afd2:	d80d      	bhi.n	1800aff0 <clear_event_registrations+0x40>
1800afd4:	fa06 f303 	lsl.w	r3, r6, r3
1800afd8:	f413 7f8b 	tst.w	r3, #278	; 0x116
1800afdc:	d008      	beq.n	1800aff0 <clear_event_registrations+0x40>
	return node->next != NULL;
1800afde:	f850 3c14 	ldr.w	r3, [r0, #-20]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
1800afe2:	b12b      	cbz	r3, 1800aff0 <clear_event_registrations+0x40>
	sys_dnode_t *const prev = node->prev;
1800afe4:	f850 5c10 	ldr.w	r5, [r0, #-16]
	prev->next = next;
1800afe8:	602b      	str	r3, [r5, #0]
	next->prev = prev;
1800afea:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
1800afec:	e940 4405 	strd	r4, r4, [r0, #-20]
1800aff0:	f382 8811 	msr	BASEPRI, r2
1800aff4:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
1800aff8:	f04f 0320 	mov.w	r3, #32
1800affc:	f3ef 8211 	mrs	r2, BASEPRI
1800b000:	f383 8812 	msr	BASEPRI_MAX, r3
1800b004:	f3bf 8f6f 	isb	sy
1800b008:	4638      	mov	r0, r7
1800b00a:	3901      	subs	r1, #1
1800b00c:	e7d6      	b.n	1800afbc <clear_event_registrations+0xc>

1800b00e <k_poll_event_init>:
{
1800b00e:	b510      	push	{r4, lr}
	event->poller = NULL;
1800b010:	2400      	movs	r4, #0
	event->type = type;
1800b012:	04d2      	lsls	r2, r2, #19
1800b014:	0209      	lsls	r1, r1, #8
1800b016:	f401 51f8 	and.w	r1, r1, #7936	; 0x1f00
1800b01a:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
1800b01e:	430a      	orrs	r2, r1
1800b020:	7b01      	ldrb	r1, [r0, #12]
	event->poller = NULL;
1800b022:	6084      	str	r4, [r0, #8]
	event->type = type;
1800b024:	430a      	orrs	r2, r1
	event->obj = obj;
1800b026:	e9c0 2303 	strd	r2, r3, [r0, #12]
}
1800b02a:	bd10      	pop	{r4, pc}

1800b02c <z_handle_obj_poll_events>:
{
1800b02c:	4603      	mov	r3, r0
	return list->head == list;
1800b02e:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
1800b030:	4283      	cmp	r3, r0
1800b032:	d008      	beq.n	1800b046 <z_handle_obj_poll_events+0x1a>
	sys_dnode_t *const next = node->next;
1800b034:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
1800b038:	6013      	str	r3, [r2, #0]
	next->prev = prev;
1800b03a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
1800b03c:	2300      	movs	r3, #0
	node->prev = NULL;
1800b03e:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
1800b042:	f7ff bf5b 	b.w	1800aefc <signal_poll_event>
}
1800b046:	4770      	bx	lr

1800b048 <z_impl_k_poll_signal_init>:
	sig->signaled = 0U;
1800b048:	2300      	movs	r3, #0
	list->tail = (sys_dnode_t *)list;
1800b04a:	e9c0 0000 	strd	r0, r0, [r0]
1800b04e:	6083      	str	r3, [r0, #8]
}
1800b050:	4770      	bx	lr

1800b052 <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
1800b052:	2300      	movs	r3, #0
1800b054:	6083      	str	r3, [r0, #8]
}
1800b056:	4770      	bx	lr

1800b058 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
1800b058:	6883      	ldr	r3, [r0, #8]
1800b05a:	600b      	str	r3, [r1, #0]
	*result = sig->result;
1800b05c:	68c3      	ldr	r3, [r0, #12]
1800b05e:	6013      	str	r3, [r2, #0]
}
1800b060:	4770      	bx	lr

1800b062 <k_heap_init>:
{
1800b062:	b410      	push	{r4}
1800b064:	f100 040c 	add.w	r4, r0, #12
1800b068:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
1800b06c:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
1800b06e:	f7fd b8b0 	b.w	180081d2 <sys_heap_init>

1800b072 <flag_test_and_clear>:
	*flagp &= ~BIT(bit);
1800b072:	2301      	movs	r3, #1
	return (*flagp & BIT(bit)) != 0U;
1800b074:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
1800b076:	408b      	lsls	r3, r1
1800b078:	ea22 0303 	bic.w	r3, r2, r3
1800b07c:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
1800b07e:	fa22 f001 	lsr.w	r0, r2, r1
}
1800b082:	f000 0001 	and.w	r0, r0, #1
1800b086:	4770      	bx	lr

1800b088 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
1800b088:	b120      	cbz	r0, 1800b094 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
1800b08a:	2200      	movs	r2, #0
1800b08c:	30c0      	adds	r0, #192	; 0xc0
1800b08e:	4611      	mov	r1, r2
1800b090:	f7ff be0e 	b.w	1800acb0 <z_sched_wake>
}
1800b094:	4770      	bx	lr

1800b096 <k_work_submit_to_queue>:
{
1800b096:	b537      	push	{r0, r1, r2, r4, r5, lr}
1800b098:	9001      	str	r0, [sp, #4]
1800b09a:	4608      	mov	r0, r1
1800b09c:	f04f 0320 	mov.w	r3, #32
1800b0a0:	f3ef 8511 	mrs	r5, BASEPRI
1800b0a4:	f383 8812 	msr	BASEPRI_MAX, r3
1800b0a8:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
1800b0ac:	a901      	add	r1, sp, #4
1800b0ae:	f7fc ff45 	bl	18007f3c <submit_to_queue_locked>
1800b0b2:	4604      	mov	r4, r0
	__asm__ volatile(
1800b0b4:	f385 8811 	msr	BASEPRI, r5
1800b0b8:	f3bf 8f6f 	isb	sy
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
1800b0bc:	2800      	cmp	r0, #0
1800b0be:	dd04      	ble.n	1800b0ca <k_work_submit_to_queue+0x34>
	return z_impl_k_is_preempt_thread();
1800b0c0:	f7fc fb70 	bl	180077a4 <z_impl_k_is_preempt_thread>
1800b0c4:	b108      	cbz	r0, 1800b0ca <k_work_submit_to_queue+0x34>
	z_impl_k_yield();
1800b0c6:	f7fc fac7 	bl	18007658 <z_impl_k_yield>
}
1800b0ca:	4620      	mov	r0, r4
1800b0cc:	b003      	add	sp, #12
1800b0ce:	bd30      	pop	{r4, r5, pc}
